<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on 白菜林</title>
    <link>https://3ae.cn/tags/golang/</link>
    <description>Recent content in Golang on 白菜林</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>baicai</copyright>
    <lastBuildDate>Wed, 04 Aug 2021 16:12:56 +0800</lastBuildDate><atom:link href="https://3ae.cn/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用 df 命令查看 Linux 上的可用磁盘空间</title>
      <link>https://3ae.cn/article/2021/check-disk-space-linux-df/</link>
      <pubDate>Wed, 04 Aug 2021 16:12:56 +0800</pubDate>
      
      <guid>https://3ae.cn/article/2021/check-disk-space-linux-df/</guid>
      <description>磁盘空间已经不像计算机早期那样珍贵，但无论你有多少磁盘空间，总有耗尽的可能。计算机需要一些磁盘空间才能启动运行，所以为了确保你没有在无意间用尽了所有的硬盘空间，偶尔检查一下是非常必要的。在 Linux 终端，你可以用 df 命令来做这件事。
df 命令可以显示文件系统中可用的磁盘空间。
要想使输出结果易于阅读，你可以加上 &amp;ndash;human-readable（或其简写 -h）选项：
$ df --human-readable Filesystem Size Used Avail Use% Mounted on /dev/sda1 1.0T 525G 500G 52% / 在这个例子中，计算机的磁盘已经用了 52%，还有 500 GB 可用空间。
由于 Linux 从整体上看待所有挂载设备的文件系统，df 命令会展示出连接到计算机上的每个存储设备的详细信息。如果你有很多磁盘，那么输出结果将会反映出来：
$ df --human-readable Filesystem Size Used Avail Use% Mounted on /dev/root 110G 45G 61G 43% / devtmpfs 12G 0 12G 0% /dev tmpfs 12G 848K 12G 1% /run /dev/sda1 1.6T 1.3T 191G 87% /home /dev/sdb1 917G 184G 687G 22% /penguin /dev/sdc1 57G 50G 4.</description>
    </item>
    
    <item>
      <title>Goproxy</title>
      <link>https://3ae.cn/article/2021/goproxy/</link>
      <pubDate>Thu, 27 May 2021 11:22:40 +0800</pubDate>
      
      <guid>https://3ae.cn/article/2021/goproxy/</guid>
      <description>Go Module代理仓库服务 七牛云提供的：https://goproxy.cn/
goproxy.io：https://goproxy.io/
百度云BOS提供的：https://goproxy.baidu.com/
阿里云提供的：https://mirrors.aliyun.com/goproxy/
下载 Go 镜像（Golang Downloads Mirrors） 下载 Go 镜像：https://golang.google.cn/
下载 Go 镜像：https://gomirrors.org/
下载 Go 镜像：https://studygolang.com/dl</description>
    </item>
    
    <item>
      <title>使用 Golang 的交叉编译</title>
      <link>https://3ae.cn/article/2021/go_cross_compilling/</link>
      <pubDate>Thu, 13 May 2021 14:35:47 +0800</pubDate>
      
      <guid>https://3ae.cn/article/2021/go_cross_compilling/</guid>
      <description>在 Linux 上测试软件时，我使用各种架构的服务器，例如 Intel、AMD、Arm 等。当我 分配了一台满足我的测试需求的 Linux 机器[1]，我仍然需要执行许多步骤：
  下载并安装必备软件 验证构建服务器上是否有新的测试软件包 获取并设置依赖软件包所需的 yum 仓库 下载并安装新的测试软件包（基于步骤 2） 获取并设置必需的 SSL 证书 设置测试环境，获取所需的 Git 仓库，更改配置，重新启动守护进程等 做其他需要做的事情  用脚本自动化 这些步骤非常常规，以至于有必要对其进行自动化并将脚本保存到中央位置（例如文件服务器），在需要时可以在此处下载脚本。为此，我编写了 100-120 行的 Bash shell 脚本，它为我完成了所有配置（包括错误检查）。这个脚本通过以下方式简化了我的工作流程：
 配置新的 Linux 系统（支持测试的架构） 登录系统并从中央位置下载自动化 shell 脚本 运行它来配置系统 开始测试  学习 Go 语言 我想学习 Go 语言 有一段时间了，将我心爱的 Shell 脚本转换为 Go 程序似乎是一个很好的项目，可以帮助我入门。它的语法看起来很简单，在尝试了一些测试程序后，我开始着手提高自己的知识并熟悉 Go 标准库。
我花了一个星期的时间在笔记本电脑上编写 Go 程序。我经常在我的 x86 服务器上测试程序，清除错误并使程序健壮起来，一切都很顺利。
直到完全转换到 Go 程序前，我继续依赖自己的 shell 脚本。然后，我将二进制文件推送到中央文件服务器上，以便每次配置新服务器时，我要做的就是获取二进制文件，将可执行标志打开，然后运行二进制文件。我对早期的结果很满意：
$ wget http://file.example.com/&amp;lt;myuser&amp;gt;/bins/prepnode $ chmod +x .</description>
    </item>
    
  </channel>
</rss>
