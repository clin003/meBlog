[{"categories":["开发技能","编程经验","收集与整理"],"content":"Swift介绍 Swift 是一门开发 iOS, macOS, watchOS 和 tvOS 应用的新语言。 swift 是一种安全，快速和互动的编程语言。 swift 支持代码预览（playgrounds），这个特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。 Swift 通过采用现代编程模式来避免大量常见编程错误： 变量始终在使用前初始化。 检查数组索引超出范围的错误。 检查整数是否溢出。 可选值确保明确处理 nil 值。 内存被自动管理。 错误处理允许从意外故障控制恢复。 ","date":"2021-05-13","objectID":"/article/2021/swift-basic-syntax/:0:1","tags":["swift","语法基础","编程学习","ios"],"title":"Swift语法全面解析","uri":"/article/2021/swift-basic-syntax/"},{"categories":["开发技能","编程经验","收集与整理"],"content":"基础部分 常量和变量 声明常量和变量， 常量和变量必须在使用前声明，使用 let 来声明常量，使用 var 来声明变量。 示例： let maximumNumberOfLoginAttempts = 10 var currentLoginAttempt = 0 // 类型注解 var welcomeMessage: String 注释 单行注释双正斜杠（//）， 多行注释（/* 多行的 */）。Swift 的多行注释可以嵌套在其它的多行注释之中。 示例： // 这是一个注释 /* 这也是一个注释， 但是是多行的 */ /* 这是第一个多行注释的开头 /* 这是第二个被嵌套的多行注释 */ 这是第一个多行注释的结尾 */ 分号 Swift 并不强制要求你在每条语句的结尾处使用分号（;）。 同一行内写多条独立的语句必须用分号分隔。 let cat = \"🐱\"; print(cat) // 输出“🐱” 标识符 标识符就是给变量、常量、方法、函数、枚举、结构体、类、协议等指定的名字。构成标识符的字母均有一定的规范，Swift语言中标识符的命名规则如下： 区分大小写，Myname与myname是两个不同的标识符； 标识符首字符可以以下划线（_）或者字母开始，但不能是数字； 标识符中其他字符可以是下划线（_）、字母或数字。 例如： userName、User_Name、_sys_val、身高等为合法的标识符，而2mail、room#和class为非法的标识符。 注意:Swift中的字母采用的是Unicode编码。Unicode叫做统一编码制，它包含了亚洲文字编码，如中文、日文、韩文等字符，甚至是我们在聊天工具中使用的表情符号 如果一定要使用关键字作为标识符，可以在关键字前后添加重音符号（`），例如： let `class` = \"xiaobai\" 关键字 关键字是类似于标识符的保留字符序列，除非用重音符号（`）将其括起来，否则不能用作标识符。关键字是对编译器具有特殊意义的预定义保留标识符。常见的关键字有以下4种。 与声明有关的关键字 class deinit enum extension func import init internal let operator private protocol public static struct subscript typealias var 与语句有关的关键字 break case continue default do else fallthrough for if in return switch where while 表达式和类型关键字 as dynamicType false is nil self Self super true _COLUMN_ _FILE_ _FUNCTION_ _LINE_ 在特定上下文中使用的关键字 associativity convenience dynamic didSet final get infix inout lazy left mutating none nonmutating optional override postfix precedence prefix Protocol required right set Type unowned weak willSet Swift 空格 Swift对空格的使用有一定的要求。 在Swift中，运算符不能直接跟在变量或常量的后面。例如下面的代码会报错： let a= 1 + 2 错误信息是： error: prefix/postfix '=' is reserved 意思大概是等号直接跟在前面或后面这种用法是保留的。 下面的代码还是会报错（继续注意空格）： let a = 1+ 2 错误信息是： error: consecutive statements on a line must be separated by ';' 这是因为Swift认为到1+这个语句就结束了，2就是下一个语句了。 只有这样写才不会报错： let a = 1 + 2; // 编码规范推荐使用这种写法 let b = 3+4 // 这样也是OK的 整数、浮点数 统一使用 Int 可以提高代码的可复用性，避免不同类型数字之间的转换， 并且匹配数字的类型推断。 示例： let minValue = UInt8.min // minValue 为 0，是 UInt8 类型 let maxValue = UInt8.max // maxValue 为 255，是 UInt8 类型 类型安全和类型推断 Swift 是一门类型安全的语言，这意味着 Swift 可以让你清楚地知道值的类型。 如果你没有显式指定类型，Swift 会使用类型推断来选择合适的类型。（int、double）。 示例： let meaningOfLife = 42 // meaningOfLife 会被推测为 Int 类型 let pi = 3.14159 // pi 会被推测为 Double 类型 数值型字面量、数值型类型转换 示例： let decimalInteger = 17 let binaryInteger = 0b10001 // 二进制的17 let octalInteger = 0o21 // 八进制的17 let hexadecimalInteger = 0x11 // 十六进制的17 类型别名 类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用 typealias 关键字来定义类型别名。 示例： typealias AudioSample = UInt16 var maxAmplitudeFound = AudioSample.min // maxAmplitudeFound 现在是 0 布尔值 示例： let orangesAreOrange = true let turnipsAreDelicious = false 元组 元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。 示例： let http404Error = (404, \"Not Found\") // http404Error 的类型是 (Int, String)，值是 (404, \"Not Found\") 可选类型 使用可选类型（optionals）来处理值可能缺失的情况。可选类型表示两种可能：或者有值， 你可以解析可选类型访问这个值， 或者根本没有值。 示例： var serverResponseCode: Int? = 404 // serverResponseCode 包含一个可选的 Int 值 404 serverResponseCode = nil // serverResponseCode 现在不包含值 错误处理 错误处理，应对程序执行中可能会遇到的错误条件。 示例： func makeASandwich() throws { // ... } do { try makeASandwich() eatASandwich() } catch SandwichError.outOfCleanDishes { washDishes() } catch SandwichError.missingIngredients(let ingredients) { buyGroceries(ingredients) } 断言和先决条件 断言和先决条件，是在运行时所做的检查。 let age = -3 assert(age \u003e= 0, \"A person's age cannot be less than zero\") // 因为 age \u003c 0，所以断言会触发 基本运算符 Swift 支持大部分标准 C 语言的运算符，还提供了 C 语言没有的区间运算符，例如 a..\u003cb 或 a...b。 赋值运算符，算术运算符，组合赋值运算符，比较运算符，三元运算符，空合运算符，区间运算符，逻辑运算符 运算符分为一元、二元和三元运算符。 闭区间运算符（a…b）定义一个包含从 a 到 b（包括 a 和 b）的所有值的区间。 半开区间运算符（a..\u003cb）定义一个从 a 到 b 但不包括 b 的区间。 闭区间操作符有另一个表达形式，可以表达往一侧无限延伸的区间，(a…，…b)。 示例： let names = [\"Anna\", \"Alex\", \"Brian\", \"Jack\"] let count = names.count for i in 0..\u003ccount { print(\"第 \\(i + 1)个人叫 \\(names[i])\") } // 第 1 个人叫 Anna // 第 2 个人叫 Alex // 第 3 个人叫 Brian // 第 4 个人叫 Jack 字符串和字符 字符串字面量，字符串插值，计算字符数量，访问和修改字符串，子字符串，比较字符串 初始化空字符串，字符串可变性，字符串是值类型，连接字符串和字符(+，+=)。 使用字符，可通过 for-in 循环来遍历字符串，获取字符串中每一个字符的值。 字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。可以在已有字符串中插入常量、变量、字面量和表达式从而形成更长的字符串。 Swift 提供了三种方式来比较文本值：字符串字符相等、前缀相等和后缀相等。 示例： // 多行字符串字面量 let quotation = \"\"\" The White Rabbit put on hi","date":"2021-05-13","objectID":"/article/2021/swift-basic-syntax/:0:2","tags":["swift","语法基础","编程学习","ios"],"title":"Swift语法全面解析","uri":"/article/2021/swift-basic-syntax/"},{"categories":["收集与整理","编程经验"],"content":" 在 Linux 上测试软件时，我使用各种架构的服务器，例如 Intel、AMD、Arm 等。当我 分配了一台满足我的测试需求的 Linux 机器[1]，我仍然需要执行许多步骤： 下载并安装必备软件 验证构建服务器上是否有新的测试软件包 获取并设置依赖软件包所需的 yum 仓库 下载并安装新的测试软件包（基于步骤 2） 获取并设置必需的 SSL 证书 设置测试环境，获取所需的 Git 仓库，更改配置，重新启动守护进程等 做其他需要做的事情 ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:0","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"用脚本自动化 这些步骤非常常规，以至于有必要对其进行自动化并将脚本保存到中央位置（例如文件服务器），在需要时可以在此处下载脚本。为此，我编写了 100-120 行的 Bash shell 脚本，它为我完成了所有配置（包括错误检查）。这个脚本通过以下方式简化了我的工作流程： 配置新的 Linux 系统（支持测试的架构） 登录系统并从中央位置下载自动化 shell 脚本 运行它来配置系统 开始测试 ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:1","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"学习 Go 语言 我想学习 Go 语言 有一段时间了，将我心爱的 Shell 脚本转换为 Go 程序似乎是一个很好的项目，可以帮助我入门。它的语法看起来很简单，在尝试了一些测试程序后，我开始着手提高自己的知识并熟悉 Go 标准库。 我花了一个星期的时间在笔记本电脑上编写 Go 程序。我经常在我的 x86 服务器上测试程序，清除错误并使程序健壮起来，一切都很顺利。 直到完全转换到 Go 程序前，我继续依赖自己的 shell 脚本。然后，我将二进制文件推送到中央文件服务器上，以便每次配置新服务器时，我要做的就是获取二进制文件，将可执行标志打开，然后运行二进制文件。我对早期的结果很满意： $ wget http://file.example.com/\u003cmyuser\u003e/bins/prepnode $ chmod +x ./prepnode $ ./prepnode 然后，出现了一个问题 第二周，我从资源池中分配了一台新的服务器，像往常一样，我下载了二进制文件，设置了可执行标志，然后运行二进制文件。但这次它出错了，是一个奇怪的错误： $ ./prepnode bash: ./prepnode: cannot execute binary file: Exec format error $ 起初，我以为可能没有成功设置可执行标志。但是，它已按预期设置： $ ls -l prepnode -rwxr-xr-x. 1 root root 2640529 Dec 16 05:43 prepnode 发生了什么事？我没有对源代码进行任何更改，编译没有引发任何错误或警告，而且上次运行时效果很好，因此我仔细查看了错误消息 format error。 我检查了二进制文件的格式，一切看起来都没问题： $ file prepnode prepnode: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped 我迅速运行了以下命令，识别所配置的测试服务器的架构以及二进制试图运行的平台。它是 Arm64 架构，但是我编译的二进制文件（在我的 x86 笔记本电脑上）生成的是 x86-64 格式的二进制文件： $ uname -m aarch64 ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:2","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"脚本编写人员的编译第一课 在那之前，我从未考虑过这种情况（尽管我知道这一点）。我主要研究脚本语言（通常是 Python）以及 Shell 脚本。在任何架构的大多数 Linux 服务器上都可以使用 Bash Shell 和 Python 解释器。总之，之前一切都很顺利。 但是，现在我正在处理 Go 这种编译语言，它生成可执行的二进制文件。编译后的二进制文件由特定架构的指令码或汇编指令组成，这就是为什么我收到格式错误的原因。由于 Arm64 CPU（运行二进制文件的地方）无法解释二进制文件的 x86-64 指令，因此它抛出错误。以前，shell 和 Python 解释器为我处理了底层指令码或特定架构的指令。 ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:3","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"Go 的交叉编译 我检查了 Golang 的文档，发现要生成 Arm64 二进制文件，我要做的就是在运行 go build 命令编译 Go 程序之前设置两个环境变量。 GOOS 指的是操作系统，例如 Linux、Windows、BSD 等，而 GOARCH 指的是要在哪种架构上构建程序。 $ env GOOS=linux GOARCH=arm64 go build -o prepnode_arm64 构建程序后，我重新运行 file 命令，这一次它显示的是 ARM AArch64，而不是之前显示的 x86。因此，我在我的笔记本上能为不同的架构构建二进制文件。 $ file prepnode_arm64 prepnode_arm64: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, not stripped 我将二进制文件从笔记本电脑复制到 ARM 服务器上。现在运行二进制文件（将可执行标志打开）不会产生任何错误： $ ./prepnode_arm64 -h Usage of ./prepnode_arm64: -c Clean existing installation -n Do not start test run (default true) -s Use stage environment, default is qa -v Enable verbose output ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:4","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"其他架构呢？ x86 和 Arm 是我测试软件所支持的 5 种架构中的两种，我担心 Go 可能不会支持其它架构，但事实并非如此。你可以查看 Go 支持的架构： $ go tool dist list Go 支持多种平台和操作系统，包括： AIX Android Darwin Dragonfly FreeBSD Illumos ios Js/wasm JavaScript Linux NetBSD OpenBSD Plan 9 Solaris Windows 要查找其支持的特定 Linux 架构，运行： $ go tool dist list | grep linux 如下面的输出所示，Go 支持我使用的所有体系结构。尽管 x86_64 不在列表中，但 AMD64 兼容 x86-64，所以你可以生成 AMD64 二进制文件，它可以在 x86 架构上正常运行： $ go tool dist list | grep linux linux/386 linux/amd64 linux/arm linux/arm64 linux/mips linux/mips64 linux/mips64le linux/mipsle linux/ppc64 linux/ppc64le linux/riscv64 linux/s390x ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:5","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"处理所有架构 为我测试的所有体系结构生成二进制文件，就像从我的 x86 笔记本电脑编写一个微小的 shell 脚本一样简单： #!/usr/bin/bash archs=(amd64 arm64 ppc64le ppc64 s390x) for arch in ${archs[@]} do env GOOS=linux GOARCH=${arch} go build -o prepnode_${arch} done $ file prepnode_* prepnode_amd64: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=y03MzCXoZERH-0EwAAYI/p909FDnk7xEUo2LdHIyo/V2ABa7X_rLkPNHaFqUQ6/5p_q8MZiR2WYkA5CzJiF, not stripped prepnode_arm64: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, Go BuildID=q-H-CCtLv__jVOcdcOpA/CywRwDz9LN2Wk_fWeJHt/K4-3P5tU2mzlWJa0noGN/SEev9TJFyvHdKZnPaZgb, not stripped prepnode_ppc64: ELF 64-bit MSB executable, 64-bit PowerPC or cisco 7500, version 1 (SYSV), statically linked, Go BuildID=DMWfc1QwOGIq2hxEzL_u/UE-9CIvkIMeNC_ocW4ry/r-7NcMATXatoXJQz3yUO/xzfiDIBuUxbuiyaw5Goq, not stripped prepnode_ppc64le: ELF 64-bit LSB executable, 64-bit PowerPC or cisco 7500, version 1 (SYSV), statically linked, Go BuildID=C6qCjxwO9s63FJKDrv3f/xCJa4E6LPVpEZqmbF6B4/Mu6T_OR-dx-vLavn1Gyq/AWR1pK1cLz9YzLSFt5eU, not stripped prepnode_s390x: ELF 64-bit MSB executable, IBM S/390, version 1 (SYSV), statically linked, Go BuildID=faC_HDe1_iVq2XhpPD3d/7TIv0rulE4RZybgJVmPz/o_SZW_0iS0EkJJZHANxx/zuZgo79Je7zAs3v6Lxuz, not stripped 现在，每当配置一台新机器时，我就运行以下 wget 命令下载特定体系结构的二进制文件，将可执行标志打开，然后运行： $ wget http://file.domain.com/\u003cmyuser\u003e/bins/prepnode_\u003carch\u003e $ chmod +x ./prepnode_\u003carch\u003e $ ./prepnode_\u003carch\u003e ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:6","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"为什么？ 你可能想知道，为什么我没有坚持使用 shell 脚本或将程序移植到 Python 而不是编译语言上来避免这些麻烦。所以有舍有得，那样的话我不会了解 Go 的交叉编译功能，以及程序在 CPU 上执行时的底层工作原理。在计算机中，总要考虑取舍，但绝不要让它们阻碍你的学习。 ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:7","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"参考 Cross-compiling made easy with Golang [1] 使用 Golang 的交叉编译 [2] ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:8","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["Using Software"],"content":" 学习基本的 GNU Screen 终端复用技术，然后下载我们的终端命令备忘录，以便你能够熟悉常用的快捷方式。 对于一般用户而言，命令行终端窗口可能是令人困惑和神秘的。但随着你对 Linux 终端的进一步了解，你很快就会意识到它的高效和强大。不过，也不需要很长时间，你就会想让终端变得更加高效，除了将更多的终端放到你的终端，还有什么高好的方法能够提升你的终端效率呢？ ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:0","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"终端复用 终端的许多优点之一是它是一个集中控制的界面。它是一个能让你访问数百个应用程序的窗口，而你与每一个应用程序进行交互所需要的只是一个键盘。但是，现代计算机几乎总是有多余的处理能力，而且现代计算机专家喜欢多任务处理，导致一个窗口处理数百个应用程序的能力是相当有限的。 解决这一问题的常见答案是终端复用：即将虚拟终端叠放在一起，然后在它们之间移动的能力。通过终端复用器，你保持了集中控制，但是当你进行多任务时，你能够进行终端切换。更好的是，你能够在终端中拆分屏幕，使得在同一时间显示多个屏幕窗口。 ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:1","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"选择合适的复用器 一些终端提供类似的功能，有标签式界面和分割式视图，但也有细微的差别。首先，这些终端的功能依赖于图形化的桌面环境。其次，许多图形化的终端功能需要鼠标交互或使用不方便的键盘快捷键。终端复用器的功能在文本控制台上和在图形桌面上一样好用，而且键位绑定是针对常见的终端序列设计的，很方便。 现有两种流行的复用器：tmux 和 GNU Screen。尽管你与它们互动的方式略有不同，但它们做同样的事情，而且大多具有相同的功能。这篇文章是 GNU Screen 的入门指南。关于 tmux 的相关介绍，请阅读 Kevin Sonney 的 tmux 介绍。 ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:2","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"使用 GNU Screen GNU Screen 的基本用法很简单，通过 screen 命令启动，你将进入 Screen 会话的第 0 个窗口。在你决定需要一个新的终端提示符前，你可能很难注意到有什么变化。 当一个终端窗口被某项活动占用（比如，你启动了文本编辑器 Vim 或 Jove 或者你在处理音视频，或运行批处理任务），你可以新建一个窗口。要打开一个新的窗口，按 Ctrl+A，释放，然后按 c。这将在你现有窗口的基础上创建一个新的窗口。 你会知道当前你是在一个新的窗口中，因为你的终端除了默认的提示符外，似乎没有任何东西。当然，你的另一个终端仍然存在，它只是躲在新窗口的后面。要遍历打开的窗口，按 Ctrl+A，释放，然后按 n（表示下一个）或按 p（表示上一个）。在只打开两个窗口的情况下， n 和 p 的功能是一样的，但你可以随时打开更多的窗口（Ctrl+A，然后 c ），并在它们之间切换。 ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:3","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"分屏 GNU Screen 的默认行为更像移动设备的屏幕，而不是桌面：你一次只能看到一个窗口。如果你因为喜欢多任务而使用 GNU Screen ，那么只关注一个窗口可能看起来是一种退步。幸运的是，GNU Screen 可以让你把终端分成窗口中的窗口。 要创建一个水平分割窗口，按 Ctrl+A，然后按 s 。这将把一个窗口置于另一个窗口之上，就像窗格一样。然而，在你告诉它要显示什么之前，分割的空间是没有用途的。因此，在创建一个分割窗后，你可以用 Ctrl+A ，然后用 Tab 移动到分割窗中。一旦进入，使用 Ctrl+A 然后 n 浏览所有可用的窗口，直到你想显示的内容出现在分割窗格中。 你也可以按 Ctrl+A 然后按 | （这是一个管道字符，在大多数键盘上通过按下 shift 键加上 \\）创建垂直分割窗口。 ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:4","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"自定义 GNU Screen GNU Screen 使用基于 Ctrl+A 的快捷键。根据你的习惯，这可能会让你感觉非常自然，也可能非常不方便，因为你可能会用 Ctrl+A 来移动到一行的开头。无论怎样，GNU Screen 允许通过 .screenrc 配置文件进行各种定制。你可以用这个来改变触发键的绑定（称为 “转义” 键绑定）。 escape ^jJ 你还可以添加一个状态行，以帮助你在 Screen 会话中保持自己不迷失。 # status bar, with current window highlighted hardstatus alwayslastline hardstatus string '%{= kG}[%{G}%H%? %1`%?%{g}][%= %{= kw}%-w%{+b yk} %n*%t%?(%u)%? %{-}%+w %=%{g}][%{B}%m/%d %{W}%C%A%{g}]' # enable 256 colors attrcolor b \".I\" termcapinfo xterm 'Co#256:AB=\\E[48;5;%dm:AF=\\E[38;5;%dm' defbce on 在有多个窗口打开的会话中，有一个时刻提醒哪些窗口具有焦点活动，哪些窗口有后台活动的提醒器特别有用。它类似一种终端的任务管理器。 ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:5","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"备忘单 当你学习 GNU Screen 的使用方法时，需要记住很多新的键盘命令。有些命令你马上就能记住，但那些你不常使用的命令可能就很难记住了。你可以按 Ctrl+A 然后再按 ? 来访问 GNU Screen 的帮助界面。 学习 GNU Screen 是提高你使用你最喜欢的 终端模拟器 的效率和敏捷性的一个好方法。请试一试吧！ ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:6","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"参考 Linux tips for using GNU Screen [1] 使用 GNU Screen 的小技巧 [2] ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:7","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["收集与整理"],"content":" unsafe 包真的不安全吗？ https://mp.weixin.qq.com/s/rIqkKNUecvnZ6gadThf4gg go-callvis 源码分析 https://mp.weixin.qq.com/s/dUXXGd8hqEhKE_Cj4EY2Lw 深度探索Go语言（二）：动态派发 https://mp.weixin.qq.com/s/fhpKBRqhRAxFnESQ4vTbWQ 再一次看到了 Go 的节制：int128 类型要不要支持？ https://mp.weixin.qq.com/s/5uW2rcIEhFPCCTPqrhwOow Go 笔试题精选 三： 19 道填空题 https://mp.weixin.qq.com/s/5Zd1DmQGDvjMySOUf7eFMg 在提赋能之前，先想想这5个问题 https://mp.weixin.qq.com/s/V8l7S7A-kRF_WDb7tlJJ0Q 代码无可避免腐化是因为这 5 个原因 https://mp.weixin.qq.com/s/IzDgV6AmK-2ph1ctcz9liA kubebuilder 实战: CRUD https://mp.weixin.qq.com/s/UDA55y5RCpzyDvfSfs9d2w 实现无限缓存的channel https://colobu.com/2021/05/11/unbounded-channel-in-go/ 轻轻松松打印网页并生成 pdf 文档 https://colobu.com/2021/05/05/generate-pdf-for-a-web-page-by-using-chromedp/ Go 1.16 的 signal.NotifyContext 让你的服务重启更优雅 https://juejin.cn/post/6960578101755510798 一种持锁被调度的情况 https://xargin.com/schedule-when-holding-lock-causes-latency-spike/ assembly 完全解析： https://segmentfault.com/a/1190000039978109?utm_source=tag-newest strace 的 10 个命令 https://colobu.com/2021/04/30/strace-commands-for-troubleshooting-and-debugging-linux/ 使eBPF工作在windows操作系统上 https://cloudblogs.microsoft.com/opensource/2021/05/10/making-ebpf-work-on-windows/ 油管视频：调试你的Go test代码：用printf还是delve https://www.youtube.com/watch?v=nmNVd7FbSYs 如何在你的本地项目中使用未发布的Go module https://iaziz786.com/blog/use-unpublished-go-modules Prometheus监控告警规则大全 https://awesome-prometheus-alerts.grep.to/ dblab: 支持与PostgreSQL和MySQL交互的终端命令行工具 https://github.com/danvergara/dblab 终端应用的自动黑暗模式 by vim-go作者 https://arslan.io/2021/02/15/automatic-dark-mode-for-terminal-applications/ 另一个开源的容器平台 https://github.com/sylabs/singularity 在Go中没有一个完美的切片克隆方案 https://github.com/go101/go101/wiki/There-is-not-a-perfect-slice-clone-way-in-Go 理解nil接口类型与值为nil的接口变量 https://trstringer.com/go-nil-interface-and-interface-with-nil-concrete-value/ 微软Teams的命令行终端UI工具 https://github.com/fossteams/teams-cli Kubernetes GUI大全 http://kokizzu.blogspot.com/2021/03/kubernetes-gui.html 如何做出你的第一个开源贡献 https://dev.to/codesandboxio/how-to-make-your-first-open-source-contribution-2oim 无服务器下的数据库 https://mp.weixin.qq.com/s/_MfuhpSAtZFnB8p-xp5HUw MySQL AUTO_UNCREMENT https://mp.weixin.qq.com/s/Ya3JrUftN0ASI8dTzb1lvw facebook google网络架构揭秘 https://mp.weixin.qq.com/s/MPBk9wdYsE48H7OXWAd5bA ","date":"2021-05-13","objectID":"/article/2021/go20210513/:0:0","tags":["Golang"],"title":"Go20210513","uri":"/article/2021/go20210513/"},{"categories":["Using Software"],"content":" cron 是一个调度守护进程，它以指定的时间间隔执行任务，这些任务称为 corn 作业，主要用于自动执行系统维护或管理任务。例如，你可以设置一个 cron 作业来自动执行重复的任务，比如备份数据库或数据，使用最新的安全补丁更新系统，检查磁盘空间使用情况，发送电子邮件等等。 cron 作业可以按分钟、小时、日、月、星期或它们的任意组合运行。 cron 的一些优点 以下是使用 cron 作业的一些优点： 你可以更好地控制作业的运行时间。例如，你可以精确到分钟、小时、天等。 它消除了为循环任务逻辑而去写代码的需要，当你不再需要执行任务时，可以直接关闭它。 作业在不执行时不会占用内存，因此你可以节省内存分配。 如果一个作业执行失败并由于某种原因退出，它将在适当的时间再次运行。 安装 cron 守护进程 幸运的是，Fedora Linux 预先配置了运行重要的系统任务来保持系统更新，有几个实用程序可以运行任务例如 cron、anacron、at 和 batch 。本文只关注 cron 实用程序的安装。cron 和 cronie 包一起安装，cronie 包也提供 cron 服务。 ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:0","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"要确定软件包是否已经存在，使用 rpm 命令： $ rpm -q cronie Cronie-1.5.2-4.el8.x86_64 如果安装了 cronie ，它将返回 cronie 包的全名。如果你的系统中没有安装，则会显示未安装。 ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:1","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"使用以下命令安装： $ dnf install cronie ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:2","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"运行 cron 守护进程 cron 作业由 crond 服务来执行，它会读取配置文件中的信息。在将作业添加到配置文件之前，必须启动 crond 服务，或者安装它。什么是 crond 呢？crond 是 cron 守护程序的简称。要确定 crond 服务是否正在运行，输入以下命令： $ systemctl status crond.service ● crond.service - Command Scheduler Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor pre\u003e Active: active (running) since Sat 2021-03-20 14:12:35 PDT; 1 day 21h ago Main PID: 1110 (crond) 如果你没有看到类似的内容 Active: active (running) since…，你需要启动 crond 守护进程。要在当前会话中运行 crond 服务，输入以下命令： $ systemctl run crond.service 将其配置为开机自启动，输入以下命令： $ systemctl enable crond.service 如果出于某种原因，你希望停止 crond 服务，按以下方式使用 stop 命令： $ systemctl stop crond.service 要重新启动它，只需使用 restart 命令： $ systemctl restart crond.service 定义一个 cron 作业 ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:3","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"cron 配置 以下是一个 cron 作业的配置细节示例。它定义了一个简单的 cron 作业，将 git master 分支的最新更改拉取到克隆的仓库中： */59 * * * * username cd /home/username/project/design \u0026\u0026 git pull origin master 主要有两部分： 第一部分是 */59 * * * *。这表明计时器设置为第 59 分钟执行一次。 该行的其余部分是命令，因为它将从命令行运行。 在此示例中，命令本身包含三个部分： 作业将以用户 username 的身份运行 它将切换到目录 /home/username/project/design 运行 git 命令拉取 master 分支中的最新更改 ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:4","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"时间语法 如上所述，时间信息是 cron 作业字符串的第一部分，如上所属。它决定了 cron 作业运行的频率和时间。它按以下顺序包括 5 个部分： 分钟 小时 一个月中的某天 月份 一周中的某天 下面是一种更图形化的方式来解释语法： .--------------- 分钟 (0 - 59) | .------------- 小时 (0 - 23) | | .---------- 一月中的某天 (1 - 31) | | | .------- 月份 (1 - 12) 或 jan、feb、mar、apr … | | | | .---- 一周中的某天 (0-6) (周日=0 或 7) | | | | | 或 sun、mon、tue、wed、thr、fri、sat | | | | | * * * * * user-name command-to-be-executed ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:5","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"星号的使用 星号（*）可以用来替代数字，表示该位置的所有可能值。例如，分钟位置上的星号会使它每分钟运行一次。以下示例可能有助于更好地理解语法。 这个 cron 作业将每分钟运行一次： * * * * [command] 斜杠表示分钟的间隔数。下面的示例将每小时运行 12 次，即每 5 分钟运行一次： */5 * * * * [command] 下一个示例将每月的第二天午夜（例如 1 月 2 日凌晨 12:00，2 月 2 日凌晨 12:00 等等）： 0 0 2 * * [command] 关于 cron 时间格式，还有更多格式符号，此处没有展开 ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:6","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"使用 crontab 创建一个 cron 作业 cron 作业会在后台运行，它会不断检查 /etc/crontab 文件和 /etc/cron.*/ 以及 /var/spool/cron/ 目录。每个用户在 /var/spool/cron/ 中都有一个唯一的 crontab 文件。 不应该直接编辑这些 cron 文件。crontab 命令是用于创建、编辑、安装、卸载和列出 cron 作业的方法。 更酷的是，在创建新文件或编辑现有文件后，你无需重新启动 cron。 $ crontab -e 这将打开你现有的 crontab 文件，或者创建一个。调用 crontab -e 时，默认情况下会使用 vi 编辑器。注意：要使用 Nano 编辑 crontab 文件，可以设置 EDITOR=nano 环境变量。 使用 -l 选项列出所有 cron 作业。如果需要，使用 -u 选项指定一个用户。 $ crontab -l $ crontab -u username -l 使用以下命令删除所有 cron 作业： $ crontab -r 要删除特定用户的作业，你必须以 root 用户身份运行以下命令： $ crontab -r -u username cron 作业看起来可能只是系统管理员的工具，但它实际上与许多 Web 应用程序和用户任务有关。 参考 Fedora Linux 文档的 [1] 使用 cron 调度任务 [2] ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:7","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["收集与整理"],"content":" 图解 Go 内存管理分配 https://mp.weixin.qq.com/s/bMr4lZgf-Fn1oaOSPPSDIQ Go 刷 leetcode 之任务调度器 https://mp.weixin.qq.com/s/oI441vsKhYninXJjg3t3yA 自己动手实现一个 kubectl exec https://mp.weixin.qq.com/s/VmEcIYfsUbgh-p4RCssGFQ 云上细粒度访问管理的参考架构 https://mp.weixin.qq.com/s/3sfWGKFa1POMFcWYJbk6Ug Go 工程师必学：Go 大杀器之跟踪剖析 trace https://mp.weixin.qq.com/s/7DY0hDwidgx0zezP1ml3Ig Go并发编程 — sync.Once 单实例模式的思考 https://mp.weixin.qq.com/s/nMHNujmbIx7uMqMtjUMTvQ kustomize 简明教程 https://mp.weixin.qq.com/s/JDsDOYaACgyt97-Nz5ScDw 你不知道的 Go 之 slice https://mp.weixin.qq.com/s/aOIp7jeBWubT-u85vQJxzA 缓存系统稳定性 - 架构师峰会演讲实录 https://mp.weixin.qq.com/s/o0qUY5zUjBQuOkx_4XGB6Q 微服务的灾难 https://mp.weixin.qq.com/s/bY2s7wjfggSt77kj8exYLQ 利用 NATS JetStream 构建分布式事件流系统 https://shijuvar.medium.com/building-distributed-event-streaming-systems-in-go-with-nats-jetstream-3938e6dc7a13 100 行 Golang 代码构建一个简单的终端仿真器 https://ishuah.com/2021/03/10/build-a-terminal-emulator-in-100-lines-of-go 编写简单的 CLI 程序：Python vs Go https://dev.to/jidicula/writing-a-simple-cli-program-python-vs-go-59kf 如何使用 Go，Maroto 和 GoFakeIt 创建 PDF https://dev.to/divrhino/creating-a-pdf-with-go-maroto-gofakeit-3c7m 一个用 Go 编写的类似 cowsay 的开源程序 weebsay https://github.com/irevenko/weebsay 最受欢迎的编程语言（1965/2021） https://statisticsanddata.org/data/the-most-popular-programming-languages-1965-2021/ 用NATS JetStream在Go中构建分布式事件流系统 https://shijuvar.medium.com/building-distributed-event-streaming-systems-in-go-with-nats-jetstream-3938e6dc7a13 外部secret管理系统与k8s的集成 https://github.com/external-secrets/kubernetes-external-secrets 生成随机的、可发音的名字，像docker给容器起的默认名字那样 https://github.com/lucasepe/codename Pixie为CNCF带来Kubernetes集群内的调试能力 https://thenewstack.io/pixie-brings-in-cluster-kubernetes-debugging-to-cncf/ bofied: 一个网络启动服务器，支持PXE服务协议 https://github.com/pojntfx/bofied 糟糕的磁盘性能 by Brendan Gregg http://www.brendangregg.com/blog/2021-05-09/poor-disk-performance.html 油管视频：使用go重头构建container https://www.youtube.com/watch?v=8fi7uSYlOdc milvus：开源向量数据库搜索引擎 https://github.com/milvus-io/milvus 使用go加速python代码 https://medium.com/geekculture/speed-up-python-with-golang-9a1d2c6067ab go语言编译器 https://mp.weixin.qq.com/s/UhxFOQBpW8EUVpFvqH2tMg 虚拟内存工作原理 https://mp.weixin.qq.com/s/c81Fvws0J2tHjcdTgxvv6g redis vs tendis https://mp.weixin.qq.com/s/MeYkfOIdnU6LYlsGb24KjQ ","date":"2021-05-12","objectID":"/article/2021/go20210512/:0:0","tags":["Golang","微服务"],"title":"Go20210512","uri":"/article/2021/go20210512/"},{"categories":["关于"],"content":"关于我 勤奋的代码搬运工。 ","date":"2021-05-11","objectID":"/about/:0:1","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"为什么建立个人博客？ 宣传自己，这是一个信息爆炸、人人自我营销的时代，不懂得宣传自己，就得不到机会的垂青。 个人觉得IT从业者就应该有自己的博客网站，记录与分享自己的经验，收集有价值的文章。 凭借互联网的媒介，结交志同道合的朋友，为未来的事业做准备。 ","date":"2021-05-11","objectID":"/about/:0:2","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"关于本站 学习日记，点滴记录。 也会收集和分享互联网上比较经典且具有价值的文章。 ","date":"2021-05-11","objectID":"/about/:0:3","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"站长是谁： 昵称：白菜林 对于技术很爱折腾、很有热情的小哥。 联系站长：77370751（微信/qq同号，备注来意） 邮箱Email：77370751@qq.com 交流QQ群：153690156 给我留言：https://support.qq.com/product/325110 ","date":"2021-05-11","objectID":"/about/:0:4","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"我的主页 Gitee: https://lyhuilin.gitee.io/ Github: https://github.com/clin003/meBlog ","date":"2021-05-11","objectID":"/about/:0:5","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"未来发展： 未来很长，且慢慢耕耘。 ","date":"2021-05-11","objectID":"/about/:0:6","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"白菜林的博客小站历程： 2021年5月11日 白菜林的博客小站 建站并部署至Github page。 ","date":"2021-05-11","objectID":"/about/:0:7","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"特别感谢 非常感谢每一位走进本站的同学对我们的大力支持，你们的走进是我坚持的动力！ 如果不介意,请把本站分享给您的同学朋友！ 我会一直努力，不求最好，只求更好！ ","date":"2021-05-11","objectID":"/about/:0:8","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"Hello World! 白菜林^_^ ","date":"2021-05-11","objectID":"/article/2021/hello_world/:0:0","tags":["about"],"title":"Hello world","uri":"/article/2021/hello_world/"}]