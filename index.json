[{"categories":["趣站","轻松好玩"],"content":"塔防游戏 可玩性很高的一款塔防游戏，需要各类元素合成，通过传送带传送宝石、木材、铁等元素，最后合成弓箭、大炮、闪电塔等来抵御怪兽的袭击，一玩就停不下来。 传送门 https://yorg.io/ ","date":"2021-06-02","objectID":"/article/2021/tower-defense/:0:1","tags":["多人联机","塔防","网页游戏","Tower Defense"],"title":"塔防游戏-YORG.io","uri":"/article/2021/tower-defense/"},{"categories":["趣站","轻松好玩"],"content":"玩法 通过传送带传送宝石、木材、铁等元素，最后合成弓箭、大炮、闪电塔等来抵御怪兽的袭击 ","date":"2021-06-02","objectID":"/article/2021/tower-defense/:0:2","tags":["多人联机","塔防","网页游戏","Tower Defense"],"title":"塔防游戏-YORG.io","uri":"/article/2021/tower-defense/"},{"categories":["趣站","轻松好玩"],"content":"80后的回忆，曾经在网吧爆肝玩的一款游戏，这是个在线版本，可以和其他人对战，回忆满满的一款在线游戏","date":"2021-06-02","objectID":"/article/2021/red-alert-2-chronodivide/","tags":["多人联机","红警2","网页游戏"],"title":"网页版红色警戒2-Red Alert 2: Chrono Divide","uri":"/article/2021/red-alert-2-chronodivide/"},{"categories":["趣站","轻松好玩"],"content":"在线红警 又是一波人的集体回忆。。。网站高度还原了经典游戏——红色警戒2，原汁原味的画面和音效，仿佛又回到了那个电脑房的年代！ 传送门 https://game.chronodivide.com/ ","date":"2021-06-02","objectID":"/article/2021/red-alert-2-chronodivide/:0:1","tags":["多人联机","红警2","网页游戏"],"title":"网页版红色警戒2-Red Alert 2: Chrono Divide","uri":"/article/2021/red-alert-2-chronodivide/"},{"categories":["趣站","轻松好玩"],"content":"玩法 网站支持多人在线对战，注册登陆后即可开始！ ","date":"2021-06-02","objectID":"/article/2021/red-alert-2-chronodivide/:0:2","tags":["多人联机","红警2","网页游戏"],"title":"网页版红色警戒2-Red Alert 2: Chrono Divide","uri":"/article/2021/red-alert-2-chronodivide/"},{"categories":["收集与整理"],"content":"2021-06-02 今日技术分享 推荐一本免费的 Go 新书：用 Go 讲架构的书 https://mp.weixin.qq.com/s/SoqxlvEOyV6EtjKTWGEyxw Go 每日一库之 fasttemplate https://mp.weixin.qq.com/s/_ZIB3H1kJwb8s53lIQ-7Sw 在容器里设置GOMAXPROCS的正确姿势 https://mp.weixin.qq.com/s/jVyKb_3YS9ETX4JmIuhWJA 自适应微服务治理背后的算法 https://mp.weixin.qq.com/s/OpF4JVWHA9W1v0yefeo56w 用 Rust 编写的 Git 极速终端 UI https://mp.weixin.qq.com/s/NlVq30gs6qcdg3CQBS8-IA 优雅地处理错误真是一门学问啊！ https://mp.weixin.qq.com/s/W_LsZtnjGIKQ-LB6EkRgBA Go 每日一库之 reflect https://mp.weixin.qq.com/s/KoHYoQ0q9qVjOWLPAIWaAA kubernetes面试相关总结(上) https://mp.weixin.qq.com/s/33cKjVFf7pERyRHQtDwXoQ 百度健康急招Gopher https://mp.weixin.qq.com/s/5zyEHVz258IgnIpjOfFADQ 16 中的新函数 signal.NotifyContext 怎么用？ https://mp.weixin.qq.com/s/mnR_wADjyHtyjdkSwcnkSw 蚂蚁开源 OceanBase，开源分布式数据库又迎新玩家 https://mp.weixin.qq.com/s/iDBpa3w2iP8XUr9fb-QWoA 曹大带我学 Go（4）—— 初识 ast 的威力 https://mp.weixin.qq.com/s/K_iyVFOqg0_2wWmkvXgD8Q 理解 Golang 中函数调用的原理 https://blog.51cto.com/u_15127695/2829851 Go 微服务全链路跟踪详解 https://mp.weixin.qq.com/s/C6OtNYtskdPpfw-HsP76vQ 自适应微服务治理背后的算法 https://mp.weixin.qq.com/s/OpF4JVWHA9W1v0yefeo56w 消息队列解耦是骗小孩儿的 https://mp.weixin.qq.com/s/O0KGm3nVUSWMSKwHlPiJpg go channel惯用法 https://blog.kevinhu.me/2021/05/31/31-go-channel-examples/ 经典旧文：k8s pod的request和limit的正确设置方法 https://learnk8s.io/setting-cpu-memory-limits-requests 用Go实现一个并发文件下载工具 https://returnfn.com/lets-build-a-concurrent-file-downloader-in-go Go并发API模式 https://tech.deliveryhero.com/concurrent-api-patterns-in-go/ 使用Go生成你自己的O’RLY动物书封面 https://github.com/nanmu42/orly 使用Go实现一个简单但强大的反向代理 https://blog.joshsoftware.com/2021/05/25/simple-and-powerful-reverseproxy-in-go/ 使用falco分析k3s集群的审计日志 https://github.com/developer-guy/falco-analyze-audit-log-from-k3s-cluster docker live视频：利用Cue和Buildkit重新思考应用交付问题 https://docker.events.cube365.net/dockercon-live/2021/content/Videos/TamRA3F2zT8fycvq5 阿里的Oceanbase开源 https://github.com/oceanbase/oceanbase 开源社区需要更多的安全空间和行为准则 https://thenewstack.io/open-source-communities-need-more-safe-spaces-and-codes-of-conducts-now/ 高性能的goroutine池 https://www.yuque.com/u2278269/gq5x74/puzrkf 流？I/O操作？阻塞？epoll? https://www.kancloud.cn/aceld/golang/1958320 曹大带你看ast https://mp.weixin.qq.com/s/K_iyVFOqg0_2wWmkvXgD8Q 最常用的调试 golang 的 bug以及性能问题的实践方法 https://www.kancloud.cn/aceld/golang/1958304 ","date":"2021-06-02","objectID":"/article/2021/go20210602/:0:0","tags":["技术分享","Golang"],"title":"Go20210602 今日技术分享","uri":"/article/2021/go20210602/"},{"categories":["收集与整理"],"content":"2021-06-01 今日技术分享 发现了众多 Go 好书 https://mp.weixin.qq.com/s/x6h8xpbn9kuV2wlk-wtULA Go语言爱好者周刊：第 97 期 https://mp.weixin.qq.com/s/6kXbi8OyubJv6opOomb4zg Go小知识：%v +v #v的区别 https://mp.weixin.qq.com/s/g4qgn1b_LvpvMqRZD-k8LA 优化 Kubernetes 横向扩缩容 HPA https://mp.weixin.qq.com/s/x_yID1QFt8vV7ioy_o5LlA Go语言内存逃逸之谜 https://mp.weixin.qq.com/s/zm5rp4DkgrWIduZAMhzNzA 图解 数据安全的3 种 IO 姿势 https://mp.weixin.qq.com/s/a-SQgKzVYVmJ-qWUXy7c8A 在容器里设置GOMAXPROCS的正确姿势 https://mp.weixin.qq.com/s/kbZsJncgVZv30_TwVrLyLQ 深挖Map的读写性能 https://mp.weixin.qq.com/s/quNpj1MQQwWCKeEENGinUg 消息队列解耦是骗小孩儿的 https://mp.weixin.qq.com/s/O0KGm3nVUSWMSKwHlPiJpg 17这个新特性竟然是6年前提出来的 https://mp.weixin.qq.com/s/8Ju2-daS0s-esDAezP-lZw 深度理解 golang map https://juejin.cn/post/6967274139065253902 sync.Pool 原理解析 https://juejin.cn/post/6965421491588431909 Kratos 学习笔记 https://juejin.cn/post/6967941646138736653 来瞧一瞧 gRPC 的拦截器 https://segmentfault.com/a/1190000040087672 Go性能剖析工具速查表 https://steveazz.xyz/blog/go-performance-tools-cheat-sheet/ sealer：阿里开源的分布式应用打包交付运行的解决方案，可以把分布式应用及其数据库中间件等依赖一起打包发布 https://github.com/alibaba/sealer 基于Go控制器的组件框架和热重载插件系统 https://github.com/aperturerobotics/controllerbus 自动化的服务健康仪表板 https://github.com/TwinProduction/gatus CNCF的制品库hub https://github.com/artifacthub/hub Linux之父：我们不会用Rust取代C语言开发内核 https://mp.weixin.qq.com/s/mVo3S_F0RoxCToawrTCnlA 基于KubeEdge实现中国移动10086客服云边协同平台 https://mp.weixin.qq.com/s/pn0UEL2LFUN63__RVgHBLw 面向Kubernetes的红帽高级集群安全简介 https://www.openshift.com/blog/a-brief-introduction-to-red-hat-advanced-cluster-security-for-kubernetes 阿里基于PostgreSQL开源的PolarDB https://github.com/alibaba/PolarDB-for-PostgreSQL ","date":"2021-06-01","objectID":"/article/2021/go20210601/:0:0","tags":["技术分享","Golang"],"title":"Go20210601 今日技术分享","uri":"/article/2021/go20210601/"},{"categories":["收集与整理"],"content":"2021-05-30 今日技术分享 国外竟然有这么多公司使用 Go https://mp.weixin.qq.com/s/fKXIBfxvk1wgZMujuz9hWA Go 中如何让消息队列达到最大吞吐量？ https://mp.weixin.qq.com/s/K9qZVNP4AKsHNcrDyZq_eA Go 每日一库之 gotalk https://mp.weixin.qq.com/s/VnpQilljVokGssECVyFjWw Istio 完败？Linkerd 和 Istio 基准测试 https://mp.weixin.qq.com/s/7A7eXQONpiNdCrfwt1HfhQ 9 种开源的服务网格比较 https://mp.weixin.qq.com/s/3XwKE1pLgMkiH7xuQix25w 如何在 Go-kit 和 Service Mesh 中进行服务注册与发现？ https://mp.weixin.qq.com/s/TZoq5CRQ_QIYTG4W_cU4dg K8s 工作负载图表工具 https://github.com/Trois-Six/k8s-diagrams 灵活的 Go http client 库-Sling https://mp.weixin.qq.com/s/liCnGt0-me4cv-1WAJSSBQ go web client 单元测试实践 https://dev.to/chen/practical-unit-testing-web-client-in-go-1o2m 为什么Go引入泛型后不会改变Go惯用法？ http://www.jerf.org/iri/post/2955 GoLand 2021.2开发计划 https://blog.jetbrains.com/go/2021/05/28/goland-2021-2-early-access-program-is-open/ 使用cobra和go实现shell命令补全 https://jmtirado.net/shell-completion-with-cobra-and-go/ dubbo-go v3版本go module踩坑记 https://mp.weixin.qq.com/s/NFwL7YAtzkSsqZi8AYA6tw 如何像专家那样写benchmark测试 https://hackernoon.com/how-to-write-benchmarks-in-golang-like-an-expert-0w1834gs Go hosts文件操作包 https://github.com/areYouLazy/libhosty Go实现的磁盘分析工具 https://github.com/dundee/gdu 如何在EKS上安装Cilium https://miles-seth.medium.com/eks-unchained-with-ebpf-and-bottlerocket-1639b011a36a eks 集群运行在带有 firecracker 的单个实例上 https://ongres.com/blog/63-node-eks-cluster-running-on-a-single-instance-with-firecracker/ Kubernetes集群压力测试工具 https://github.com/cloud-bulldozer/kube-burner 不可变数据库immudb发布v1.0版本 https://www.codenotary.com/blog/immudb-release-1-0/ ","date":"2021-05-31","objectID":"/article/2021/go20210531/:0:0","tags":["技术分享","Golang"],"title":"Go20210531 今日技术分享","uri":"/article/2021/go20210531/"},{"categories":["收集与整理"],"content":"2021-05-29 今日技术分享 Go：近期两个开源免费好资源 https://mp.weixin.qq.com/s/wXrIztN5MXsNvBKg2LR3hA 再次探讨 Go 的无限缓冲的channel https://mp.weixin.qq.com/s/wZNLOywbQWdju_-7TN_48Q 读者问答：Go 编程怎么也有内存问题？ https://mp.weixin.qq.com/s/51xEfULa1cWaltkTkg1cUA validator库你知多少？govalidator了解一下 https://mp.weixin.qq.com/s/FnvvREHWeN1UdRliFjxQ9A 睡前故事|用Bitmap与AST做一个配置化时长系统 https://mp.weixin.qq.com/s/th5HgpibwZkRlj1EzxmMTw 理论结合实践详解 B+ 树存储引擎（PPT）（多图） https://mp.weixin.qq.com/s/aSNdEkNdeCAC7O6b3coo-A 图解 | epoll怎么实现的 https://mp.weixin.qq.com/s/XW561JURm5zxsXHnD1lV6A 硬核！如何在容器中做时间漫游者 https://mp.weixin.qq.com/s/dTVwpi60_URx1P9c1OPEug Pod Terminating 状态排查 https://mp.weixin.qq.com/s/IattDivoyFSWCq26IV457g 1 业务服务（1） https://mp.weixin.qq.com/s/GzoMpMIUWtM2qNFp5xNiWQ NSQ 如何实现文件队列 https://reposkeeper.net/2020/11/nsq-disk-queue-implement.html Go sync.Pool 浅析 https://blog.csdn.net/haohongfan/article/details/116978613 Golang 指针和 C++ 指针的简单剖析 https://juejin.cn/post/6967315069310861319 在 Go 中使用位掩码 https://www.ardanlabs.com/blog/2021/04/using-bitmasks-in-go.html Go 中的垃圾收集 https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html 鹅厂的Go编码安全指南 https://github.com/Tencent/secguide/blob/main/Go%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97.md OpenTelemetry Go应用入门 https://speakerdeck.com/riferrei/opentelemetry-for-dummies-instrumenting-go-apps 使用Go进行benchmark测试 https://stonecode.ca/benchmarking-with-go/ 使用Go语言进行位操作 https://www.ardanlabs.com/blog/2021/04/using-bitmasks-in-go.html 基于eBPF的网络开源项目Cilium发布1.10 https://cilium.io/blog/2021/05/20/cilium-110 Linkerd和Istio的性能对比(2021版) https://linkerd.io/2021/05/27/linkerd-vs-istio-benchmarks/ 使用Fio来判断你的存储是否足够快，以满足Etcd的需要 https://www.ibm.com/cloud/blog/using-fio-to-tell-whether-your-storage-is-fast-enough-for-etcd Kubernetes API的优先级和公平性 https://itnext.io/kubernetes-api-priority-and-fairness-b1ef2b8a26a2 用于替代TCP的QUIC协议被IETF确定为RFC9000 https://www.fastly.com/blog/quic-is-now-rfc-9000 云的成本，一万亿美元的悖论 https://a16z.com/2021/05/27/cost-of-cloud-paradox-market-cap-cloud-lifecycle-scale-growth-repatriation-optimization/ 分布式事务的实现原理 https://draveness.me/distributed-transaction-principle/ facebook全球用户流量管理系统 https://draveness.me/papers-taiji/ goroutine调度机制概览 https://zhuanlan.zhihu.com/p/244054940?utm_source=wechat_session\u0026utm_medium=social\u0026utm_oi=1034363224250163200\u0026utm_campaign=shareopn ","date":"2021-05-30","objectID":"/article/2021/go20210529/:0:0","tags":["技术分享","Golang"],"title":"Go20210529 今日技术分享","uri":"/article/2021/go20210529/"},{"categories":["收集与整理"],"content":"2021-05-28 今日技术分享 如何让 Go 的缓存库 BigCache 更好用？ https://mp.weixin.qq.com/s/Zn1rP18GtmZsbaRnRfJ8ug 在 Go 语言中，有时 nil 并不是一个 nil https://mp.weixin.qq.com/s/_REGCKxs0ymIdZXN5a6Tgg AWS 容器服务的安全实践 https://mp.weixin.qq.com/s/GYMXc4HXBGOGgA_7mdenhA 骚操作，这款工具可以把Kubernetes集群打包成一个镜像 https://mp.weixin.qq.com/s/ssZSMqogjP6CTOKOOR2e5Q 总结 Kafka 背后的优秀设计 https://mp.weixin.qq.com/s/dfOP2MeBOqFqg_BdcJCYug 硬核！如何在容器中做时间漫游者 https://mp.weixin.qq.com/s/PtYKA-lviJO6A2sXfEaNWA 曹大带我学 Go（3）—— 如何用汇编打同事的脸 https://mp.weixin.qq.com/s/2Y3qPkysRLaWDcIyLOerZg Go可用性(七) 总结: 一张图串联可用性知识点 https://mp.weixin.qq.com/s/OXopl6FpwtE6P-k0GEP9qA Go 指针 https://sher-chowdhury.medium.com/pointers-in-go-507ec33446b0 Go 自定义 http 错误 https://dev.to/clavinjune/my-custom-http-error-in-golang-5ab Go 语言 JSON 使用技巧 https://www.liwenzhou.com/posts/Go/json_tricks_in_go Go 简单快速模板引擎 https://github.com/valyala/fasttemplate Go 1.18加入泛型后的Go函数式编程的未来 https://ani.dev/2021/05/25/functional-programming-in-go-with-generics/ Go团队如何解bug: 乱序执行与内存屏障 https://mzh.io/how-go-core-team-debug-1-memory-model/ 提案：将Go移植到中科龙芯指令架构 https://github.com/golang/go/issues/46229 实验性Go重构工具rf https://pkg.go.dev/rsc.io/rf 成为Kubernetes专家的47件事 https://ymmt2005.hatenablog.com/entry/k8s-things Go自动化测试介绍 https://dev.to/salesforceeng/intro-to-automated-testing-in-go-4mjl 油管视频：Go 还是 Rust，看Go专家与Rust专家的圆桌辩论 https://www.youtube.com/watch?v=N-E-qtQhsHw 欧洲电信巨头优先选择基于Kubernetes的开放云平台 https://thenewstack.io/european-telecom-giants-prioritize-a-kubernetes-based-open-cloud-platform/ 5分钟内从零到入门Kubernetes https://dev.to/ahmednader10/zero-to-kubernetes-in-5-mins-2hbp 用这4个最佳实践提高你的CI/CD可观察性 https://thenewstack.io/improve-your-ci-cd-observability-with-these-4-best-practices/ ","date":"2021-05-29","objectID":"/article/2021/go20210528/:0:0","tags":["技术分享","Golang"],"title":"Go20210528 今日技术分享","uri":"/article/2021/go20210528/"},{"categories":["收集与整理"],"content":"2021-05-27 今日技术分享 为什么Go程序占用那么大的虚拟内存？ https://mp.weixin.qq.com/s/tkAWtSJ4ebAUcQG9AmeXWA 你不知道的 Go 之 string https://mp.weixin.qq.com/s/6miIgsZN_Fh79Aixv5BlTg 又吵起来了，Go 是传值还是传引用？ https://mp.weixin.qq.com/s/qsxvfiyZfRCtgTymO9LBZQ Go 编程怎么也有踩内存？ https://mp.weixin.qq.com/s/tXAP8_U63QLNj1h0ZMvXPw kubectl debug | 调试Kubernetes的最简方法 https://mp.weixin.qq.com/s/8uN2MySGlgxTed5vwqfFlA 果然，连流程控制都这么另类 https://mp.weixin.qq.com/s/tO8CFBDZ2UsOonqARxOQUA 带你走进云原生技术：云原生开放运维体系探索和实践 https://mp.weixin.qq.com/s/zasjqGBDjyeg91jVaa5Xwg 通用连接池帮你解决资源管理难题 https://mp.weixin.qq.com/s/X-xzEzlVrEKYo78eiHwDKw Go 1.17新特性 https://mp.weixin.qq.com/s/T14M_s5qOA6LKvWGgNa0Ow 无限缓冲的channel(2) https://mp.weixin.qq.com/s/wDrOBRaPqHx6g-Ir-Yx8kA 如何运行并行功能测试 https://medium.com/fiverr-engineering/running-parallel-functional-tests-2f6609bfbf4e Go 中一些不曾注意的点 https://arash-cordi.medium.com/dark-corners-of-go-4e29aafcd4b9 如何像专家一样编写 Golang 基准测试 https://hackernoon.com/how-to-write-benchmarks-in-golang-like-an-expert-0w1834gs 详解 Go 空结构体的 3 种使用场景 https://mp.weixin.qq.com/s/zbYIdB0HlYwYSQRXFFpqSg Promtheus rules lint 工具 https://github.com/cloudflare/pint 详解Go语言的栈跟踪 https://github.com/DataDog/go-profiler-notes/blob/main/stack-traces.md 关于go结构体字段布局优化 https://dev.to/deleplace/data-oriented-ant-in-go-3eki 使用Go实现《Head First Design Patterns》中的设计模式 5.使用taildrop在终端间安全的发送文件 https://faun.pub/head-first-design-patterns-using-go-introduction-d9f05a4c243a 使用Go实现《Head First Design Patterns》中的设计模式 5.使用taildrop在终端间安全的发送文件 https://tailscale.com/blog/sending-files-with-taildrop/ Vanilla Kubernetes对Raspberry Pi来说真的太重了吗？ https://www.talos-systems.com/blog/is-vanilla-kubernetes-really-too-heavy-for-the-raspberry-pi/ 使用Go, Gin, MySQL和Docker构建blog项目 https://nizu.tech/go-blog-1 20大Dockerfile最佳实践 https://sysdig.com/blog/dockerfile-best-practices/ 在kubernetes上运行consul和vault https://testdriven.io/blog/running-vault-and-consul-on-kubernetes/ 使用tekton构建云原生ci/cd https://itnext.io/cloud-native-ci-cd-with-tekton-building-custom-tasks-663e63c1f4fb 观点：是时候停止推荐clean code了 https://qntm.org/clean 关于编程语言的思考 https://itnext.io/my-thoughts-about-programming-languages-43a8d23ead1f redis和IO多路复用 https://zhuanlan.zhihu.com/p/24252862 mysql核心知识 https://zhuanlan.zhihu.com/p/363639169 ","date":"2021-05-28","objectID":"/article/2021/go20210527/:0:0","tags":["技术分享","Golang"],"title":"Go20210527 今日技术分享","uri":"/article/2021/go20210527/"},{"categories":["收集与整理","编程经验"],"content":"Go Module代理仓库服务 七牛云提供的：https://goproxy.cn/ goproxy.io：https://goproxy.io/ 百度云BOS提供的：https://goproxy.baidu.com/ 阿里云提供的：https://mirrors.aliyun.com/goproxy/ ","date":"2021-05-27","objectID":"/article/2021/goproxy/:0:1","tags":["技术分享","Golang","Goproxy"],"title":"Goproxy","uri":"/article/2021/goproxy/"},{"categories":["收集与整理","编程经验"],"content":"下载 Go 镜像（Golang Downloads Mirrors） 下载 Go 镜像：https://golang.google.cn/ 下载 Go 镜像：https://gomirrors.org/ 下载 Go 镜像：https://studygolang.com/dl ","date":"2021-05-27","objectID":"/article/2021/goproxy/:0:2","tags":["技术分享","Golang","Goproxy"],"title":"Goproxy","uri":"/article/2021/goproxy/"},{"categories":["收集与整理"],"content":"2021-05-26 今日技术分享 gRPC 可以不用 pb 而使用 JSON 吗？ https://mp.weixin.qq.com/s/oQ4aG0pIJmQFQd2TKGxsXg 什么？无限缓冲 channel。。。 https://mp.weixin.qq.com/s/0TJRcbaWlfwEjbKMKAxNAQ 10.0 有史以来性能最优 https://mp.weixin.qq.com/s/qJ7HQ2BVS6DEO6sPTJzeAA 最强 CNI 基准测试：Cilium 网络性能分析 https://mp.weixin.qq.com/s/NR7gDpp2i5gCRRwZjxaASA 使用kubebuilder开发简单的Operator https://mp.weixin.qq.com/s/uhOIPfTs4o5MDKbdhh_kEQ 我这样升级 Go 版本，你呢？ https://mp.weixin.qq.com/s/jEhX5JHAo9L6iD3N54x6aA B 站直播 | Istio 开源四周年回顾与展望 https://mp.weixin.qq.com/s/tYIP1_s1jHXu6j4mjLuJIw PAAS平台开发的自我救赎 https://mp.weixin.qq.com/s/0vuneQ-rweCZ-kKLvhe_6g Go 每日一库之 fasttemplate https://mp.weixin.qq.com/s/uNE94IBUmTp2PJ4boFz8OQ 60道重要的Kubernetes面试题 https://mp.weixin.qq.com/s/G1kNSmXLaAzAOQ-ja2pKVQ Go 编码安全指南 https://github.com/Tencent/secguide/blob/main/Go%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97.md 私钥安全分发工具 cocert https://github.com/Dentrax/cocert 两年 Go 经验学到的东西 https://sayedalesawy.hashnode.dev/top-5-lessons-i-learned-while-working-with-go-for-two-years Go 如何进行栈追踪 https://github.com/DataDog/go-profiler-notes/blob/main/stack-traces.md Linux 中的 macOS 子系统 lima https://github.com/AkihiroSuda/lima 使用Go的两年后我学到的五大教训 https://sayedalesawy.hashnode.dev/top-5-lessons-i-learned-while-working-with-go-for-two-years Ransomware：Kasten K8s存储平台如何克服终极数据复制挑战 https://thenewstack.io/ransomware-how-the-kasten-k8s-storage-platform-overcomes-the-ultimate-data-replication-challenge/ 新提案：bytes、strings包增加Cut函数 https://github.com/golang/go/issues/46336 将eBPF用于高级Linux基础设施监控 https://www.linuxjournal.com/content/ebpf-advanced-linux-infrastructure-monitoring 使用podman从docker compose转换到kubernetes https://www.redhat.com/sysadmin/compose-kubernetes-podman 像函数一样调用的go模板 https://github.com/rsc/tmplfunc FIFO、LRU、CLOCK和LFU四种缓存替换策略的Go实现 https://brunocalza.me/the-cache-is-full/ 使用Thanos监控多k8s集群 https://particule.io/en/blog/thanos-monitoring/ 在kubernetes上运行apache flink https://medium.com/empathyco/running-apache-flink-on-kubernetes-10815a26559e kubecost：使用kubectl监控kubernetes消耗 https://thenewstack.io/kubecost-monitor-kubernetes-costs-with-kubectl/ go应用性能优化 https://xargin.com/go-perf-optimization/ Kubernetes 集群灾备环境部署 https://mp.weixin.qq.com/s/3rOKOT7bg17K3SKNUFIiIQ mvcc多版本并发控制 https://blog.csdn.net/filling_l/article/details/112854716 ","date":"2021-05-26","objectID":"/article/2021/go20210526/:0:0","tags":["技术分享","Golang"],"title":"Go20210526 今日技术分享","uri":"/article/2021/go20210526/"},{"categories":["Using Software"],"content":" 利用 Volatility 找出应用程序、网络连接、内核模块、文件等方面的情况。 计算机的操作系统和应用使用主内存（RAM）来执行不同的任务。这种易失性内存包含大量关于运行应用、网络连接、内核模块、打开的文件以及几乎所有其他的内容信息，但这些信息每次计算机重启的时候都会被清除。 内存取证是一种从内存中找到和抽取这些有价值的信息的方式。Volatility 是一种使用插件来处理这类信息的开源工具。但是，存在一个问题：在你处理这些信息前，必须将物理内存转储到一个文件中，而 Volatility 没有这种能力。 因此，这篇文章分为两部分： 第一部分是处理获取物理内存并将其转储到一个文件中。 第二部分使用 Volatility 从这个内存转储中读取并处理这些信息。 我在本教程中使用了以下测试系统，不过它可以在任何 Linux 发行版上工作： $ cat /etc/redhat-release Red Hat Enterprise Linux release 8.3 (Ootpa) $ $ uname -r 4.18.0-240.el8.x86_64 $ 注意事项： 部分 1 涉及到编译和加载一个内核模块。不要担心：它并不像听起来那么困难。 一些指南： 按照以下的步骤。 不要在生产系统或你的主要计算机上尝试任何这些步骤。 始终使用测试的虚拟机（VM）来尝试，直到你熟悉使用这些工具并理解它们的工作原理为止。 ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:0:0","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"安装需要的包 在开始之前安装必要的工具。如果你经常使用基于 Debian 的发行版，可以使用 apt-get 命令。这些包大多数提供了需要的内核信息和工具来编译代码： $ yum install kernel-headers kernel-devel gcc elfutils-libelf-devel make git libdwarf-tools python2-devel.x86_64-y ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:1:0","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"部分 1：使用 LiME 获取内存并将其转储到一个文件中 在开始分析内存之前，你需要一个内存转储供你使用。在实际的取证活动中，这可能来自一个被破坏或者被入侵的系统。这些信息通常会被收集和存储来分析入侵是如何发生的及其影响。由于你可能没有可用的内存转储，你可以获取你的测试 VM 的内存转储，并使用它来执行内存取证。 Linux 内存提取器（LiME）是一个在 Linux 系统上获取内存很常用的工具。使用以下命令获得 LiME： $ git clone https://github.com/504ensicsLabs/LiME.git $ $ cd LiME/src/ $ $ ls deflate.c disk.c hash.c lime.h main.c Makefile Makefile.sample tcp.c $ ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:2:0","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"构建 LiME 内核模块 在 src 文件夹下运行 make 命令。这会创建一个以 .ko 为扩展名的内核模块。理想情况下，在 make 结束时，lime.ko 文件会使用格式 lime-.ko 被重命名。 $ make make -C /lib/modules/4.18.0-240.el8.x86_64/build M=\"/root/LiME/src\" modules make[1]: Entering directory '/usr/src/kernels/4.18.0-240.el8.x86_64' \u003c\u003c 删节 \u003e\u003e make[1]: Leaving directory '/usr/src/kernels/4.18.0-240.el8.x86_64' strip --strip-unneeded lime.ko mv lime.ko lime-4.18.0-240.el8.x86_64.ko $ $ $ ls -l lime-4.18.0-240.el8.x86_64.ko -rw-r--r--. 1 root root 25696 Apr 17 14:45 lime-4.18.0-240.el8.x86_64.ko $ $ file lime-4.18.0-240.el8.x86_64.ko lime-4.18.0-240.el8.x86_64.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=1d0b5cf932389000d960a7e6b57c428b8e46c9cf, not stripped $ ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:2:1","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"加载LiME 内核模块 现在是时候加载内核模块来获取系统内存了。insmod 命令会帮助加载内核模块；模块一旦被加载，会在你的系统上读取主内存（RAM）并且将内存的内容转储到命令行所提供的 path 目录下的文件中。另一个重要的参数是 format；保持 lime 的格式，如下所示。在插入内核模块之后，使用 lsmod 命令验证它是否真的被加载。 $ lsmod | grep lime $ $ insmod ./lime-4.18.0-240.el8.x86_64.ko \"path=../RHEL8.3_64bit.mem format=lime\" $ $ lsmod | grep lime lime 16384 0 $ 你应该看到给 path 命令的文件已经创建好了，而且文件大小与你系统的物理内存（RAM）大小相同（并不奇怪）。一旦你有了内存转储，你就可以使用 rmmod 命令删除该内核模块： $ $ ls -l ~/LiME/RHEL8.3_64bit.mem -r--r--r--. 1 root root 4294544480 Apr 17 14:47 /root/LiME/RHEL8.3_64bit.mem $ $ du -sh ~/LiME/RHEL8.3_64bit.mem 4.0G /root/LiME/RHEL8.3_64bit.mem $ $ free -m total used free shared buff/cache available Mem: 3736 220 366 8 3149 3259 Swap: 4059 8 4051 $ $ rmmod lime $ $ lsmod | grep lime $ ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:2:2","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"内存转储中是什么？ 这个内存转储文件只是原始数据，就像使用 file 命令可以看到的一样。你不可能通过手动去理解它；是的，在这里边有一些 ASCII 字符，但是你无法用编辑器打开这个文件并把它读出来。hexdump 的输出显示，最初的几个字节是 EmiL；这是因为你的请求格式在上面的命令行中是 lime： $ file ~/LiME/RHEL8.3_64bit.mem /root/LiME/RHEL8.3_64bit.mem: data $ $ hexdump -C ~/LiME/RHEL8.3_64bit.mem | head 00000000 45 4d 69 4c 01 00 00 00 00 10 00 00 00 00 00 00 |EMiL............| 00000010 ff fb 09 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000020 b8 fe 4c cd 21 44 00 32 20 00 00 2a 2a 2a 2a 2a |..L.!D.2 ..*****| 00000030 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a |****************| 00000040 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 20 00 20 |************* . | 00000050 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000080 00 00 00 00 00 00 00 00 00 00 00 00 70 78 65 6c |............pxel| 00000090 69 6e 75 78 2e 30 00 00 00 00 00 00 00 00 00 00 |inux.0..........| 000000a0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| $ ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:2:3","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"部分 2：获得 Volatility 并使用它来分析你的内存转储 现在你有了要分析的示例内存转储，使用下面的命令获取 Volatility 软件。Volatility 已经用 Python 3 重写了，但是本教程使用的是用 Python 2 写的原始的 Volatility 包。如果你想用 Volatility 3 进行实验，可以从合适的 Git 仓库下载它，并在以下命令中使用 Python 3 而不是 Python 2： $ git clone https://github.com/volatilityfoundation/volatility.git $ $ cd volatility/ $ $ ls AUTHORS.txt contrib LEGAL.txt Makefile PKG-INFO pyinstaller.spec resources tools vol.py CHANGELOG.txt CREDITS.txt LICENSE.txt MANIFEST.in pyinstaller README.txt setup.py volatility $ Volatility 使用两个 Python 库来实现某些功能，所以使用以下命令来安装它们。否则，在你运行 Volatility 工具时，你可能看到一些导入错误；你可以忽略它们，除非你正在运行的插件需要这些库；这种情况下，工具将会报错： $ pip2 install pycrypto $ pip2 install distorm3 ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:3:0","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"列出 Volatility 的 Linux 配置文件 你将要运行的第一个 Volatility 命令列出了可用的 Linux 配置文件，运行 Volatility 命令的主要入口点是 vol.py 脚本。使用 Python 2 解释器调用它并提供 –info 选项。为了缩小输出，查找以 Linux 开头的字符串。正如你所看到的，并没有很多 Linux 配置文件被列出： $ python2 vol.py --info | grep ^Linux Volatility Foundation Volatility Framework 2.6.1 LinuxAMD64PagedMemory - Linux-specific AMD 64-bit address space. $ ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:3:1","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"构建你自己的 Linux 配置文件 Linux 发行版是多种多样的，并且是为不同架构而构建的。这就是为什么配置文件是必要的 —— Volatility 在提取信息前必须知道内存转储是从哪个系统和架构获得的。有一些 Volatility 命令可以找到这些信息；但是这个方法很费时。为了加快速度，可以使用以下命令构建一个自定义的 Linux 配置文件： 移动到 Volatility 仓库的 tools/linux目录下，运行 make 命令： $ cd tools/linux/ $ $ pwd /root/volatility/tools/linux $ $ ls kcore Makefile Makefile.enterprise module.c $ $ make make -C //lib/modules/4.18.0-240.el8.x86_64/build CONFIG_DEBUG_INFO=y M=\"/root/volatility/tools/linux\" modules make[1]: Entering directory '/usr/src/kernels/4.18.0-240.el8.x86_64' \u003c\u003c 删节 \u003e\u003e make[1]: Leaving directory '/usr/src/kernels/4.18.0-240.el8.x86_64' $ 你应该看到一个新的 module.dwarf 文件。你也需要 /boot 目录下的 System.map 文件，因为它包含了所有与当前运行的内核相关的符号： $ ls kcore Makefile Makefile.enterprise module.c module.dwarf $ $ ls -l module.dwarf -rw-r--r--. 1 root root 3987904 Apr 17 15:17 module.dwarf $ $ ls -l /boot/System.map-4.18.0-240.el8.x86_64 -rw-------. 1 root root 4032815 Sep 23 2020 /boot/System.map-4.18.0-240.el8.x86_64 $ $ 要创建一个自定义配置文件，移动回到 Volatility 目录并且运行下面的命令。第一个参数提供了一个自定义 .zip 文件，文件名是你自己命名的。我经常使用操作系统和内核版本来命名。下一个参数是前边创建的 module.dwarf 文件，最后一个参数是 /boot 目录下的 System.map 文件： $ $ cd volatility/ $ $ zip volatility/plugins/overlays/linux/Redhat8.3_4.18.0-240.zip tools/linux/module.dwarf /boot/System.map-4.18.0-240.el8.x86_64 adding: tools/linux/module.dwarf (deflated 91%) adding: boot/System.map-4.18.0-240.el8.x86_64 (deflated 79%) $ 现在自定义配置文件就准备好了，所以在前边给出的位置检查一下 .zip 文件是否被创建好。如果你想知道 Volatility 是否检测到这个自定义配置文件，再一次运行 –info 命令。现在，你应该可以在下边的列出的内容中看到新的配置文件： $ $ ls -l volatility/plugins/overlays/linux/Redhat8.3_4.18.0-240.zip -rw-r--r--. 1 root root 1190360 Apr 17 15:20 volatility/plugins/overlays/linux/Redhat8.3_4.18.0-240.zip $ $ $ python2 vol.py --info | grep Redhat Volatility Foundation Volatility Framework 2.6.1 LinuxRedhat8_3_4_18_0-240x64 - A Profile for Linux Redhat8.3_4.18.0-240 x64 $ $ ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:3:2","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"开始使用 Volatility 现在你已经准备好去做一些真正的内存取证了。记住，Volatility 是由自定义的插件组成的，你可以针对内存转储来获得信息。命令的通用格式是： python2 vol.py -f \u003cmemory-dump-file-taken-by-Lime\u003e \u003cplugin-name\u003e --profile=\u003cname-of-our-custom-profile\u003e 有了这些信息，运行 linux_banner 插件来看看你是否可从内存转储中识别正确的发行版信息： $ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_banner --profile=LinuxRedhat8_3_4_18_0-240x64 Volatility Foundation Volatility Framework 2.6.1 Linux version 4.18.0-240.el8.x86_64 ([mockbuild@vm09.test.com][4]) (gcc version 8.3.1 20191121 (Red Hat 8.3.1-5) (GCC)) #1 SMP Wed Sep 23 05:13:10 EDT 2020 $ ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:3:3","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"找到 Linux 插件 到现在都很顺利，所以现在你可能对如何找到所有 Linux 插件的名字比较好奇。有一个简单的技巧：运行 –info 命令并抓取 linux_ 字符串。有各种各样的插件可用于不同的用途。这里列出一部分： $ python2 vol.py --info | grep linux_ Volatility Foundation Volatility Framework 2.6.1 linux_apihooks - Checks for userland apihooks linux_arp - Print the ARP table linux_aslr_shift - Automatically detect the Linux ASLR shift \u003c\u003c 删节 \u003e\u003e linux_banner - Prints the Linux banner information linux_vma_cache - Gather VMAs from the vm_area_struct cache linux_volshell - Shell in the memory image linux_yarascan - A shell in the Linux memory image $ 使用 linux_psaux 插件检查内存转储时系统上正在运行哪些进程。注意列表中的最后一个命令：它是你在转储之前运行的 insmod 命令。 $ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_psaux --profile=LinuxRedhat8_3_4_18_0-240x64 Volatility Foundation Volatility Framework 2.6.1 Pid Uid Gid Arguments 1 0 0 /usr/lib/systemd/systemd --switched-root --system --deserialize 18 2 0 0 [kthreadd] 3 0 0 [rcu_gp] 4 0 0 [rcu_par_gp] 861 0 0 /usr/libexec/platform-python -Es /usr/sbin/tuned -l -P 869 0 0 /usr/bin/rhsmcertd 875 0 0 /usr/libexec/sssd/sssd_be --domain implicit_files --uid 0 --gid 0 --logger=files 878 0 0 /usr/libexec/sssd/sssd_nss --uid 0 --gid 0 --logger=files \u003c\u003c 删节 \u003e\u003e 11064 89 89 qmgr -l -t unix -u 227148 0 0 [kworker/0:0] 227298 0 0 -bash 227374 0 0 [kworker/u2:1] 227375 0 0 [kworker/0:2] 227884 0 0 [kworker/0:3] 228573 0 0 insmod ./lime-4.18.0-240.el8.x86_64.ko path=../RHEL8.3_64bit.mem format=lime 228576 0 0 $ 想要知道系统的网络状态吗？运行 linux_netstat 插件来找到在内存转储期间网络连接的状态： $ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_netstat --profile=LinuxRedhat8_3_4_18_0-240x64 Volatility Foundation Volatility Framework 2.6.1 UNIX 18113 systemd/1 /run/systemd/private UNIX 11411 systemd/1 /run/systemd/notify UNIX 11413 systemd/1 /run/systemd/cgroups-agent UNIX 11415 systemd/1 UNIX 11416 systemd/1 \u003c\u003c 删节 \u003e\u003e $ 接下来，使用 linux_mount 插件来看在内存转储期间哪些文件系统被挂载： $ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_mount --profile=LinuxRedhat8_3_4_18_0-240x64 Volatility Foundation Volatility Framework 2.6.1 tmpfs /sys/fs/cgroup tmpfs ro,nosuid,nodev,noexec cgroup /sys/fs/cgroup/pids cgroup rw,relatime,nosuid,nodev,noexec systemd-1 /proc/sys/fs/binfmt_misc autofs rw,relatime sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw,relatime /dev/mapper/rhel_kvm--03--guest11-root / xfs rw,relatime tmpfs /dev/shm tmpfs rw,nosuid,nodev selinuxfs /sys/fs/selinux selinuxfs rw,relatime \u003c\u003c 删节 \u003e\u003e cgroup /sys/fs/cgroup/net_cls,net_prio cgroup rw,relatime,nosuid,nodev,noexec cgroup /sys/fs/cgroup/cpu,cpuacct cgroup rw,relatime,nosuid,nodev,noexec bpf /sys/fs/bpf bpf rw,relatime,nosuid,nodev,noexec cgroup /sys/fs/cgroup/memory cgroup ro,relatime,nosuid,nodev,noexec cgroup /sys/fs/cgroup/cpuset cgroup rw,relatime,nosuid,nodev,noexec mqueue /dev/mqueue mqueue rw,relatime $ 好奇哪些内核模块被加载了吗？Volatility 也为这个提供了一个插件 linux_lsmod： $ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_lsmod --profile=LinuxRedhat8_3_4_18_0-240x64 Volatility Foundation Volatility Framework 2.6.1 ffffffffc0535040 lime 20480 ffffffffc0530540 binfmt_misc 20480 ffffffffc05e8040 sunrpc 479232 \u003c\u003c 删节 \u003e\u003e ffffffffc04f9540 nfit 65536 ffffffffc0266280 dm_mirror 28672 ffffffffc025e040 dm_region_hash 20480 ffffffffc0258180 dm_log 20480 ffffffffc024bbc0 dm_mod 151552 $ 想知道哪些文件被哪些进程打开了吗？使用 linux_bash 插件可以列出这些信息： $ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_bash --profile=LinuxRedhat8_3_4_18_0-240x64 -v Volatility Foundation Volatility Framework 2.6.1 Pid Name Command Time Command -------- -------------------- ------------------------------ ------- 227221 bash 2021-04-17 18:38:24 UTC+0000 lsmod 227221 bash 2021-04-17 18:38:24 UTC+0000 rm -f .log 227221 bash 2021-04-17 18:38:24 UTC+0000 ls -l /etc/zzz 227221 bash 2021-04-17 18:38:24 UTC+0000 cat ~/.vimrc 227221 bash 2021-04-17 18:38:24 UTC+0000 ls 227221 bash 2021-04-17 18:38:24 UTC+0000 cat /proc/817/cwd 227221 bash 2021-04-17 18:38:24 UTC+0000 ls -l /proc/817/cwd 227221 bash 2021-04-17 18:38:24 UTC+0000 ls /proc/817/ \u003c\u003c 删节 \u003e\u003e 227298 bash 2021-04-17 18:40:30 UTC+0000 gcc prt.c 227298 bash 2021-04-","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:3:4","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"访问 Linux 插件脚本位置 通过读取内存转储和处理这些信息，你可以获得更多的信息。如果你会 Python，并且好奇这些信息是如何被处理的，可以到存储所有插件的目录，选择一个你感兴趣的，并看看 Volatility 是如何获得这些信息的： $ ls volatility/plugins/linux/ apihooks.py common.py kernel_opened_files.py malfind.py psaux.py apihooks.pyc common.pyc kernel_opened_files.pyc malfind.pyc psaux.pyc arp.py cpuinfo.py keyboard_notifiers.py mount_cache.py psenv.py arp.pyc cpuinfo.pyc keyboard_notifiers.pyc mount_cache.pyc psenv.pyc aslr_shift.py dentry_cache.py ld_env.py mount.py pslist_cache.py aslr_shift.pyc dentry_cache.pyc ld_env.pyc mount.pyc pslist_cache.pyc \u003c\u003c 删节 \u003e\u003e check_syscall_arm.py __init__.py lsmod.py proc_maps.py tty_check.py check_syscall_arm.pyc __init__.pyc lsmod.pyc proc_maps.pyc tty_check.pyc check_syscall.py iomem.py lsof.py proc_maps_rb.py vma_cache.py check_syscall.pyc iomem.pyc lsof.pyc proc_maps_rb.pyc vma_cache.pyc $ $ 我喜欢 Volatility 的理由是他提供了许多安全插件。这些信息很难手动获取： linux_hidden_modules - Carves memory to find hidden kernel modules linux_malfind - Looks for suspicious process mappings linux_truecrypt_passphrase - Recovers cached Truecrypt passphrases Volatility 也允许你在内存转储中打开一个 shell，所以你可以运行 shell 命令来代替上面所有命令，并获得相同的信息： $ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_volshell --profile=LinuxRedhat8_3_4_18_0-240x64 -v Volatility Foundation Volatility Framework 2.6.1 Current context: process systemd, pid=1 DTB=0x1042dc000 Welcome to volshell! Current memory image is: file:///root/LiME/RHEL8.3_64bit.mem To get help, type 'hh()' \u003e\u003e\u003e \u003e\u003e\u003e sc() Current context: process systemd, pid=1 DTB=0x1042dc000 \u003e\u003e\u003e ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:3:5","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"接下来的步骤 内存转储是了解 Linux 内部情况的好方法。试一试 Volatility 的所有插件，并详细研究它们的输出。然后思考这些信息如何能够帮助你识别入侵或安全问题。深入了解这些插件的工作原理，甚至尝试改进它们。如果你没有找到你想做的事情的插件，那就写一个并提交给 Volatility，这样其他人也可以使用它。 ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:4:0","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"参考 使用开源工具进行 Linux 内存取证 [1] Perform Linux memory forensics with this open source tool [2] ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:4:1","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["收集与整理"],"content":"2021-05-25 今日技术分享 Go 中为什么应该使用接口 https://mp.weixin.qq.com/s/KqXI9ekYAZYd5oYmhqFH8Q 图解Go sync.Pool https://mp.weixin.qq.com/s/aiOjUcN89nxwEUJzVNkl3A 自制文件系统 — 01 文件系统的样子 https://mp.weixin.qq.com/s/0FpQGDzFh_D7IJi6z7oXjg 深入 Go 中各个高性能 JSON 解析库 https://mp.weixin.qq.com/s/FBT5QN_Pja6vRntWY0wFeA 【预告】理论结合实践详解 b+ 树存储引擎（innodb、boltdb、buntdb） https://mp.weixin.qq.com/s/lAD6GmqjElmgXduSDA6kAg 懂得取舍才是缓存设计的真谛 https://mp.weixin.qq.com/s/CWV_rssaz3fTvi7AqEo92w 详解 Go 空结构体的 3 种使用场景 https://mp.weixin.qq.com/s/zbYIdB0HlYwYSQRXFFpqSg 配置化系统中的图模型 https://mp.weixin.qq.com/s/ZDW9mg_iYI6a8dkpo31Sdw 曹大带我学 Go（2）—— 迷惑的 goroutine 执行顺序 https://mp.weixin.qq.com/s/WWfm7Ui7g_gGlb8XkIZigg Go可用性(六) 熔断 https://mp.weixin.qq.com/s/b5Wi1TqFVCCmpjvfmUcQBQ 懂得取舍才是缓存设计的真谛 https://my.oschina.net/kevwan/blog/5056791 immudb v1.0 released https://www.codenotary.com/blog/immudb-release-1-0/ 你知道 Goroutine 是怎么来的吗？ https://mp.weixin.qq.com/s/DZavvanPnRwZMPU-5_wOeg 分布式链路跟踪中的 traceid 和 spanid 代表什么？ https://mp.weixin.qq.com/s/eKbFYwnH4vwgWm6_5sWs3w Dart Flutter 数据库 ObjectBox 1.0 版本 https://objectbox.io/dart-flutter-database-1_0-release/ 区块链可扩展性的局限 by 以太坊之父 https://vitalik.ca/general/2021/05/23/scaling.html 学习golang.org/x/sync下的包 https://ketansingh.me/posts/golang-x-sync/ 什么是可观察性 by Brendan Gregg http://www.brendangregg.com/blog/2021-05-23/what-is-observability.html Uber API网关的架构 https://eng.uber.com/architecture-api-gateway/ Uber API网关的演化 https://eng.uber.com/gatewayuberapi/ 在Go 1.16中如何嵌入静态资源文件 https://www.josephspurrier.com/how-to-embed-assets-in-go-1-16 Zadig：一个云原生、分布式、面向开发者的持续交付产品 https://github.com/koderover/zadig 给Kubernetes服务提供人类可懂的注解 https://kubernetes.io/blog/2021/04/20/annotating-k8s-for-humans/ Kubernetes应用程序的预检工具，并支持捆绑其他框架 https://github.com/replicatedhq/troubleshoot 使用kubernetes自定义资源(CRD)来管理我们的短暂环境 https://medium.com/beamdental/using-kubernetes-custom-resources-to-manage-our-ephemeral-environments-f298610893e1 使用Kubeadm在Ubuntu virtualbox上安装kubernetes集群 https://kosyfrances.com/kubernetes-cluster/ MySQL索引失效的底层原理 https://www.yuque.com/u2278269/gq5x74/sotkoz goroutine 执行顺序 https://mp.weixin.qq.com/s/WWfm7Ui7g_gGlb8XkIZigg 调度本质 https://mp.weixin.qq.com/s/5E5V56wazp5gs9lrLvtopA ","date":"2021-05-25","objectID":"/article/2021/go20210525/:0:0","tags":["技术分享","Golang"],"title":"Go20210525 今日技术分享","uri":"/article/2021/go20210525/"},{"categories":["收集与整理"],"content":"2021-05-24 今日技术分享 2021 年 5 月程序员工资排行：Go的工资满意吗？ https://mp.weixin.qq.com/s/cX25jSXo_wI22x2CKWW2Cg Go语言爱好者周刊：第 96 期 — 用 Go 实现一个计算器 https://mp.weixin.qq.com/s/yKRK4cfcdJcdwh2u0tyi7w 源码级剖析new和make怎么用！ https://mp.weixin.qq.com/s/ClbdoJXPWlq0hP9ABzVJvQ 在 EKS 中实现基于 Promtail + Loki + Grafana 容器日志解决方案 https://mp.weixin.qq.com/s/Qotk0CNgsBrFy0Ot7AL0jQ 代码重构的原则和技巧 https://mp.weixin.qq.com/s/HlbURQBw35RUJOu5XEX9KA 深度探索Go语言（四）：包装方法 https://mp.weixin.qq.com/s/9KCIaWfka-z5GDEHfAnKzg 深度探索Go语言（五）：包装方法 https://mp.weixin.qq.com/s/yZpnWXfnrSPfAa6qXM4CUw 一本开源免费的 Go 进阶图书 https://mp.weixin.qq.com/s/C2y8WqjVnLXHRMYJa-hqvA 分布式链路跟踪中的traceid和spanid代表什么？ https://mp.weixin.qq.com/s/eKbFYwnH4vwgWm6_5sWs3w 使用gRPC改造Kubernetes通信 https://mp.weixin.qq.com/s/MUW_CcsXYH1RXQGfLcb6yw 什么技巧，能优化 Go 服务 40% 以上的 CPU？ https://mp.weixin.qq.com/s/1BUAy84aXOxWwHy0ZYOD1Q 五月第三股来袭，文末有彩蛋哦！ https://mp.weixin.qq.com/s/a-iNzl9kggG-oY28ShAhxw API 网关架构 https://eng.uber.com/architecture-api-gateway/ 使用 Go 语言对网页进行截屏 https://www.youtube.com/watch?v=4hrFtF6OuiM Go 并发同步包 https://ketansingh.me/posts/golang-x-sync/ 深入 Go 中各个高性能 JSON 解析库 https://www.luozhiyun.com/archives/535 lima: 一款 Go 语言实现的 Linux 虚拟机 https://github.com/AkihiroSuda/lima 初探Go代码混淆 https://paper.seebug.org/1586/ 有争议的Go错误处理 https://dev.to/hlmerscher/the-controversial-go-way-of-handling-errors-2ka1 高性能、自我托管的通讯和邮件列表管理器-listmonk发布1.0 https://github.com/knadh/listmonk Go错误处理：从拒绝到接受 https://evilmartians.com/chronicles/errors-in-go-from-denial-to-acceptance 一个简单而完整的功能开关解决方案 https://github.com/thomaspoignant/go-feature-flag Go实现的短链接应用 https://github.com/go-awesome/shortlink 我们如何在CockroachDB中建立可扩展的空间数据和空间索引 https://www.cockroachlabs.com/blog/how-we-built-spatial-indexing/ CI/CD pipeline的pipeline模式 https://harness.io/blog/devops/deployment-pipeline-patterns/ 对Postgres 14的早期看法：性能和监控的改进 https://pganalyze.com/blog/postgres-14-performance-monitoring 如何建立你作为开发者的个人品牌 https://www.freecodecamp.org/news/build-your-personal-brand-as-a-developer/ Rust进入Linux内核开发？ https://lwn.net/Articles/853423/ 知识图谱入门 http://ai.stanford.edu/blog/introduction-to-knowledge-graphs/ ","date":"2021-05-24","objectID":"/article/2021/go20210524/:0:0","tags":["技术分享","Golang"],"title":"Go20210524 今日技术分享","uri":"/article/2021/go20210524/"},{"categories":["Using Software"],"content":" 很少有 Unix 命令像 sed、grep 和 awk 一样出名，它们经常组合在一起，可能是因为它们具有奇怪的名称和强大的文本解析能力。它们还在一些语法和逻辑上有相似之处。虽然它们都能用于文本解析，但都有其特殊性。本文研究 sed 命令，它是一个 流编辑器。 ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:0","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["Using Software"],"content":"安装 sed 如果你使用的是 Linux、BSD 或 macOS，那么它们已经安装了 GNU 的或 BSD 的 sed。这些是原始 sed 命令的独特重新实现。虽然它们很相似，但也有一些细微的差别。本文已经在 Linux 和 NetBSD 版本上进行了测试，所以你可以使用你的计算机上找到的任何 sed，但是对于 BSD sed，你必须使用短选项（例如 -n 而不是 –quiet）。 GNU sed 通常被认为是功能最丰富的 sed，因此无论你是否运行 Linux，你可能都想要尝试一下。如果在 Ports 树中找不到 GNU sed（在非 Linux 系统上通常称为 gsed），你可以从 GNU 网站 下载源代码。 安装 GNU sed 的好处是，你可以使用它的额外功能，但是如果需要可移植性，还可以限制它以遵守 sed 的 POSIX 规范。 MacOS 用户可以在 MacPorts 或 Homebrew 上找到 GNU sed。 在 Windows 上，你可以通过 Chocolatey 来 安装 GNU sed。 ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:1","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["Using Software"],"content":"了解模式空间和保留空间 sed 一次只能处理一行。因为它没有可视化模式，所以会创建一个 模式空间，这是一个内存空间，其中包含来自输入流的当前行（删除了尾部的任何换行符）。填充模式空间后，sed 将执行你的指令。当命令执行完时，sed 将模式空间中的内容打印到输出流，默认是 标准输出，但是可以将输出重定向到文件，甚至使用 --in-place=.bak 选项重定向到同一文件。 然后，循环从下一个输入行再次开始。 为了在遍历文件时提供一点灵活性，sed 还提供了保留空间（有时也称为 保留缓冲区），即 sed 内存中为临时数据存储保留的空间。你可以将保留空间当作剪贴板，实际上，这正是本文所演示的内容：如何使用 sed 复制/剪切和粘贴。 首先，创建一个示例文本文件，其内容如下： Line one Line three Line two ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:2","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["Using Software"],"content":"复制数据到保留空间 要将内容放置在 sed 的保留空间，使用 h 或 H 命令。小写的 h 告诉 sed 覆盖保留空间中的当前内容，而大写的 H 告诉 sed 将数据追加到保留空间中已经存在的内容之后。 单独使用，什么都看不到： $ sed --quiet -e '/three/ h' example.txt $ --quiet（缩写为 -n）选项禁止显示所有输出，但 sed 执行了我的搜索需求。在这种情况下，sed 选择包含字符串 three 的任何行，并将其复制到保留空间。我没有告诉 sed 打印任何东西，所以没有输出。 ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:3","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["Using Software"],"content":"从保留空间复制数据 要了解保留空间，你可以从保留空间复制内容，然后使用 g 命令将其放入模式空间，观察会发生什么： $ sed -n -e '/three/h' -e 'g;p' example.txt Line three Line three 第一个空白行是因为当 sed 第一次复制内容到模式空间时，保留空间为空。 接下来的两行包含 Line three 是因为这是从第二行开始的保留空间。 该命令使用两个唯一的脚本（-e）纯粹是为了帮助提高可读性和组织性。将步骤划分为单独的脚本可能会很有用，但是从技术上讲，以下命令与一个脚本语句一样有效： $ sed -n -e '/three/h ; g ; p' example.txt Line three Line three ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:4","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["Using Software"],"content":"将数据追加到模式空间 G 命令会将一个换行符和保留空间的内容添加到模式空间。 $ sed -n -e '/three/h' -e 'G;p' example.txt Line one Line three Line three Line two Line three 此输出的前两行同时包含模式空间（Line one）的内容和空的保留空间。接下来的两行与搜索文本（three）匹配，因此它既包含模式空间又包含保留空间。第三行的保留空间没有变化，因此在模式空间（Line two）的末尾是保留空间（仍然是 Line three）。 ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:5","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["Using Software"],"content":"用 sed 剪切和粘贴 现在你知道了如何将字符串从模式空间转到保留空间并再次返回，你可以设计一个 sed 脚本来复制、删除，然后在文档中粘贴一行。例如，将示例文件的 Line three 挪至第三行，sed 可以解决这个问题： $ sed -n -e '/three/ h' -e '/three/ d' \\ -e '/two/ G;p' example.txt Line one Line two Line three 第一个脚本找到包含字符串 three 的行，并将其从模式空间复制到保留空间，替换当前保留空间中的任何内容。 第二个脚本删除包含字符串 three 的任何行。这样就完成了与文字处理器或文本编辑器中的 剪切 动作等效的功能。 最后一个脚本找到包含字符串 two 的行，并将保留空间的内容_追加_到模式空间，然后打印模式空间。 任务完成。 ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:6","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["Using Software"],"content":"使用 sed 编写脚本 再说一次，使用单独的脚本语句纯粹是为了视觉和心理上的简单。剪切和粘贴命令作为一个脚本同样有效： $ sed -n -e '/three/ h ; /three/ d ; /two/ G ; p' example.txt Line one Line two Line three 它甚至可以写在一个专门的脚本文件中： #!/usr/bin/sed -nf /three/h /three/d /two/ G p 要运行该脚本，将其加入可执行权限，然后用示例文件尝试： $ chmod +x myscript.sed $ ./myscript.sed example.txt Line one Line two Line three 当然，你需要解析的文本越可预测，则使用 sed 解决问题越容易。发明 sed 操作（例如复制和粘贴）的“配方”通常是不切实际的，因为触发操作的条件可能因文件而异。但是，你对 sed 命令的使用越熟练，就越容易根据需要解析的输入来设计复杂的动作。 重要的事情是识别不同的操作，了解 sed 何时移至下一行，并预测模式和保留空间包含的内容。 sed 很复杂。虽然它只有十几个命令，但它灵活的语法和原生功能意味着它充满了无限的潜力。 ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:7","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["Using Software"],"content":"参考 How to use the Linux sed command [1] 使用 sed 命令进行复制、剪切和粘贴 [2] ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:8","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["收集与整理"],"content":"2021-05-23 今日技术分享 用Go实现一个直播系统难吗？看看这个开源项目 https://mp.weixin.qq.com/s/5YPp7WFgVfPlGxim7tmQ5A Go语言数据争用与race原理 https://mp.weixin.qq.com/s/gGGg6wqQX5b1kEOeRbTQlA Go 标准库之 unsafe 包详解 https://mp.weixin.qq.com/s/Pj4Q_8sj2pCmXe2cHNqdvw Go - 开箱即用，WEB 界面一键安装，没有项目经验，可以拿这个练手 https://mp.weixin.qq.com/s/6RlAb7iWc3Tj6g7ttiBoRQ Loki 源码分析之日志写入 https://mp.weixin.qq.com/s/9BKZvNANqGJwziygytJ1ag 无限缓冲的channel(1) https://mp.weixin.qq.com/s/ETfrSqQczbW2SnaFjoUx0A 基于 Kubernetes 的微服务项目设计与实现 https://mp.weixin.qq.com/s/BjDx-pDQsuj6p_X01Vw92g 假如 Go 能说话，听听 GMP 的心声 https://mp.weixin.qq.com/s/Tgf-JU9YDume4jRHex65NA 利用 eBPF 支撑大规模 Kubernetes Service https://mp.weixin.qq.com/s/BJHzU4LxLdLnNzOnAqIptg Golang 中的适配器设计模式 https://www.smartscribs.com/adapter-design-pattern-in-golang/ 假如 Go 能说话，听听 GMP 的心声 https://mp.weixin.qq.com/s/Tgf-JU9YDume4jRHex65NA 小函数的调用开销需要考虑吗? https://mp.weixin.qq.com/s/nW0Cye1G_A72fm7MuBAM1A ","date":"2021-05-24","objectID":"/article/2021/go20210523/:0:0","tags":["技术分享","Golang"],"title":"Go20210523 今日技术分享","uri":"/article/2021/go20210523/"},{"categories":["收集与整理"],"content":"2021-05-21 今日技术分享 优化 Golang 服务来减少 40% 以上的 CPU https://mp.weixin.qq.com/s/dgVv6p8HQtc-krPGEdU2cQ fuckdb 新功能上线，开箱即用、更加强大的代码生成器 https://mp.weixin.qq.com/s/ysOlv8xsc7wF7cPcV5pu7g Go 面试官问我如何实现面向对象？ https://mp.weixin.qq.com/s/2x4Sajv7HkAjWFPe4oD96g 一文搞懂缓存系统稳定性 https://mp.weixin.qq.com/s/eNLB1BKZi4L3aNxbL0TqWQ kubernetes 平台开发者的几个小技巧 https://mp.weixin.qq.com/s/RVYJd_3xzDps-1xFwtl01g 周刊题解：常量表达式这个规则应该了解下 https://mp.weixin.qq.com/s/8fG0OMvwKziMSRs8bZFj2Q 企业微信万亿级日志检索系统 https://mp.weixin.qq.com/s/opxvlddsSQctb3nwcxaW_g 曹大带我学 Go（1）——调度的本质 https://mp.weixin.qq.com/s/5E5V56wazp5gs9lrLvtopA 初探 Go 代码混淆 https://mp.weixin.qq.com/s/q9xUFQ7HdHAis70WrFHuOQ 优化 Golang 服务减少 40% 以上的 CPU https://mp.weixin.qq.com/s/dgVv6p8HQtc-krPGEdU2cQ Go 实现 bridge 设计模式 https://www.smartscribs.com/bridge-design-pattern-in-golang/ Go 模板引擎 templ https://adrianhesketh.com/2021/05/18/introducing-templ/ 使用 Viper 和 Consul 配置 Go 应用 https://bencane.com/2021/05/18/using-viper-with-consul-to-configure-go-apps/ 实现无限缓存的channel https://colobu.com/2021/05/11/unbounded-channel-in-go/ pprof++: 一个带有硬件监控的 Go Profiler[译] https://mp.weixin.qq.com/s/-BSzD_wIEjHnHbs0xnsHXA istio 1.10发布，让StatefulSet使用起来更容易 https://istio.io/latest/blog/2021/statefulsets-made-easier/ templ：一个可用于go web的新模板引擎 https://adrianhesketh.com/2021/05/18/introducing-templ/ Go实现bridge设计模式 https://www.smartscribs.com/bridge-design-pattern-in-golang/ Kubernetes The Hard Way(aws版) https://github.com/prabhatsharma/kubernetes-the-hard-way-aws 用于在k8s上创建和管理postgresql数据库的k8s operator https://github.com/reactive-tech/kubegres 服务网格战争：和istio说byebye https://medium.com/polymatic-systems/service-mesh-wars-goodbye-istio-b047d9e533c7#--responses 你的技术项目需要Go时的5个场景 https://hackernoon.com/lets-go-5-use-cases-when-you-need-golang-for-your-tech-project-wp1931r0 ","date":"2021-05-22","objectID":"/article/2021/go20210521/:0:0","tags":["技术分享","Golang"],"title":"Go20210521 今日技术分享","uri":"/article/2021/go20210521/"},{"categories":null,"content":"请扫下方二维码打赏一杯咖啡。 多少不重要，1元也是支持 -- ","date":"2021-05-19","objectID":"/donations/:0:0","tags":null,"title":"捐助","uri":"/donations/"},{"categories":["收集与整理"],"content":"2021-05-18 今日技术分享 也许是你从来没用过的利器：GODEBUG https://mp.weixin.qq.com/s/lqOs34aMs7AYCxM_Jv0Hug 从0开发上线一个web项目（下） https://mp.weixin.qq.com/s/W5lHCgA_SzzyCoDaHDmz1Q 如何打造高性能的 Go 缓存库 https://mp.weixin.qq.com/s/G8LJ1HBuWoQfWV2dILi6Rg 【本周四预告】JetBrains GoLand 2021.1 新特性介绍 https://mp.weixin.qq.com/s/9DbBwdkBvECl11jSd-hbYw 用 Go struct 不能犯的一个低级错误！ https://mp.weixin.qq.com/s/EKbsUwLABjpadxPZ9AJGTg Go语言中new和make你使用哪个来分配内存？ https://mp.weixin.qq.com/s/XJ9O9O4KS3LbZL0jYnJHPg 同步secret和config到指定namespace https://mp.weixin.qq.com/s/i1fI58MhbWnPx7RFftLXkg 缓存数据一致性 - 架构师峰会演讲实录 https://mp.weixin.qq.com/s/DhIv9RACxa5igJTYg4N1mA kubebuilder 进阶: 源码分析 https://mp.weixin.qq.com/s/mlpNUwoqcNdT0kAowb_zrQ 咱Gopher好香啊，输入法、搜索Top行业招Gopher，还不快到碗里来？ https://mp.weixin.qq.com/s/HY4CpoPqXroMhJJ250quZQ 如何管理多版本的 go https://lakefs.io/managing-multiple-go-versions-with-go/ 一个 SQL 数据库只使用了 2000 行 golang 代码并且没有任何第三方依赖 https://github.com/auxten/go-sqldb 使用 go 开发一个监控剪贴板的服务 https://www.reddit.com/r/golang/comments/ncsnj2/monitoring_clipboard_as_service_with_go/ Gorm 复杂关系举例 https://github.com/harranali/gorm-relationships-examples 写了 500，000 行 go 代码之后 https://blog.khanacademy.org/half-a-million-lines-of-go GopherChina 全部日程出炉 https://gc.gocn.vip/ Go http应用的错误处理 https://www.joeshaw.org/error-handling-in-go-http-applications/ 使用 Open Telemetry为Go服务自动埋点 https://varunksaini.com/auto-instrument-open-telemetry-go/ 关于（过早）优化的思考 https://www.tnotes.dev/posts/thoughts-on-premature-optimization 使用2000行go代码实现的sql关系数据库 https://github.com/auxten/go-sqldb/blob/main/README-zh.md 使用Go管理多个Go版本 https://lakefs.io/managing-multiple-go-versions-with-go/ Go算法基础 https://yourbasic.org/algorithms/ 2021年最适合初学者学习的4种编程语言 https://qvault.io/news/top-coding-languages-for-beginners/ 哪些公司使用了Go（按领域) https://www.softkraft.co/companies-using-golang/ 面向云原生企业的统一事件驱动架构 https://thenewstack.io/unified-event-driven-architecture-for-the-cloud-native-enterprise/ Harbor仓库中锁定镜像避免误删的简便方法 https://mp.weixin.qq.com/s/sj6Nj9etH-Z4B7GPjHOZng 从几百个生产环境总结出的Redis性能问题排查解决手册 https://mp.weixin.qq.com/s/WcY-h_vxXVca94Xnw0Wrgg MySQL一条语句的执行 https://www.yuque.com/u2278269/gq5x74/ubr2zr kafka知识导图 https://processon.com/view/5fff01bb6376897ae0b610ff#map go luki 日志报警 https://mp.weixin.qq.com/s/wO0w1f8ptZf4Rv1KQ6I1sw ","date":"2021-05-18","objectID":"/article/2021/go20210518/:0:0","tags":["技术分享","Golang","Gorm","Mysql"],"title":"Go20210518 今日技术分享","uri":"/article/2021/go20210518/"},{"categories":["收集与整理"],"content":"2021-05-17 今日技术分享 单机内存内缓存怎么做？go-cache 了解下 https://mp.weixin.qq.com/s/LzfLySMPtbCO91q87UKRcQ Go语言爱好者周刊：第 95 期 — 自信点，这道题一定会 https://mp.weixin.qq.com/s/yBUlIhhGNSDUv7_J8Y0NmA 从0写一个 Go Web 服务 (上) https://mp.weixin.qq.com/s/vNUBJERfgmeV_qk_cdFoVQ 高性能 Go 代码工坊（Part7) https://mp.weixin.qq.com/s/ptUH-9dvRlA558SNakIbFQ 使用 Loki 进行日志报警(二) https://mp.weixin.qq.com/s/wO0w1f8ptZf4Rv1KQ6I1sw 用Kubernetes搭建Etcd集群和WebUI https://mp.weixin.qq.com/s/AkIvkW22dvqcdFXkiTpv8Q Leetcode:House Robber II https://mp.weixin.qq.com/s/-mUMeklJdajaSxlpqJB0MA 深度探索Go语言（三）：动态派发 https://mp.weixin.qq.com/s/XLj_AKqETZy4cUBNiNZPBw 通过例子，让你彻底搞懂微服务的演化过程 https://mp.weixin.qq.com/s/wWBlrjUUn-tx0v7ZTkha1g 5月你好，第二股来喽 https://mp.weixin.qq.com/s/onnAaqM8GoaphEtZ-KHO6g http.Client 的连接行为控制详解 https://mp.weixin.qq.com/s/2fAj_8vEQYLxddllqjsYFg unsafe.Pointer 和 uintptr 的区别和联系 https://mp.weixin.qq.com/s/l-ZQws4SH4QsvMhmJddiww Common anti-patterns in Go https://mp.weixin.qq.com/s/k-Use24-UCB3y_hV0tihVg 详解 http.Handle 与 http.HandleFunc 区别 https://ckarchive.com/b/75u7h8h730p5 i/o timeout ， 希望你不要踩到这个 net/http 包的坑 https://mp.weixin.qq.com/s/AKhRFKgs-I46Lnqhbk6Iog 当GOPATH与go module相遇时的混乱情况 https://arxiv.org/pdf/2102.12105.pdf 使用NATS作为http.RoundTripper的实现 https://github.com/ripienaar/nats-roundtripper 油管视频：用net包建立一个DIY代理 https://www.youtube.com/watch?v=J4J-A9tcjcA 使用Telepresence 2进行Kubernetes调试和本地开发 https://codefresh.io/kubernetes-tutorial/telepresence-2-local-development/ Kubernetes the Hard Way (azure版) https://github.com/carlosonunez/kubernetes-the-hard-way-on-azure 像top那样的容器度量数据采集工具 https://github.com/bcicen/ctop UTF-8历史 by Rob Pike http://doc.cat-v.org/bell_labs/utf-8_history 10分钟内学会go https://www.codingholygrail.com/learn-go-in-10-mins 为Go项目逐步构建优化的Docker镜像 https://www.codingholygrail.com/build-docker-image-for-golang-projects 软件测试的角色 https://blog.thundra.io/4-software-testing-roles 在Rust中做不了的事情（以及该怎么做） https://blog.logrocket.com/what-you-cant-do-in-rust-and-what-to-do-instead/ ","date":"2021-05-17","objectID":"/article/2021/go20210517/:0:0","tags":["技术分享","Golang","Rust"],"title":"Go20210517 今日技术分享","uri":"/article/2021/go20210517/"},{"categories":["收集与整理"],"content":"2021-05-16 今日技术分享 面试官：说说unsafe.Pointer和uintptr的区别和联系 https://mp.weixin.qq.com/s/l-ZQws4SH4QsvMhmJddiww http.Client的连接行为控制详解 https://mp.weixin.qq.com/s/2fAj_8vEQYLxddllqjsYFg 你不知道的 Go 之 slice https://mp.weixin.qq.com/s/-VRyRg9d-65lNTFRPvoCLw go每日新闻(2021-05-14)——Go语言内存分配 https://mp.weixin.qq.com/s/wembkRjdv8IErolT4IpnCg 说说常见数据库及中间件的主从设计 https://mp.weixin.qq.com/s/EXTdTsOcCuWpaNXOATpGFQ i/o timeout ， 希望你不要踩到这个net/http包的坑 https://mp.weixin.qq.com/s/AKhRFKgs-I46Lnqhbk6Iog Common anti-patterns in Go https://mp.weixin.qq.com/s/k-Use24-UCB3y_hV0tihVg 服务注册中心和配置中心的选择 https://mp.weixin.qq.com/s/4gOoYI9GsfauCcDoq_6Wxw golang 并发底层实现竟然都是它！！！ https://mp.weixin.qq.com/s/7BeLEzqmA1IR-rjVig0Qbw golang 编写的 GBA 模拟器 https://github.com/pokemium/magia 漫谈 Go 语言编译器（01） https://mp.weixin.qq.com/s/0q0k8gGX56SBKJvfMquQkQ semaphore 的原理与实现 https://mp.weixin.qq.com/s/GB649snXQ5rDF2BXO9V55Q pprof++：具有硬件性能监控的 Go 探查器 https://eng.uber.com/pprof-go-profiler 对cni benchmark中Cilium网络性能的理解 https://cilium.io/blog/2021/05/11/cni-benchmark 编程与写作 by redis之父 http://antirez.com/news/135 fly.io的Prometheus度量采集实践 https://fly.io/blog/measuring-fly/ go实现的GBA游戏模拟器 https://github.com/pokemium/magia 使用go构建rest server：身份验证 https://eli.thegreenplace.net/2021/rest-servers-in-go-part-6-authentication 使用go和无服务框架构建OKR跟踪工具 https://arjitjaiswal.medium.com/building-okayar-part-1-how-it-started-back-end-crud-serverless-lambda-api-in-go-3248ae93c97c 了解如何使用Rancher的kim和K3s更快地构建函数 https://www.openfaas.com/blog/kim/ 减少Kubernetes的AWS账单的8个最佳做法 https://cast.ai/blog/8-best-practices-to-reduce-your-aws-bill-for-kubernetes Go实现的bloom filter包 https://github.com/bits-and-blooms/bloom iptables: kubernetes service是如何将流量打到pod中的 https://dustinspecker.com/posts/iptables-how-kubernetes-services-direct-traffic-to-pods/ 经过8年努力，scala 3终于发布了！ https://scala-lang.org/blog/2021/05/14/scala3-is-here.html 在大规模数据中心运行BGP协议 by facebook https://engineering.fb.com/2021/05/13/data-center-engineering/bgp/ ","date":"2021-05-16","objectID":"/article/2021/go20210516/:0:0","tags":["技术分享","Golang"],"title":"Go20210516 今日技术分享","uri":"/article/2021/go20210516/"},{"categories":["收集与整理"],"content":"今日技术分享 Uber 使用 Go 的规模这么大？！都自己定制的 Go 编译器了 https://mp.weixin.qq.com/s/oJ6BD8AXbKKe_OBj9kCx6A Go：如何优雅地实现并发编排任务 https://mp.weixin.qq.com/s/5RhaUEk33kf4LkcZphyt_g grpc Go Client 源码分析 https://mp.weixin.qq.com/s/SQ22u7l17mWl2nQlSqvGXg 使用 Loki 进行日志报警(一) https://mp.weixin.qq.com/s/s4g_lg9k1QjGa-GLRfZtEg Go 程序运行时数据统计的可视化工具 statsviz https://mp.weixin.qq.com/s/gaQhIo544VHYeGcKq34GIw Rust 劝退系列 06：常量 https://mp.weixin.qq.com/s/y5WJbP8qcvdm4WASXEEibQ semaphore 的原理与实现 https://mp.weixin.qq.com/s/GB649snXQ5rDF2BXO9V55Q kubebuilder 进阶: webhook https://mp.weixin.qq.com/s/CFggTa7E91Rf1N1EZZpOBA 【直播】5.15（周六）9:00 聊聊风控系统构建演进过程~欢迎扫码报名 https://mp.weixin.qq.com/s/KctKKf0VUCt0AppLyEEtrg 为什么 Go map 和 slice 是非线性安全的？ https://mp.weixin.qq.com/s/TzHvDdtfp0FZ9y1ndqeCRw 深度剖析 Go 的 nil https://mp.weixin.qq.com/s/wwpDqXZ8VsDL0N2IKjJNDA 熔断原理与实现 Golang 版 https://blog.51cto.com/u_15175878/2774901 Golang 语言中怎么拦截系统信号和优雅退出 http server？ https://mp.weixin.qq.com/s/yvK42TntdzAI9S6kBFFZ-w 关于如何组织 Go 项目结构的思考 https://changelog.com/posts/on-go-application-structure kubernetes 问题排查: 系统时间被修改导致 sandbox 冲突 https://mp.weixin.qq.com/s/DJMrRBP237BE69pTyrKmnQ 可汗学院 Go 语言实践 https://blog.khanacademy.org/half-a-million-lines-of-go/ 编写50w行Go代码之后：可汗学院工程师的Go感悟 https://blog.khanacademy.org/half-a-million-lines-of-go/ 为什么你应该在你的Go服务器处理程序中使用errgroup.WithContext https://bionic.fullstory.com/why-you-should-be-using-errgroup-withcontext-in-golang-server-handlers/ BuildKit CLI for kubectl是docker build的替代品 https://container-registry.com/posts/productivity-lift-buildkit-cli-for-kubectl/ docker和kubernetes是如何创建ip地址的 https://dustinspecker.com/posts/how-do-kubernetes-and-docker-create-ip-addresses/ Go语言eBPF入门 https://networkop.co.uk/post/2021-03-ebpf-intro/ k8s集群中如何切换容器运行时 https://dev.to/stack-labs/how-to-switch-container-runtime-in-a-kubernetes-cluster-1628 gohugo vs. jekyll，哪个才是你的菜 https://draft.dev/learn/posts/hugo-vs-jekyll-which-is-right-for-your-blog mk48: go实现的开源游戏项目 https://github.com/SoftbearStudios/mk48 如何构建良好的远程工作文化 https://liuandrewk.medium.com/how-to-build-a-good-remote-work-culture-5f482cd4f1dd 油管视频：git和github教程 https://www.youtube.com/watch?v=RGOj5yH7evk Go语言内存分配 https://mp.weixin.qq.com/s/Hm8egXrdFr5c4-v--VFOtg 用100行Go代码实现容器 https://medium.com/@ssttehrani/containers-from-scratch-with-golang-5276576f9909 图解kafka架构原理 https://mp.weixin.qq.com/s/4zH9kfuC6FYh4hYo0CLtTg ","date":"2021-05-15","objectID":"/article/2021/go20210515/:0:0","tags":["技术分享","Golang"],"title":"Go20210515 今日技术分享","uri":"/article/2021/go20210515/"},{"categories":["收集与整理"],"content":"今日技术分享 面试官：聊聊 defer 的工作原理。。。 https://mp.weixin.qq.com/s/oWlQU9c9z11CHdOwOMOHxA 深度解密Go语言之基于信号的抢占式调度 https://mp.weixin.qq.com/s/xdhv24Lh-7smOT5ESw2dBw 聊聊如何做技术分享 https://mp.weixin.qq.com/s/iRe1aGShDBeVhLhOSHwbMQ Uber 使用 Go 的规模这么大？！都自己定制的 Go 编译器了 https://mp.weixin.qq.com/s/MO0WNlwecDVLx4QfWklamA 如何让消息队列达到最大吞吐量？ https://mp.weixin.qq.com/s/Y1qWYdzNs8EXCFu_DtBH9g 薪资比肩北上广，你会考虑回老家吗？急招哦 https://mp.weixin.qq.com/s/koCxSjX8tXMMY3Yn8c4KpA kubebuilder 进阶: 测试 https://mp.weixin.qq.com/s/tcLIx3E0LyRkNhPO0U8zmg 从0.5到1用golang上线一个web项目 https://mp.weixin.qq.com/s/ZqbDY3IjtH2s5_oeDvhQVQ 从0到0.5用golang写一个web项目 https://mp.weixin.qq.com/s/XXLFwlmOUaD7a3hftYCd2A 译文 Go 的抢占式调度 https://gocn.vip/topics/12062 深度解密 Go 语言之基于信号的抢占式调度 https://mp.weixin.qq.com/s/ESfbVoCGUIdpwFOfGyvz1w 使用 Golang 的交叉编译 https://linux.cn/article-13385-1.html Go 无分支编码 https://mattnakama.com/blog/go-branchless-coding/ Go 数组比切片好在哪？ https://mp.weixin.qq.com/s/zp1vdhGukEYKpzAdPt--Mw minikube v1.20.0版本的一个bug https://t.zsxq.com/RbEufqr 关于Go项目代码结构的思考 https://changelog.com/posts/on-go-application-structure Kubernetes的三个租户模型 https://kubernetes.io/blog/2021/04/15/three-tenancy-models-for-kubernetes/ 经典旧文：对go测试的崇拜 https://danmux.com/posts/the_cult_of_go_test/ Calico的可插拔式数据平面的重要性 https://thenewstack.io/the-importance-of-calicos-pluggable-data-plane/ 使用curl探索kubernetes https://blog.tilt.dev/2021/03/18/kubernetes-is-so-simple.html 用eStargz加快在各种工具上pull容器镜像的速度 https://medium.com/nttlabs/lazy-pulling-estargz-ef35812d73de Kubernetes中AWS NLB超时的一个奇怪的案例 https://build.thebeat.co/a-curious-case-of-aws-nlb-timeouts-in-kubernetes-522bd88a3399 为SQL数据库dolt构建fuzz testing https://www.dolthub.com/blog/2021-05-12-dolt-and-fuzz-testing/ 使用Go CDK(Cloud Development Kit )创建Elastic Kubernetes Service https://www.steveyackey.com/post/eks-cdk-go/ pause容器源码 https://mp.weixin.qq.com/s/2kkD6Dx40Ilu7HWpCe43hw MySQL 学习 https://mp.weixin.qq.com/s/sRFmW57KUY3yyyRkyw0L4A etcd 操作 boltdb 的优化实现 https://mp.weixin.qq.com/s/Cv1lagwtSkonQQes_0Sndw ","date":"2021-05-14","objectID":"/article/2021/go20210514/:0:0","tags":["技术分享","Golang"],"title":"Go20210514 今日技术分享","uri":"/article/2021/go20210514/"},{"categories":["收集与整理"],"content":"今日技术分享 Go：跨团队协作时如何共享对象 https://mp.weixin.qq.com/s/zJaruocUDSzld8ttDyawng template源码分析 https://mp.weixin.qq.com/s/HqcaFEXgQbcRyjYjI6oKGQ kubebuilder 实战: status \u0026 event https://mp.weixin.qq.com/s/JuRlClCX7TnQKaW-Rr3Z7g 如何优雅地实现并发编排任务 https://mp.weixin.qq.com/s/M88-VS_H7o754mw5Ra7BYg Prometheus 二次开发之 API 接口 https://mp.weixin.qq.com/s/K7ERtE2KKflYSA9KJOukYg 从TDSQL，看分布式数据库的技术之美 https://mp.weixin.qq.com/s/CbzlPmGJCQKi3UmvwjFC1Q Go Team Leader — rsc大神新开源了一个库，增强模板功能 https://mp.weixin.qq.com/s/3DFejimkPY9tg9QQL2QTqw Wow，联通数科也招Gopher了 https://mp.weixin.qq.com/s/tVY3AuUOYEnMKi7Km4eBCw Go 数组比切片好在哪？ https://mp.weixin.qq.com/s/zp1vdhGukEYKpzAdPt--Mw Go 缓存系列之 go-cache https://mp.weixin.qq.com/s/dKlfwJ69s3fUBWYIV57hyg Go 存储基础 — 内存结构体怎么写入文件？ https://mp.weixin.qq.com/s/mfNz7r76vZOOgiMSmuVeJA 深度解密Go语言之基于信号的抢占式调度 https://mp.weixin.qq.com/s/ESfbVoCGUIdpwFOfGyvz1w 实现无限缓存的 channel https://colobu.com/2021/05/11/unbounded-channel-in-go/ Go RIP 协议简单的模拟实现 https://segmentfault.com/a/1190000039984330 Golang 框架 gin 运行源码分析 https://mp.weixin.qq.com/s/D6Ls3fUZnmimg8EgBDuXcQ Golang MySQL 查询更轻松 https://mp.weixin.qq.com/s/Sdt_wYJCXepoUwIIy7h9yw golang 如何使用原生 RPC 及微服务简述 https://segmentfault.com/a/1190000039990286 Go并发：高级话题 https://t.zsxq.com/yJMRjiI pprof++: 带有硬件性能监控的Go性能剖析器 by uber https://eng.uber.com/pprof-go-profiler/ Kubernetes中混沌工程的开源解决方案 https://blog.flant.com/chaos-engineering-in-kubernetes-open-source-tools/ 用GoPacket对数据包进行捕获和程序化分析 https://blog.apnic.net/2021/05/12/programmatically-analyse-packet-captures-with-gopacket/ KrakenD：高性能API网关框架项目加入linux基金会 https://www.krakend.io/blog/krakend-framework-joins-the-linux-foundation/ 跳出Go module的泥潭 https://mp.weixin.qq.com/s/EndbbH0Cxw7jBmUOovs6Ew 在Kubernetes上用多容器pod扩展应用程序 https://learnk8s.io/sidecar-containers-patterns Popeye是一个实时扫描Kubernetes集群并报告部署资源和配置的潜在问题的工具 https://github.com/derailed/popeye 分布式账本技术（DLT）和数字凭证–完美的搭配 https://www.memberpass.com/2021/05/distributed-ledger-technology-dlt-and-digital-credentials-a-perfect-match/ 通过microsoft learn零基础学习Go编程语言 https://dev.to/azure/get-started-with-the-go-programming-language-with-microsoft-learn-no-experience-needed-1npg 通过AI和机器学习扩大网络防御 https://thenewstack.io/expanding-cyber-defense-through-ai-and-ml/ 云开发如何扛过大流量活动洪峰 https://mp.weixin.qq.com/s/WOhY_bTj213XP6tdUYQCZQ MySQL 学习 https://mp.weixin.qq.com/s/sRFmW57KUY3yyyRkyw0L4A 煎鱼 数组比切片好在哪里 https://mp.weixin.qq.com/s/zp1vdhGukEYKpzAdPt--Mw ","date":"2021-05-13","objectID":"/article/2021/go20210513/:0:0","tags":["技术分享","Golang"],"title":"Go20210513 今日技术分享","uri":"/article/2021/go20210513/"},{"categories":["开发技能","编程经验","收集与整理"],"content":"Swift介绍 Swift 是一门开发 iOS, macOS, watchOS 和 tvOS 应用的新语言。 swift 是一种安全，快速和互动的编程语言。 swift 支持代码预览（playgrounds），这个特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。 Swift 通过采用现代编程模式来避免大量常见编程错误： 变量始终在使用前初始化。 检查数组索引超出范围的错误。 检查整数是否溢出。 可选值确保明确处理 nil 值。 内存被自动管理。 错误处理允许从意外故障控制恢复。 ","date":"2021-05-13","objectID":"/article/2021/swift-basic-syntax/:0:1","tags":["swift","语法基础","编程学习","ios"],"title":"Swift语法全面解析","uri":"/article/2021/swift-basic-syntax/"},{"categories":["开发技能","编程经验","收集与整理"],"content":"基础部分 常量和变量 声明常量和变量， 常量和变量必须在使用前声明，使用 let 来声明常量，使用 var 来声明变量。 示例： let maximumNumberOfLoginAttempts = 10 var currentLoginAttempt = 0 // 类型注解 var welcomeMessage: String 注释 单行注释双正斜杠（//）， 多行注释（/* 多行的 */）。Swift 的多行注释可以嵌套在其它的多行注释之中。 示例： // 这是一个注释 /* 这也是一个注释， 但是是多行的 */ /* 这是第一个多行注释的开头 /* 这是第二个被嵌套的多行注释 */ 这是第一个多行注释的结尾 */ 分号 Swift 并不强制要求你在每条语句的结尾处使用分号（;）。 同一行内写多条独立的语句必须用分号分隔。 let cat = \"🐱\"; print(cat) // 输出“🐱” 标识符 标识符就是给变量、常量、方法、函数、枚举、结构体、类、协议等指定的名字。构成标识符的字母均有一定的规范，Swift语言中标识符的命名规则如下： 区分大小写，Myname与myname是两个不同的标识符； 标识符首字符可以以下划线（_）或者字母开始，但不能是数字； 标识符中其他字符可以是下划线（_）、字母或数字。 例如： userName、User_Name、_sys_val、身高等为合法的标识符，而2mail、room#和class为非法的标识符。 注意:Swift中的字母采用的是Unicode编码。Unicode叫做统一编码制，它包含了亚洲文字编码，如中文、日文、韩文等字符，甚至是我们在聊天工具中使用的表情符号 如果一定要使用关键字作为标识符，可以在关键字前后添加重音符号（`），例如： let `class` = \"xiaobai\" 关键字 关键字是类似于标识符的保留字符序列，除非用重音符号（`）将其括起来，否则不能用作标识符。关键字是对编译器具有特殊意义的预定义保留标识符。常见的关键字有以下4种。 与声明有关的关键字 class deinit enum extension func import init internal let operator private protocol public static struct subscript typealias var 与语句有关的关键字 break case continue default do else fallthrough for if in return switch where while 表达式和类型关键字 as dynamicType false is nil self Self super true _COLUMN_ _FILE_ _FUNCTION_ _LINE_ 在特定上下文中使用的关键字 associativity convenience dynamic didSet final get infix inout lazy left mutating none nonmutating optional override postfix precedence prefix Protocol required right set Type unowned weak willSet Swift 空格 Swift对空格的使用有一定的要求。 在Swift中，运算符不能直接跟在变量或常量的后面。例如下面的代码会报错： let a= 1 + 2 错误信息是： error: prefix/postfix '=' is reserved 意思大概是等号直接跟在前面或后面这种用法是保留的。 下面的代码还是会报错（继续注意空格）： let a = 1+ 2 错误信息是： error: consecutive statements on a line must be separated by ';' 这是因为Swift认为到1+这个语句就结束了，2就是下一个语句了。 只有这样写才不会报错： let a = 1 + 2; // 编码规范推荐使用这种写法 let b = 3+4 // 这样也是OK的 整数、浮点数 统一使用 Int 可以提高代码的可复用性，避免不同类型数字之间的转换， 并且匹配数字的类型推断。 示例： let minValue = UInt8.min // minValue 为 0，是 UInt8 类型 let maxValue = UInt8.max // maxValue 为 255，是 UInt8 类型 类型安全和类型推断 Swift 是一门类型安全的语言，这意味着 Swift 可以让你清楚地知道值的类型。 如果你没有显式指定类型，Swift 会使用类型推断来选择合适的类型。（int、double）。 示例： let meaningOfLife = 42 // meaningOfLife 会被推测为 Int 类型 let pi = 3.14159 // pi 会被推测为 Double 类型 数值型字面量、数值型类型转换 示例： let decimalInteger = 17 let binaryInteger = 0b10001 // 二进制的17 let octalInteger = 0o21 // 八进制的17 let hexadecimalInteger = 0x11 // 十六进制的17 类型别名 类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用 typealias 关键字来定义类型别名。 示例： typealias AudioSample = UInt16 var maxAmplitudeFound = AudioSample.min // maxAmplitudeFound 现在是 0 布尔值 示例： let orangesAreOrange = true let turnipsAreDelicious = false 元组 元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。 示例： let http404Error = (404, \"Not Found\") // http404Error 的类型是 (Int, String)，值是 (404, \"Not Found\") 可选类型 使用可选类型（optionals）来处理值可能缺失的情况。可选类型表示两种可能：或者有值， 你可以解析可选类型访问这个值， 或者根本没有值。 示例： var serverResponseCode: Int? = 404 // serverResponseCode 包含一个可选的 Int 值 404 serverResponseCode = nil // serverResponseCode 现在不包含值 错误处理 错误处理，应对程序执行中可能会遇到的错误条件。 示例： func makeASandwich() throws { // ... } do { try makeASandwich() eatASandwich() } catch SandwichError.outOfCleanDishes { washDishes() } catch SandwichError.missingIngredients(let ingredients) { buyGroceries(ingredients) } 断言和先决条件 断言和先决条件，是在运行时所做的检查。 let age = -3 assert(age \u003e= 0, \"A person's age cannot be less than zero\") // 因为 age \u003c 0，所以断言会触发 基本运算符 Swift 支持大部分标准 C 语言的运算符，还提供了 C 语言没有的区间运算符，例如 a..\u003cb 或 a...b。 赋值运算符，算术运算符，组合赋值运算符，比较运算符，三元运算符，空合运算符，区间运算符，逻辑运算符 运算符分为一元、二元和三元运算符。 闭区间运算符（a…b）定义一个包含从 a 到 b（包括 a 和 b）的所有值的区间。 半开区间运算符（a..\u003cb）定义一个从 a 到 b 但不包括 b 的区间。 闭区间操作符有另一个表达形式，可以表达往一侧无限延伸的区间，(a…，…b)。 示例： let names = [\"Anna\", \"Alex\", \"Brian\", \"Jack\"] let count = names.count for i in 0..\u003ccount { print(\"第 \\(i + 1)个人叫 \\(names[i])\") } // 第 1 个人叫 Anna // 第 2 个人叫 Alex // 第 3 个人叫 Brian // 第 4 个人叫 Jack 字符串和字符 字符串字面量，字符串插值，计算字符数量，访问和修改字符串，子字符串，比较字符串 初始化空字符串，字符串可变性，字符串是值类型，连接字符串和字符(+，+=)。 使用字符，可通过 for-in 循环来遍历字符串，获取字符串中每一个字符的值。 字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。可以在已有字符串中插入常量、变量、字面量和表达式从而形成更长的字符串。 Swift 提供了三种方式来比较文本值：字符串字符相等、前缀相等和后缀相等。 示例： // 多行字符串字面量 let quotation = \"\"\" The White Rabbit put on hi","date":"2021-05-13","objectID":"/article/2021/swift-basic-syntax/:0:2","tags":["swift","语法基础","编程学习","ios"],"title":"Swift语法全面解析","uri":"/article/2021/swift-basic-syntax/"},{"categories":["收集与整理","编程经验"],"content":" 在 Linux 上测试软件时，我使用各种架构的服务器，例如 Intel、AMD、Arm 等。当我 分配了一台满足我的测试需求的 Linux 机器[1]，我仍然需要执行许多步骤： 下载并安装必备软件 验证构建服务器上是否有新的测试软件包 获取并设置依赖软件包所需的 yum 仓库 下载并安装新的测试软件包（基于步骤 2） 获取并设置必需的 SSL 证书 设置测试环境，获取所需的 Git 仓库，更改配置，重新启动守护进程等 做其他需要做的事情 ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:0","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"用脚本自动化 这些步骤非常常规，以至于有必要对其进行自动化并将脚本保存到中央位置（例如文件服务器），在需要时可以在此处下载脚本。为此，我编写了 100-120 行的 Bash shell 脚本，它为我完成了所有配置（包括错误检查）。这个脚本通过以下方式简化了我的工作流程： 配置新的 Linux 系统（支持测试的架构） 登录系统并从中央位置下载自动化 shell 脚本 运行它来配置系统 开始测试 ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:1","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"学习 Go 语言 我想学习 Go 语言 有一段时间了，将我心爱的 Shell 脚本转换为 Go 程序似乎是一个很好的项目，可以帮助我入门。它的语法看起来很简单，在尝试了一些测试程序后，我开始着手提高自己的知识并熟悉 Go 标准库。 我花了一个星期的时间在笔记本电脑上编写 Go 程序。我经常在我的 x86 服务器上测试程序，清除错误并使程序健壮起来，一切都很顺利。 直到完全转换到 Go 程序前，我继续依赖自己的 shell 脚本。然后，我将二进制文件推送到中央文件服务器上，以便每次配置新服务器时，我要做的就是获取二进制文件，将可执行标志打开，然后运行二进制文件。我对早期的结果很满意： $ wget http://file.example.com/\u003cmyuser\u003e/bins/prepnode $ chmod +x ./prepnode $ ./prepnode 然后，出现了一个问题 第二周，我从资源池中分配了一台新的服务器，像往常一样，我下载了二进制文件，设置了可执行标志，然后运行二进制文件。但这次它出错了，是一个奇怪的错误： $ ./prepnode bash: ./prepnode: cannot execute binary file: Exec format error $ 起初，我以为可能没有成功设置可执行标志。但是，它已按预期设置： $ ls -l prepnode -rwxr-xr-x. 1 root root 2640529 Dec 16 05:43 prepnode 发生了什么事？我没有对源代码进行任何更改，编译没有引发任何错误或警告，而且上次运行时效果很好，因此我仔细查看了错误消息 format error。 我检查了二进制文件的格式，一切看起来都没问题： $ file prepnode prepnode: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped 我迅速运行了以下命令，识别所配置的测试服务器的架构以及二进制试图运行的平台。它是 Arm64 架构，但是我编译的二进制文件（在我的 x86 笔记本电脑上）生成的是 x86-64 格式的二进制文件： $ uname -m aarch64 ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:2","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"脚本编写人员的编译第一课 在那之前，我从未考虑过这种情况（尽管我知道这一点）。我主要研究脚本语言（通常是 Python）以及 Shell 脚本。在任何架构的大多数 Linux 服务器上都可以使用 Bash Shell 和 Python 解释器。总之，之前一切都很顺利。 但是，现在我正在处理 Go 这种编译语言，它生成可执行的二进制文件。编译后的二进制文件由特定架构的指令码或汇编指令组成，这就是为什么我收到格式错误的原因。由于 Arm64 CPU（运行二进制文件的地方）无法解释二进制文件的 x86-64 指令，因此它抛出错误。以前，shell 和 Python 解释器为我处理了底层指令码或特定架构的指令。 ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:3","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"Go 的交叉编译 我检查了 Golang 的文档，发现要生成 Arm64 二进制文件，我要做的就是在运行 go build 命令编译 Go 程序之前设置两个环境变量。 GOOS 指的是操作系统，例如 Linux、Windows、BSD 等，而 GOARCH 指的是要在哪种架构上构建程序。 $ env GOOS=linux GOARCH=arm64 go build -o prepnode_arm64 构建程序后，我重新运行 file 命令，这一次它显示的是 ARM AArch64，而不是之前显示的 x86。因此，我在我的笔记本上能为不同的架构构建二进制文件。 $ file prepnode_arm64 prepnode_arm64: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, not stripped 我将二进制文件从笔记本电脑复制到 ARM 服务器上。现在运行二进制文件（将可执行标志打开）不会产生任何错误： $ ./prepnode_arm64 -h Usage of ./prepnode_arm64: -c Clean existing installation -n Do not start test run (default true) -s Use stage environment, default is qa -v Enable verbose output ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:4","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"其他架构呢？ x86 和 Arm 是我测试软件所支持的 5 种架构中的两种，我担心 Go 可能不会支持其它架构，但事实并非如此。你可以查看 Go 支持的架构： $ go tool dist list Go 支持多种平台和操作系统，包括： AIX Android Darwin Dragonfly FreeBSD Illumos ios Js/wasm JavaScript Linux NetBSD OpenBSD Plan 9 Solaris Windows 要查找其支持的特定 Linux 架构，运行： $ go tool dist list | grep linux 如下面的输出所示，Go 支持我使用的所有体系结构。尽管 x86_64 不在列表中，但 AMD64 兼容 x86-64，所以你可以生成 AMD64 二进制文件，它可以在 x86 架构上正常运行： $ go tool dist list | grep linux linux/386 linux/amd64 linux/arm linux/arm64 linux/mips linux/mips64 linux/mips64le linux/mipsle linux/ppc64 linux/ppc64le linux/riscv64 linux/s390x ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:5","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"处理所有架构 为我测试的所有体系结构生成二进制文件，就像从我的 x86 笔记本电脑编写一个微小的 shell 脚本一样简单： #!/usr/bin/bash archs=(amd64 arm64 ppc64le ppc64 s390x) for arch in ${archs[@]} do env GOOS=linux GOARCH=${arch} go build -o prepnode_${arch} done $ file prepnode_* prepnode_amd64: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=y03MzCXoZERH-0EwAAYI/p909FDnk7xEUo2LdHIyo/V2ABa7X_rLkPNHaFqUQ6/5p_q8MZiR2WYkA5CzJiF, not stripped prepnode_arm64: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, Go BuildID=q-H-CCtLv__jVOcdcOpA/CywRwDz9LN2Wk_fWeJHt/K4-3P5tU2mzlWJa0noGN/SEev9TJFyvHdKZnPaZgb, not stripped prepnode_ppc64: ELF 64-bit MSB executable, 64-bit PowerPC or cisco 7500, version 1 (SYSV), statically linked, Go BuildID=DMWfc1QwOGIq2hxEzL_u/UE-9CIvkIMeNC_ocW4ry/r-7NcMATXatoXJQz3yUO/xzfiDIBuUxbuiyaw5Goq, not stripped prepnode_ppc64le: ELF 64-bit LSB executable, 64-bit PowerPC or cisco 7500, version 1 (SYSV), statically linked, Go BuildID=C6qCjxwO9s63FJKDrv3f/xCJa4E6LPVpEZqmbF6B4/Mu6T_OR-dx-vLavn1Gyq/AWR1pK1cLz9YzLSFt5eU, not stripped prepnode_s390x: ELF 64-bit MSB executable, IBM S/390, version 1 (SYSV), statically linked, Go BuildID=faC_HDe1_iVq2XhpPD3d/7TIv0rulE4RZybgJVmPz/o_SZW_0iS0EkJJZHANxx/zuZgo79Je7zAs3v6Lxuz, not stripped 现在，每当配置一台新机器时，我就运行以下 wget 命令下载特定体系结构的二进制文件，将可执行标志打开，然后运行： $ wget http://file.domain.com/\u003cmyuser\u003e/bins/prepnode_\u003carch\u003e $ chmod +x ./prepnode_\u003carch\u003e $ ./prepnode_\u003carch\u003e ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:6","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"为什么？ 你可能想知道，为什么我没有坚持使用 shell 脚本或将程序移植到 Python 而不是编译语言上来避免这些麻烦。所以有舍有得，那样的话我不会了解 Go 的交叉编译功能，以及程序在 CPU 上执行时的底层工作原理。在计算机中，总要考虑取舍，但绝不要让它们阻碍你的学习。 ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:7","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"参考 Cross-compiling made easy with Golang [1] 使用 Golang 的交叉编译 [2] ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:8","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["Using Software"],"content":" 学习基本的 GNU Screen 终端复用技术，然后下载我们的终端命令备忘录，以便你能够熟悉常用的快捷方式。 对于一般用户而言，命令行终端窗口可能是令人困惑和神秘的。但随着你对 Linux 终端的进一步了解，你很快就会意识到它的高效和强大。不过，也不需要很长时间，你就会想让终端变得更加高效，除了将更多的终端放到你的终端，还有什么高好的方法能够提升你的终端效率呢？ ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:0","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"终端复用 终端的许多优点之一是它是一个集中控制的界面。它是一个能让你访问数百个应用程序的窗口，而你与每一个应用程序进行交互所需要的只是一个键盘。但是，现代计算机几乎总是有多余的处理能力，而且现代计算机专家喜欢多任务处理，导致一个窗口处理数百个应用程序的能力是相当有限的。 解决这一问题的常见答案是终端复用：即将虚拟终端叠放在一起，然后在它们之间移动的能力。通过终端复用器，你保持了集中控制，但是当你进行多任务时，你能够进行终端切换。更好的是，你能够在终端中拆分屏幕，使得在同一时间显示多个屏幕窗口。 ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:1","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"选择合适的复用器 一些终端提供类似的功能，有标签式界面和分割式视图，但也有细微的差别。首先，这些终端的功能依赖于图形化的桌面环境。其次，许多图形化的终端功能需要鼠标交互或使用不方便的键盘快捷键。终端复用器的功能在文本控制台上和在图形桌面上一样好用，而且键位绑定是针对常见的终端序列设计的，很方便。 现有两种流行的复用器：tmux 和 GNU Screen。尽管你与它们互动的方式略有不同，但它们做同样的事情，而且大多具有相同的功能。这篇文章是 GNU Screen 的入门指南。关于 tmux 的相关介绍，请阅读 Kevin Sonney 的 tmux 介绍。 ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:2","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"使用 GNU Screen GNU Screen 的基本用法很简单，通过 screen 命令启动，你将进入 Screen 会话的第 0 个窗口。在你决定需要一个新的终端提示符前，你可能很难注意到有什么变化。 当一个终端窗口被某项活动占用（比如，你启动了文本编辑器 Vim 或 Jove 或者你在处理音视频，或运行批处理任务），你可以新建一个窗口。要打开一个新的窗口，按 Ctrl+A，释放，然后按 c。这将在你现有窗口的基础上创建一个新的窗口。 你会知道当前你是在一个新的窗口中，因为你的终端除了默认的提示符外，似乎没有任何东西。当然，你的另一个终端仍然存在，它只是躲在新窗口的后面。要遍历打开的窗口，按 Ctrl+A，释放，然后按 n（表示下一个）或按 p（表示上一个）。在只打开两个窗口的情况下， n 和 p 的功能是一样的，但你可以随时打开更多的窗口（Ctrl+A，然后 c ），并在它们之间切换。 ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:3","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"分屏 GNU Screen 的默认行为更像移动设备的屏幕，而不是桌面：你一次只能看到一个窗口。如果你因为喜欢多任务而使用 GNU Screen ，那么只关注一个窗口可能看起来是一种退步。幸运的是，GNU Screen 可以让你把终端分成窗口中的窗口。 要创建一个水平分割窗口，按 Ctrl+A，然后按 s 。这将把一个窗口置于另一个窗口之上，就像窗格一样。然而，在你告诉它要显示什么之前，分割的空间是没有用途的。因此，在创建一个分割窗后，你可以用 Ctrl+A ，然后用 Tab 移动到分割窗中。一旦进入，使用 Ctrl+A 然后 n 浏览所有可用的窗口，直到你想显示的内容出现在分割窗格中。 你也可以按 Ctrl+A 然后按 | （这是一个管道字符，在大多数键盘上通过按下 shift 键加上 \\）创建垂直分割窗口。 ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:4","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"自定义 GNU Screen GNU Screen 使用基于 Ctrl+A 的快捷键。根据你的习惯，这可能会让你感觉非常自然，也可能非常不方便，因为你可能会用 Ctrl+A 来移动到一行的开头。无论怎样，GNU Screen 允许通过 .screenrc 配置文件进行各种定制。你可以用这个来改变触发键的绑定（称为 “转义” 键绑定）。 escape ^jJ 你还可以添加一个状态行，以帮助你在 Screen 会话中保持自己不迷失。 # status bar, with current window highlighted hardstatus alwayslastline hardstatus string '%{= kG}[%{G}%H%? %1`%?%{g}][%= %{= kw}%-w%{+b yk} %n*%t%?(%u)%? %{-}%+w %=%{g}][%{B}%m/%d %{W}%C%A%{g}]' # enable 256 colors attrcolor b \".I\" termcapinfo xterm 'Co#256:AB=\\E[48;5;%dm:AF=\\E[38;5;%dm' defbce on 在有多个窗口打开的会话中，有一个时刻提醒哪些窗口具有焦点活动，哪些窗口有后台活动的提醒器特别有用。它类似一种终端的任务管理器。 ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:5","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"备忘单 当你学习 GNU Screen 的使用方法时，需要记住很多新的键盘命令。有些命令你马上就能记住，但那些你不常使用的命令可能就很难记住了。你可以按 Ctrl+A 然后再按 ? 来访问 GNU Screen 的帮助界面。 学习 GNU Screen 是提高你使用你最喜欢的 终端模拟器 的效率和敏捷性的一个好方法。请试一试吧！ ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:6","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"参考 Linux tips for using GNU Screen [1] 使用 GNU Screen 的小技巧 [2] ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:7","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":" cron 是一个调度守护进程，它以指定的时间间隔执行任务，这些任务称为 corn 作业，主要用于自动执行系统维护或管理任务。例如，你可以设置一个 cron 作业来自动执行重复的任务，比如备份数据库或数据，使用最新的安全补丁更新系统，检查磁盘空间使用情况，发送电子邮件等等。 cron 作业可以按分钟、小时、日、月、星期或它们的任意组合运行。 cron 的一些优点 以下是使用 cron 作业的一些优点： 你可以更好地控制作业的运行时间。例如，你可以精确到分钟、小时、天等。 它消除了为循环任务逻辑而去写代码的需要，当你不再需要执行任务时，可以直接关闭它。 作业在不执行时不会占用内存，因此你可以节省内存分配。 如果一个作业执行失败并由于某种原因退出，它将在适当的时间再次运行。 安装 cron 守护进程 幸运的是，Fedora Linux 预先配置了运行重要的系统任务来保持系统更新，有几个实用程序可以运行任务例如 cron、anacron、at 和 batch 。本文只关注 cron 实用程序的安装。cron 和 cronie 包一起安装，cronie 包也提供 cron 服务。 ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:0","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"要确定软件包是否已经存在，使用 rpm 命令： $ rpm -q cronie Cronie-1.5.2-4.el8.x86_64 如果安装了 cronie ，它将返回 cronie 包的全名。如果你的系统中没有安装，则会显示未安装。 ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:1","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"使用以下命令安装： $ dnf install cronie ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:2","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"运行 cron 守护进程 cron 作业由 crond 服务来执行，它会读取配置文件中的信息。在将作业添加到配置文件之前，必须启动 crond 服务，或者安装它。什么是 crond 呢？crond 是 cron 守护程序的简称。要确定 crond 服务是否正在运行，输入以下命令： $ systemctl status crond.service ● crond.service - Command Scheduler Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor pre\u003e Active: active (running) since Sat 2021-03-20 14:12:35 PDT; 1 day 21h ago Main PID: 1110 (crond) 如果你没有看到类似的内容 Active: active (running) since…，你需要启动 crond 守护进程。要在当前会话中运行 crond 服务，输入以下命令： $ systemctl run crond.service 将其配置为开机自启动，输入以下命令： $ systemctl enable crond.service 如果出于某种原因，你希望停止 crond 服务，按以下方式使用 stop 命令： $ systemctl stop crond.service 要重新启动它，只需使用 restart 命令： $ systemctl restart crond.service 定义一个 cron 作业 ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:3","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"cron 配置 以下是一个 cron 作业的配置细节示例。它定义了一个简单的 cron 作业，将 git master 分支的最新更改拉取到克隆的仓库中： */59 * * * * username cd /home/username/project/design \u0026\u0026 git pull origin master 主要有两部分： 第一部分是 */59 * * * *。这表明计时器设置为第 59 分钟执行一次。 该行的其余部分是命令，因为它将从命令行运行。 在此示例中，命令本身包含三个部分： 作业将以用户 username 的身份运行 它将切换到目录 /home/username/project/design 运行 git 命令拉取 master 分支中的最新更改 ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:4","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"时间语法 如上所述，时间信息是 cron 作业字符串的第一部分，如上所属。它决定了 cron 作业运行的频率和时间。它按以下顺序包括 5 个部分： 分钟 小时 一个月中的某天 月份 一周中的某天 下面是一种更图形化的方式来解释语法： .--------------- 分钟 (0 - 59) | .------------- 小时 (0 - 23) | | .---------- 一月中的某天 (1 - 31) | | | .------- 月份 (1 - 12) 或 jan、feb、mar、apr … | | | | .---- 一周中的某天 (0-6) (周日=0 或 7) | | | | | 或 sun、mon、tue、wed、thr、fri、sat | | | | | * * * * * user-name command-to-be-executed ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:5","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"星号的使用 星号（*）可以用来替代数字，表示该位置的所有可能值。例如，分钟位置上的星号会使它每分钟运行一次。以下示例可能有助于更好地理解语法。 这个 cron 作业将每分钟运行一次： * * * * [command] 斜杠表示分钟的间隔数。下面的示例将每小时运行 12 次，即每 5 分钟运行一次： */5 * * * * [command] 下一个示例将每月的第二天午夜（例如 1 月 2 日凌晨 12:00，2 月 2 日凌晨 12:00 等等）： 0 0 2 * * [command] 关于 cron 时间格式，还有更多格式符号，此处没有展开 ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:6","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"使用 crontab 创建一个 cron 作业 cron 作业会在后台运行，它会不断检查 /etc/crontab 文件和 /etc/cron.*/ 以及 /var/spool/cron/ 目录。每个用户在 /var/spool/cron/ 中都有一个唯一的 crontab 文件。 不应该直接编辑这些 cron 文件。crontab 命令是用于创建、编辑、安装、卸载和列出 cron 作业的方法。 更酷的是，在创建新文件或编辑现有文件后，你无需重新启动 cron。 $ crontab -e 这将打开你现有的 crontab 文件，或者创建一个。调用 crontab -e 时，默认情况下会使用 vi 编辑器。注意：要使用 Nano 编辑 crontab 文件，可以设置 EDITOR=nano 环境变量。 使用 -l 选项列出所有 cron 作业。如果需要，使用 -u 选项指定一个用户。 $ crontab -l $ crontab -u username -l 使用以下命令删除所有 cron 作业： $ crontab -r 要删除特定用户的作业，你必须以 root 用户身份运行以下命令： $ crontab -r -u username cron 作业看起来可能只是系统管理员的工具，但它实际上与许多 Web 应用程序和用户任务有关。 参考 Fedora Linux 文档的 [1] 使用 cron 调度任务 [2] ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:7","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["收集与整理"],"content":"今日技术分享 unsafe 包真的不安全吗？ https://mp.weixin.qq.com/s/rIqkKNUecvnZ6gadThf4gg go-callvis 源码分析 https://mp.weixin.qq.com/s/dUXXGd8hqEhKE_Cj4EY2Lw 深度探索Go语言（二）：动态派发 https://mp.weixin.qq.com/s/fhpKBRqhRAxFnESQ4vTbWQ 再一次看到了 Go 的节制：int128 类型要不要支持？ https://mp.weixin.qq.com/s/5uW2rcIEhFPCCTPqrhwOow Go 笔试题精选 三： 19 道填空题 https://mp.weixin.qq.com/s/5Zd1DmQGDvjMySOUf7eFMg 在提赋能之前，先想想这5个问题 https://mp.weixin.qq.com/s/V8l7S7A-kRF_WDb7tlJJ0Q 代码无可避免腐化是因为这 5 个原因 https://mp.weixin.qq.com/s/IzDgV6AmK-2ph1ctcz9liA kubebuilder 实战: CRUD https://mp.weixin.qq.com/s/UDA55y5RCpzyDvfSfs9d2w 实现无限缓存的channel https://colobu.com/2021/05/11/unbounded-channel-in-go/ 轻轻松松打印网页并生成 pdf 文档 https://colobu.com/2021/05/05/generate-pdf-for-a-web-page-by-using-chromedp/ Go 1.16 的 signal.NotifyContext 让你的服务重启更优雅 https://juejin.cn/post/6960578101755510798 一种持锁被调度的情况 https://xargin.com/schedule-when-holding-lock-causes-latency-spike/ assembly 完全解析： https://segmentfault.com/a/1190000039978109?utm_source=tag-newest strace 的 10 个命令 https://colobu.com/2021/04/30/strace-commands-for-troubleshooting-and-debugging-linux/ 使eBPF工作在windows操作系统上 https://cloudblogs.microsoft.com/opensource/2021/05/10/making-ebpf-work-on-windows/ 油管视频：调试你的Go test代码：用printf还是delve https://www.youtube.com/watch?v=nmNVd7FbSYs 如何在你的本地项目中使用未发布的Go module https://iaziz786.com/blog/use-unpublished-go-modules Prometheus监控告警规则大全 https://awesome-prometheus-alerts.grep.to/ dblab: 支持与PostgreSQL和MySQL交互的终端命令行工具 https://github.com/danvergara/dblab 终端应用的自动黑暗模式 by vim-go作者 https://arslan.io/2021/02/15/automatic-dark-mode-for-terminal-applications/ 另一个开源的容器平台 https://github.com/sylabs/singularity 在Go中没有一个完美的切片克隆方案 https://github.com/go101/go101/wiki/There-is-not-a-perfect-slice-clone-way-in-Go 理解nil接口类型与值为nil的接口变量 https://trstringer.com/go-nil-interface-and-interface-with-nil-concrete-value/ 微软Teams的命令行终端UI工具 https://github.com/fossteams/teams-cli Kubernetes GUI大全 http://kokizzu.blogspot.com/2021/03/kubernetes-gui.html 如何做出你的第一个开源贡献 https://dev.to/codesandboxio/how-to-make-your-first-open-source-contribution-2oim 无服务器下的数据库 https://mp.weixin.qq.com/s/_MfuhpSAtZFnB8p-xp5HUw MySQL AUTO_UNCREMENT https://mp.weixin.qq.com/s/Ya3JrUftN0ASI8dTzb1lvw facebook google网络架构揭秘 https://mp.weixin.qq.com/s/MPBk9wdYsE48H7OXWAd5bA ","date":"2021-05-12","objectID":"/article/2021/go20210512/:0:0","tags":["技术分享","Golang"],"title":"Go20210512 今日技术分享","uri":"/article/2021/go20210512/"},{"categories":["关于"],"content":"关于我 勤奋的代码搬运工。 ","date":"2021-05-11","objectID":"/about/:0:1","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"为什么建立个人博客？ 宣传自己，这是一个信息爆炸、人人自我营销的时代，不懂得宣传自己，就得不到机会的垂青。 个人觉得IT从业者就应该有自己的博客网站，记录与分享自己的经验，收集有价值的文章。 凭借互联网的媒介，结交志同道合的朋友，为未来的事业做准备。 ","date":"2021-05-11","objectID":"/about/:0:2","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"关于本站 学习日记，点滴记录。 也会收集和分享互联网上比较经典且具有价值的文章。 ","date":"2021-05-11","objectID":"/about/:0:3","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"站长是谁： 昵称：白菜林 对于技术很爱折腾、很有热情的小哥。 联系站长：77370751（微信/qq同号，备注来意） 邮箱Email：77370751@qq.com 交流QQ群：153690156 给我留言：https://support.qq.com/product/325110 ","date":"2021-05-11","objectID":"/about/:0:4","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"我的主页 Gitee: https://lyhuilin.gitee.io/ Github: https://github.com/clin003/meBlog ","date":"2021-05-11","objectID":"/about/:0:5","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"未来发展： 未来很长，且慢慢耕耘。 ","date":"2021-05-11","objectID":"/about/:0:6","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"白菜林的博客小站历程： 2021年5月11日 白菜林的博客小站 建站并部署至Github page。 ","date":"2021-05-11","objectID":"/about/:0:7","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"特别感谢 非常感谢每一位走进本站的同学对我们的大力支持，你们的走进是我坚持的动力！ 如果不介意,请把本站分享给您的同学朋友！ 我会一直努力，不求最好，只求更好！ ","date":"2021-05-11","objectID":"/about/:0:8","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"Hello World! 白菜林^_^ ","date":"2021-05-11","objectID":"/article/2021/hello_world/:0:0","tags":["about"],"title":"Hello world","uri":"/article/2021/hello_world/"},{"categories":["收集与整理"],"content":"今日技术分享 图解 Go 内存管理分配 https://mp.weixin.qq.com/s/bMr4lZgf-Fn1oaOSPPSDIQ Go 刷 leetcode 之任务调度器 https://mp.weixin.qq.com/s/oI441vsKhYninXJjg3t3yA 自己动手实现一个 kubectl exec https://mp.weixin.qq.com/s/VmEcIYfsUbgh-p4RCssGFQ 云上细粒度访问管理的参考架构 https://mp.weixin.qq.com/s/3sfWGKFa1POMFcWYJbk6Ug Go 工程师必学：Go 大杀器之跟踪剖析 trace https://mp.weixin.qq.com/s/7DY0hDwidgx0zezP1ml3Ig Go并发编程 — sync.Once 单实例模式的思考 https://mp.weixin.qq.com/s/nMHNujmbIx7uMqMtjUMTvQ kustomize 简明教程 https://mp.weixin.qq.com/s/JDsDOYaACgyt97-Nz5ScDw 你不知道的 Go 之 slice https://mp.weixin.qq.com/s/aOIp7jeBWubT-u85vQJxzA 缓存系统稳定性 - 架构师峰会演讲实录 https://mp.weixin.qq.com/s/o0qUY5zUjBQuOkx_4XGB6Q 微服务的灾难 https://mp.weixin.qq.com/s/bY2s7wjfggSt77kj8exYLQ 利用 NATS JetStream 构建分布式事件流系统 https://shijuvar.medium.com/building-distributed-event-streaming-systems-in-go-with-nats-jetstream-3938e6dc7a13 100 行 Golang 代码构建一个简单的终端仿真器 https://ishuah.com/2021/03/10/build-a-terminal-emulator-in-100-lines-of-go 编写简单的 CLI 程序：Python vs Go https://dev.to/jidicula/writing-a-simple-cli-program-python-vs-go-59kf 如何使用 Go，Maroto 和 GoFakeIt 创建 PDF https://dev.to/divrhino/creating-a-pdf-with-go-maroto-gofakeit-3c7m 一个用 Go 编写的类似 cowsay 的开源程序 weebsay https://github.com/irevenko/weebsay 最受欢迎的编程语言（1965/2021） https://statisticsanddata.org/data/the-most-popular-programming-languages-1965-2021/ 用NATS JetStream在Go中构建分布式事件流系统 https://shijuvar.medium.com/building-distributed-event-streaming-systems-in-go-with-nats-jetstream-3938e6dc7a13 外部secret管理系统与k8s的集成 https://github.com/external-secrets/kubernetes-external-secrets 生成随机的、可发音的名字，像docker给容器起的默认名字那样 https://github.com/lucasepe/codename Pixie为CNCF带来Kubernetes集群内的调试能力 https://thenewstack.io/pixie-brings-in-cluster-kubernetes-debugging-to-cncf/ bofied: 一个网络启动服务器，支持PXE服务协议 https://github.com/pojntfx/bofied 糟糕的磁盘性能 by Brendan Gregg http://www.brendangregg.com/blog/2021-05-09/poor-disk-performance.html 油管视频：使用go重头构建container https://www.youtube.com/watch?v=8fi7uSYlOdc milvus：开源向量数据库搜索引擎 https://github.com/milvus-io/milvus 使用go加速python代码 https://medium.com/geekculture/speed-up-python-with-golang-9a1d2c6067ab go语言编译器 https://mp.weixin.qq.com/s/UhxFOQBpW8EUVpFvqH2tMg 虚拟内存工作原理 https://mp.weixin.qq.com/s/c81Fvws0J2tHjcdTgxvv6g redis vs tendis https://mp.weixin.qq.com/s/MeYkfOIdnU6LYlsGb24KjQ ","date":"2021-05-11","objectID":"/article/2021/go20210511/:0:0","tags":["技术分享","Golang","微服务"],"title":"Go20210511 今日技术分享","uri":"/article/2021/go20210511/"}]