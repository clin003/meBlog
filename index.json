[{"categories":["Nginx","收集与整理"],"content":"什么是浏览器同源策略？ 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。 同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 ","date":"2021-07-01","objectID":"/article/2021/nginx_cors_server_conf/:0:1","tags":["技术分享","跨域","CORS"],"title":"跨域方案Nginx配置","uri":"/article/2021/nginx_cors_server_conf/"},{"categories":["Nginx","收集与整理"],"content":"如何实现跨域？ 跨域是个比较古老的命题了，历史上跨域的实现手段有很多，我们现在主要介绍Nginx的跨域方案，其余的方案我们就不深入讨论了。 ","date":"2021-07-01","objectID":"/article/2021/nginx_cors_server_conf/:0:2","tags":["技术分享","跨域","CORS"],"title":"跨域方案Nginx配置","uri":"/article/2021/nginx_cors_server_conf/"},{"categories":["Nginx","收集与整理"],"content":"方便的跨域方案Nginx nginx是一款极其强大的web服务器，其优点就是轻量级、启动快、高并发。 现在的新项目中nginx几乎是首选，我们用node或者go开发的服务通常都需要经过nginx的反向代理。 反向代理的原理很简单，即所有客户端的请求都必须先经过nginx的处理，nginx作为代理服务器再讲请求转发给node或者go服务，这样就规避了同源策略。 #进程, 可更具cpu数量调整 worker_processes 1; events { #连接数 worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; #连接超时时间，服务器会在这个时间过后关闭连接。 keepalive_timeout 10; # gizp压缩 gzip on; # 直接请求nginx也是会报跨域错误的这里设置允许跨域 # 如果代理地址已经允许跨域则不需要这些, 否则报错(虽然这样nginx跨域就没意义了) add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Headers X-Requested-With; add_header Access-Control-Allow-Methods GET,POST,OPTIONS; # srever模块配置是http模块中的一个子模块，用来定义一个虚拟访问主机 server { listen 80; server_name localhost; # 根路径指到index.html location / { root html; index index.html index.htm; } # localhost/api 的请求会被转发到192.168.0.103:8080 location /api { rewrite ^/b/(.*)$ /$1 break; # 去除本地接口/api前缀, 否则会出现404 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://192.168.0.103:8080; # 转发地址 } # 重定向错误页面到/50x.html error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } ","date":"2021-07-01","objectID":"/article/2021/nginx_cors_server_conf/:0:3","tags":["技术分享","跨域","CORS"],"title":"跨域方案Nginx配置","uri":"/article/2021/nginx_cors_server_conf/"},{"categories":["Using Software"],"content":"find命令 描述：通过 find命令查找 语法：find ~ -iname “文件名*” /** * 比如我要查找一个以‘vue-’开头的.zip文件, * 但是你忘了它的全名也忘了在那个文件夹， * 查找范围是‘～’节点以内 * 就可以用这种方式进行模糊搜索 */ find ~ -iname \"vue-*.zip\" /** * 然后它就把所有包含符合条件的文件和路径都打印出来了 */ find不但能查找文件，还能查找文件夹 /** * 比如我要查找所有包含‘vue’的文件或文件夹 */ find ~ -iname \"*vue*\" /** * 结果它找到了所有包含‘vue’的文件或文件夹 */ find方式很简单但是需要一点专业知识，需要知道一些正则的基本常识，需要指定路径范围，搜索的名字需要加引号等等 ","date":"2021-06-27","objectID":"/article/2021/mac_find/:0:1","tags":["mac命令行","mac","find"],"title":"MAC命令快速模糊查找文件","uri":"/article/2021/mac_find/"},{"categories":["Using Software"],"content":"mdfind命令 描述：通过 mdfind命令查找 语法：mdfind -name 文件名 /** * 比如我要查找所有包含‘vue’的文件或文件夹 */ mdfind -name vue /** * 看，我直接输入我要找的关键字‘vue’ * 就把所有文件和文件夹都输出出来了，是不是很方便 */ mdfind 简单粗暴，没缺点，但有个前提是你mac电脑要支持Spotlight功能，不过也不用担心，一般mac默认是支持的 ","date":"2021-06-27","objectID":"/article/2021/mac_find/:0:2","tags":["mac命令行","mac","find"],"title":"MAC命令快速模糊查找文件","uri":"/article/2021/mac_find/"},{"categories":["Using Software"],"content":"在 shell 中执行命令 你是找到这个文件或文件夹了，但是你想直接打开它，那么怎么打开呢，看下面 若要运行当前用户个人文件夹中的命令，请在前面加上文件夹说明符。例如，若要运行 MyCommandLineProg，请使用以下命令： % ~/MyCommandLineProg 若要打开一个 App，请使用打开命令： % open -a MyProg.app ","date":"2021-06-27","objectID":"/article/2021/mac_find/:0:3","tags":["mac命令行","mac","find"],"title":"MAC命令快速模糊查找文件","uri":"/article/2021/mac_find/"},{"categories":["Using Software"],"content":"终止命令 在 Mac 上的“终端” App 中，点按正在运行您想要终止的命令的“终端”窗口。 按下 Control-C 键。 这会发出一个让大多数命令终止的信号。 ","date":"2021-06-27","objectID":"/article/2021/mac_find/:0:4","tags":["mac命令行","mac","find"],"title":"MAC命令快速模糊查找文件","uri":"/article/2021/mac_find/"},{"categories":["Using Software"],"content":"参考 在 Mac 上的“终端”中执行命令和运行工具 [1] MAC命令快速全局查找文件或文件夹，支持模糊搜索 [2] ","date":"2021-06-27","objectID":"/article/2021/mac_find/:0:5","tags":["mac命令行","mac","find"],"title":"MAC命令快速模糊查找文件","uri":"/article/2021/mac_find/"},{"categories":["编程经验","Learn Rust","收集与整理"],"content":"通常cargo跑得挺顺畅，不怎么需要proxy。但有备无患。 ","date":"2021-06-25","objectID":"/article/2021/rustproxy/:0:0","tags":["技术分享","Rust"],"title":"Rust 镜像源","uri":"/article/2021/rustproxy/"},{"categories":["编程经验","Learn Rust","收集与整理"],"content":"crates.io 和 rustup 的国内镜像源 字节跳动提供的：https://rsproxy.cn/ 中国科技大学的：https://mirrors.ustc.edu.cn/help/crates.io-index.html 清华大学的：https://mirrors.tuna.tsinghua.edu.cn/help/rustup/ 上海交通大学的：https://git.sjtu.edu.cn/sjtug/crates.io-index ","date":"2021-06-25","objectID":"/article/2021/rustproxy/:0:1","tags":["技术分享","Rust"],"title":"Rust 镜像源","uri":"/article/2021/rustproxy/"},{"categories":["趣站","轻松好玩"],"content":" 网页前端是一门技术活！出色的网站除了后台够快够可靠，也非常需要前端吸引眼球。在这个网站里，点击SHOW ME SOMETHING AWESOME就能随机跳转到一个新页面，往往是一些用了平时不太多见的网页设计元素制作出来的页面演示，有时候也会有独到设计的网页游戏，或许还有些别的内容。这个网站收录的内容都挺不错，有些网站的质量完全可以拿出来单独写一篇文章。 传送门 https://sharkle.com/ ","date":"2021-06-23","objectID":"/article/2021/sharkle/:0:0","tags":["web前端","创意","网页特效"],"title":"给我来点酷炫玩意-Sharkle","uri":"/article/2021/sharkle/"},{"categories":["趣站","轻松好玩"],"content":"方法 进入网站直接点击SHOW ME SOMETHING AWESOME即可欣赏！ ","date":"2021-06-23","objectID":"/article/2021/sharkle/:0:1","tags":["web前端","创意","网页特效"],"title":"给我来点酷炫玩意-Sharkle","uri":"/article/2021/sharkle/"},{"categories":["Learn Rust"],"content":"cargo-wix：创建Windows安装程序的cargo子命令 它使用二进制项目的发行版中的构建Windows安装程序（msi）。 如果可以使用提供的应用程序提供代码签名证书，则它还支持对Windows安装程序进行签名。 ","date":"2021-06-22","objectID":"/article/2021/cargo-wix/:0:0","tags":["wix","Rust"],"title":"Cargo Wix 创建Windows安装程序的cargo子命令","uri":"/article/2021/cargo-wix/"},{"categories":["Learn Rust"],"content":"快速开始 启动命令提示符（cmd.exe），然后执行以下命令： C:\\\u003ecargo install cargo-wix C:\\\u003ecd Path\\To\\Project C:\\Path\\To\\Project\\\u003ecargo wix init C:\\Path\\To\\Project\\\u003ecargo wix 该项目的Windows安装程序（msi）将位于C:\\Path\\To\\Project\\target\\wix文件夹中。 ","date":"2021-06-22","objectID":"/article/2021/cargo-wix/:0:1","tags":["wix","Rust"],"title":"Cargo Wix 创建Windows安装程序的cargo子命令","uri":"/article/2021/cargo-wix/"},{"categories":["Learn Rust"],"content":"官方文档 https://crates.io/crates/cargo-wix ","date":"2021-06-22","objectID":"/article/2021/cargo-wix/:0:2","tags":["wix","Rust"],"title":"Cargo Wix 创建Windows安装程序的cargo子命令","uri":"/article/2021/cargo-wix/"},{"categories":["Using Software"],"content":" 如果你有多显示器设置，你会意识到拥有多个屏幕的好处。而且，有了 Deskreen，你可以把任何设备变成你的副屏。 ","date":"2021-06-21","objectID":"/article/2021/linux_deskreen/:0:0","tags":["linux","deskreen"],"title":"用 Deskreen 将你的 Linux 屏幕镜像或串流到任何设备上","uri":"/article/2021/linux_deskreen/"},{"categories":["Using Software"],"content":"Deskreen：将任何设备变成你的 Linux 系统的副屏 Deskreen 是一个自由开源的应用，可以让你使用任何带有 Web 浏览器的设备来作为电脑的副屏。 如果你愿意，它还支持多个设备连接。 Deskreen 很容易使用，当你的所有设备都连接到同一个 Wi-Fi 网络时，它可以正常工作。 让我们来看看它的功能和工作原理。 Deskreen 的功能 Deskreen 的功能包括以下要点： 分享整个屏幕的能力 选择一个特定的应用窗口进行串流 翻转模式，将你的屏幕作为提词器使用 支持多种设备 高级视频质量设置 提供端对端加密 最小的系统要求 黑暗模式 没有一个冗长的功能列表，但对大多数用户来说应该是足够的。 ","date":"2021-06-21","objectID":"/article/2021/linux_deskreen/:0:1","tags":["linux","deskreen"],"title":"用 Deskreen 将你的 Linux 屏幕镜像或串流到任何设备上","uri":"/article/2021/linux_deskreen/"},{"categories":["Using Software"],"content":"如何使用 Deskreen 应用？ Deskreen 使用分为三个简单的步骤，让我为你强调一下，以便你开始使用： 首先，当你启动该应用时，它会显示一个二维码和一个 IP 地址，以帮助你用 Web 浏览器连接其他设备，以串流你的屏幕。 你可以按你喜欢的方式，在你的辅助设备上的 Web 浏览器的帮助下建立连接。 当你扫描二维码或在浏览器的地址栏中输入 IP 地址，你会在 Deskreen 应用上得到一个提示，允许或拒绝连接。除非是你不认识它，否则就允许吧。 接下来，你将被要求选择你想要串流的内容（你的整个屏幕或特定的应用窗口）： 你可以选择串流整个屏幕或选择你想串流的窗口。然而，并不是每个应用窗口都能被检测到。 你只需要选择源并确认，就可以了。你应该注意到它在你的副屏（手机/桌面）上开始串流。 Deskreen 还为你提供了管理连接设备的能力。因此，如果你需要断开任何会话或所有会话的连接，你可以从设置中进行操作。 ","date":"2021-06-21","objectID":"/article/2021/linux_deskreen/:0:2","tags":["linux","deskreen"],"title":"用 Deskreen 将你的 Linux 屏幕镜像或串流到任何设备上","uri":"/article/2021/linux_deskreen/"},{"categories":["Using Software"],"content":"在 Linux 中安装 Deskreen 你会找到一个用于 Linux 机器的 DEB 包和 AppImage 文件。如果你不知道，可以通过我们的 安装 DEB 包 和 使用 AppImage 文件 指南来安装它。 你可以从 官方网站 下载它，或者从它的 GitHub 页面探索更多的信息。 ","date":"2021-06-21","objectID":"/article/2021/linux_deskreen/:0:3","tags":["linux","deskreen"],"title":"用 Deskreen 将你的 Linux 屏幕镜像或串流到任何设备上","uri":"/article/2021/linux_deskreen/"},{"categories":["Using Software"],"content":"结束语 考虑到它使用 Wi-Fi 网络工作，在串流方面绝对没有问题。这是一种奇妙的方式，可以与别人分享你的屏幕，或者出于任何目的将其串流到第二个设备上。 当然，它不能取代你的电脑的第二个显示器的优势，但在一些使用情况下，你可能不需要第二个屏幕。 ","date":"2021-06-21","objectID":"/article/2021/linux_deskreen/:0:4","tags":["linux","deskreen"],"title":"用 Deskreen 将你的 Linux 屏幕镜像或串流到任何设备上","uri":"/article/2021/linux_deskreen/"},{"categories":["Using Software"],"content":"参考 With Deskreen, You Can Mirror or Stream Your Linux Computer Screen to Any Device [1] 用 Deskreen 将你的 Linux 屏幕镜像或串流到任何设备上 [2] ","date":"2021-06-21","objectID":"/article/2021/linux_deskreen/:0:5","tags":["linux","deskreen"],"title":"用 Deskreen 将你的 Linux 屏幕镜像或串流到任何设备上","uri":"/article/2021/linux_deskreen/"},{"categories":["趣站","千奇百怪"],"content":" 网站为你营造了专注冥想的时间，通过三个简单的小游戏，你可以进入一个精神集中的状态，从而让大脑思维平静下来！ 传送门 https://thezen.zone/ ","date":"2021-06-21","objectID":"/article/2021/the-zen-zone/:0:0","tags":["专注","冥想","小游戏"],"title":"为你营造专注冥想的时间-The Zen Zone","uri":"/article/2021/the-zen-zone/"},{"categories":["趣站","千奇百怪"],"content":"方法 进入网站直接开始冥想吧！ ","date":"2021-06-21","objectID":"/article/2021/the-zen-zone/:0:1","tags":["专注","冥想","小游戏"],"title":"为你营造专注冥想的时间-The Zen Zone","uri":"/article/2021/the-zen-zone/"},{"categories":["趣站","轻松好玩"],"content":"全球范围内的公开实况摄像头，你可以看到世界各地的文化遗产、城市风光、人气景点","date":"2021-06-14","objectID":"/article/2021/skylinewebcams/","tags":["全球","摄像头","风景"],"title":"全球高清实况摄像头-Skylinewebcams","uri":"/article/2021/skylinewebcams/"},{"categories":["趣站","轻松好玩"],"content":" 网站收录了全球范围内的公开实况摄像头，你可以看到世界各地的文化遗产、城市风光、人气景点！ 传送门 https://www.skylinewebcams.com/ ","date":"2021-06-14","objectID":"/article/2021/skylinewebcams/:0:0","tags":["全球","摄像头","风景"],"title":"全球高清实况摄像头-Skylinewebcams","uri":"/article/2021/skylinewebcams/"},{"categories":["趣站","轻松好玩"],"content":"方法 网站支持中文，进入后直接观看！ ","date":"2021-06-14","objectID":"/article/2021/skylinewebcams/:0:1","tags":["全球","摄像头","风景"],"title":"全球高清实况摄像头-Skylinewebcams","uri":"/article/2021/skylinewebcams/"},{"categories":["收集与整理"],"content":"2021-06-12 今日技术分享 Go：内存管理与内存清理 https://mp.weixin.qq.com/s/gTk2UcVCv4a0xuP44oqZhg Go看源码必会知识之unsafe包 https://mp.weixin.qq.com/s/dulgHWM-mjrYIdD9nHZyYg 漫画：寻找无序数组的第k大元素（文末送书） https://mp.weixin.qq.com/s/ycZ8Lh1mjzlrfZoN8lRvEQ 《Istio 大咖说》第3期直播回放|如何让 Istio 变得更为高效和智能 https://mp.weixin.qq.com/s/k3tj6n6lcWfAbu_8k9l5eg 或许这是目前为止最好的 Git 教程了 https://mp.weixin.qq.com/s/MsAO29B05AizHHuOQe_p3g 曹大带我学 Go（6）—— 技术之外 https://mp.weixin.qq.com/s/OHljMca3k7m__puOUCrrtA 全网最牛X的！MySQL两阶段提交串讲！没有之一！ https://mp.weixin.qq.com/s/NNRH4TQcCQr4aQw7Cm6zLg gRPC入门指南 — 简单RPC（一） https://mp.weixin.qq.com/s/GnDKAx9bLe90h0rvCQYb6g 面试题：mysql 一棵 B+ 树能存多少条数据？ https://mp.weixin.qq.com/s/ItFtW9OLt-x-J--IVzvJ_A TCP 连接的前世今生 https://mp.weixin.qq.com/s/f3rDqiDe4isTIBx-RPPN4g 分享两个在开发中需注意的小点 https://mp.weixin.qq.com/s/-QCG61vh6NVJUWz6tOY7Gw 一文教你搞懂 Go 中栈操作 https://mp.weixin.qq.com/s/hU6Xmp5zeh9vgUEV5otjWg kubernetes面试相关总结(下) https://mp.weixin.qq.com/s/Tc292lVE1Lue267N5RdunA Go Runtime 的调度器 https://mp.weixin.qq.com/s/hU6Xmp5zeh9vgUEV5otjWg 一文讲懂服务的优雅重启和更新 https://mp.weixin.qq.com/s/yryqf8SCzvt-BFj8j5bZ2w 你不知道的 Go 之 pprof https://mp.weixin.qq.com/s/pSD2k1uNH9WFZumw24I4uQ 源码剖析 Go 语言的 timer https://mp.weixin.qq.com/s/GwY6650MNF07MOb79-A-jQ 一文教你搞懂 Go 中栈操作 https://mp.weixin.qq.com/s/hU6Xmp5zeh9vgUEV5otjWg 将一个巨大的金融系统迁移到云端的20,000个pod上 https://medium.com/virtuslab/migrating-a-gigantic-financial-system-to-20-000-pods-in-the-cloud-220d5fcfcbc0 如何使用go 1.16中的go:embed by The GoLand Blog https://blog.jetbrains.com/go/2021/06/09/how-to-use-go-embed-in-go-1-16/ 什么是eBPF，为什么它对可观察性很重要？ https://www.cncf.io/blog/2021/06/07/what-is-ebpf-and-why-does-it-matter-for-observability/ 如何用Github Actions自动发布你的Go二进制文件 https://web3.coach/golang-github-actions-release-binaries-tutorial 基于OAuth 2.0/OIDC的UI优先的集中认证/单点登录（SSO）平台 https://github.com/casbin/casdoor 用Trimaran在Kubernetes中进行真正的负载感知调度 https://medium.com/paypal-tech/real-load-aware-scheduling-in-kubernetes-with-trimaran-a8efe14d51e2 Hashicorp发布Packer云服务 https://www.hashicorp.com/blog/announcing-hcp-packer bramble: 生产可用的GraphQL网关 https://github.com/movio/bramble Redis 作者谈如何处理维护开源项目面对的精神压力 https://news.ycombinator.com/item?id=27423526 用Terraform在Linode上配置Kubernetes集群 https://learnk8s.io/terraform-lke 你使用的开源软件比你想象的要多 https://github.com/readme/unseen-oss go 栈操作 https://mp.weixin.qq.com/s/hU6Xmp5zeh9vgUEV5otjWg go pprof https://mp.weixin.qq.com/s/pSD2k1uNH9WFZumw24I4uQ 索引下推 https://mp.weixin.qq.com/s/i2CWsDi8pqISGbwdn9Wm3g ","date":"2021-06-12","objectID":"/article/2021/go20210612/:0:0","tags":["技术分享","Golang"],"title":"Go20210612 今日技术分享","uri":"/article/2021/go20210612/"},{"categories":["收集与整理"],"content":"2021-06-09 今日技术分享 字节跳动打造的轮子：Go 表单验证器 https://mp.weixin.qq.com/s/Oc90iCYyZGj5uDKhj8eGWw 16 中的新函数 signal.NotifyContext 怎么用？ https://mp.weixin.qq.com/s/LLKgeGmhU_GpQQeivEvi1g Go 每日一库之 reflect https://mp.weixin.qq.com/s/3kE_M9jKTG14t3KIlkqhgA 一个高逼格的 Go 招聘 https://mp.weixin.qq.com/s/lFrmy68XTF79kO3iCD9l6A 云原生 CI/CD 框架 Tekton 初体验 https://mp.weixin.qq.com/s/ZI9vWJ4giVsMhxZYHjjd5A Go 简单分布式系统 3.4 服务发现（2） https://mp.weixin.qq.com/s/dLtyKjJ5_p0aiyx9BMGEYg Go 简单分布式系统 3.5 服务发现（3） https://mp.weixin.qq.com/s/SQbOS1xRECM2Oa-tXjEkfw Go 每日一库之 ants（源码赏析） https://mp.weixin.qq.com/s/a84T6Hpbrhop7vQA01N1Bg 2021 中国 Go 语言开源贡献者峰会预告 https://mp.weixin.qq.com/s/-FWxWGVJEVe8JPPcGqHxgw Go timer 是如何被调度的？ https://mp.weixin.qq.com/s/iseiQ20eIUR9i02fy1tFhg 2.5年写成的Go免费在线图书 https://mp.weixin.qq.com/s/Z97eT7FrqeJhygQwKvJaIw 一文带你深究无线缓冲channel的实现 https://mp.weixin.qq.com/s/7P3Gn7JFvMWUh0iuNExPKA 东南亚最大的外卖出行公司招聘，这福利，酸了，酸了 https://mp.weixin.qq.com/s/wynt1zdgsRJywFva_gE5dA 在 Golang 中创建自定义应用程序 logger https://jilsonfreddy.medium.com/create-a-custom-application-logger-in-golang-cdd11ba106d5 在 Go 1.16+ 中构建 GUI 桌面应用程序 https://blog.ctrlshiftmake.com/build-tray-gui-desktop-application-go Go 实现为以太坊智能合约创建绑定 https://www.metachris.com/2021/05/creating-go-bindings-for-ethereum-smart-contracts/ Go 中简单、可定制、分级且高效的日志记录 https://github.com/ermanimer/log Go 实现的发送原始 HTTP 请求的基准测试和压力测试工具 https://github.com/utkusen/reqstress 2021 中国 Go 语言开源贡献者峰会预告 https://mp.weixin.qq.com/s/-FWxWGVJEVe8JPPcGqHxgw 使用Go和cube.js构建你自己的网站分析工具 https://itnext.io/build-your-own-website-analytics-with-cube-js-in-10-minutes-f195ed5d4d21 使用Go 1.16构建桌面GUI应用 https://blog.ctrlshiftmake.com/build-tray-gui-desktop-application-go 最后测试(TLD)简介(Test-Last Development) https://bitfieldconsulting.com/golang/test-last-development 2021年及以后的DevOps预测 https://harness.io/blog/devops/devops-predictions/ Docker安全实践速查表 https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html 提高开发人员的工作效率：BuildKit CLI for kubectl是docker build的替代品 https://container-registry.com/posts/productivity-lift-buildkit-cli-for-kubectl/ 理解defer关键字 https://syed-hasan-83344.medium.com/understanding-defer-keyword-in-go-lang-b02c7f406870 开源项目维护不易，docz维护者的心路历程 https://github.com/pedronauck/docz/issues/1634 ","date":"2021-06-09","objectID":"/article/2021/go20210609/:0:0","tags":["技术分享","Golang"],"title":"Go20210609 今日技术分享","uri":"/article/2021/go20210609/"},{"categories":["收集与整理"],"content":"2021-06-08 今日技术分享 Go 调度器的任务窃取（Work-Stealing） https://mp.weixin.qq.com/s/trBAi976eaaTDcSzpAqPkQ 通过实例理解Go逃逸分析 https://mp.weixin.qq.com/s/bR9shJGRXsRHJhh-GcY83A Go 凭什么不支持三元运算符？ https://mp.weixin.qq.com/s/LmHR7Y674dSo-Xa0tajL_w 一文搞懂如何实现 Go 超时控制 https://mp.weixin.qq.com/s/S4d9CJYmViJT8EbhyNCIMg 神奇的init函数 https://mp.weixin.qq.com/s/y-H0y1ahq8a_TgJ4c4otuQ 3 服务发现（1） https://mp.weixin.qq.com/s/QoDwEbl02nSHjRci8yRbyQ ​手把手教你如何进行 Golang 单元测试 https://mp.weixin.qq.com/s/N5wby-aWWEPc7mHN_lN3lQ 主干开发、主干发布，CI 如何为大型项目提供最优解？ https://mp.weixin.qq.com/s/mQihX1VbEEArHpcx6s5KFQ 自制文件系统 —— 03 Go实战：hello world 的文件系统 https://mp.weixin.qq.com/s/Yf6yBoEQe6ijMlPgZ6P2sA 曹大带我学 Go（5）—— 哪里来的 goexit https://mp.weixin.qq.com/s/xrDZ2Z7KkHL0vZ3k6KGcyg Code Review 引发的 Golang Memory Model 深入思考 https://juejin.cn/post/6970513766509182984 监控是手段，而不是目的 https://www.robustperception.io/monitoring-is-a-means-not-an-end Calico 路由反射模式权威指南 https://mp.weixin.qq.com/s/hLiI9fsPQ7w4PS2ALff09g 从栈上理解 Go 语言函数调用 https://www.cnblogs.com/luozhiyun/p/14844710.html Go context包的上下文 https://asheetbhaskar.medium.com/context-about-context-package-in-golang-487ef60d9acc 为什么服务跟踪将替代所有日志手段 https://go.lightstep.com/rs/260-KGM-472/images/Tracing-Will-Replace-Logging-Guide.pdf 内部服务的go单点登录方案 https://github.com/buzzfeed/sso 在Go中创建自定义logger https://jilsonfreddy.medium.com/create-a-custom-application-logger-in-golang-cdd11ba106d5 惊！这个 Go 开源项目号称「不改一行代码做秒杀」 https://mp.weixin.qq.com/s/NSJmV-hBucaXoBAfD3TKLA 一文讲懂服务的优雅重启和更新 https://mp.weixin.qq.com/s/yryqf8SCzvt-BFj8j5bZ2w 视频教程：Go初学者教程 https://tutorialedge.net/courses/go-beginners-guide/ kubestr: 一个工具集合，用于发现、验证和评估你的kubernetes存储选项 https://kubestr.io/ 除了编码之外，高级工程师所需技能的不完整清单 https://skamille.medium.com/an-incomplete-list-of-skills-senior-engineers-need-beyond-coding-8ed4a521b29f 主流分布式文件系统对比 https://mp.weixin.qq.com/s/XgCjWKtqc2Mi_cqRj9_2xw 互斥锁，自旋锁，悲观锁，乐观锁总结 https://blog.csdn.net/qq_34827674/article/details/108608566 高并发服务遇 redis 瓶颈引发的事故 https://mp.weixin.qq.com/s/MtdU1xhOI5XkuSDrIYFRMA redis实现自动输入完成 https://www.cnblogs.com/like-minded/p/5239444.html ","date":"2021-06-08","objectID":"/article/2021/go20210608/:0:0","tags":["技术分享","Golang"],"title":"Go20210608 今日技术分享","uri":"/article/2021/go20210608/"},{"categories":["收集与整理"],"content":"2021-06-05 今日技术分享 Go: stringer 命令，通过代码生成提高效率 https://mp.weixin.qq.com/s/Ik3PxNRbddtbm6E-Xo_rdA 详解并发编程基础之原子操作(atomic包) https://mp.weixin.qq.com/s/-KE6jNKkVxNrm-e3laibzw 函数的不定参数你是这样用吗？ https://mp.weixin.qq.com/s/jvSbZ0_g_EFqaR2TmjjO8w 如何不 Review 每一行代码，同时保持代码不被写乱？ https://mp.weixin.qq.com/s/UtBkJYpQHIvRQ_AQnzxxMw 假如 Go 能说话，听听 GMP 的心声 https://mp.weixin.qq.com/s/eHXAPQkzwMTaLVrXESowBg 直播回放 | Istio 大咖说第 2 期：从微服务架构到 Istio—— 架构升级实践分享 https://mp.weixin.qq.com/s/huZaJVK5qXVrQFfDlha5zQ 惊！这个 Go 开源项目号称「不改一行代码做秒杀」 https://mp.weixin.qq.com/s/NSJmV-hBucaXoBAfD3TKLA 超全代码！详解Go中内存分配源码实现 https://mp.weixin.qq.com/s/_SYT7zWqvFnfH02cHFOgow 十个问题理解Linux epoll工作原理 https://mp.weixin.qq.com/s/h3CBZt2KEA-ScXFSKHaRBg Pointer https://mp.weixin.qq.com/s/8qtHdw2JiRQ1cXlzbJ0ANA 基于 cdp 协议开发的浏览器自动化工具 rod https://go-rod.github.io/i18n/zh-CN/#/get-started/README Go 重构和转换工具 https://github.com/uber-go/gopatch#gopatch 开发小应用的 jetbrains 插件 tinygo https://blog.jetbrains.com/go/2021/06/02/tinygo-for-tiny-applications-discover-a-new-plugin-for-goland/ 使用 httputil 反向代理工具将 grpc rest \u0026 html 绑定到一个端口上 https://medium.com/james-reads-public-cloud-technology-blog/using-a-httputil-reverse-proxy-to-host-grpc-rest-html-on-a-single-port-9d3f629762b7 Pre-commit-golang 支持 revive 了 https://github.com/TekWizely/pre-commit-golang/releases/tag/v0.8.3 Go应用lint指南 https://freshman.tech/linting-golang/ 用eBPF编写的简单跨语言（Go、Rust、C/C++）连续性能剖析器 https://blog.px.dev/cpu-profiling-2/ Go学习资源 https://kush01.hashnode.dev/resources-for-learning-go 探索goland上的tinygo插件 https://blog.jetbrains.com/go/2021/06/02/tinygo-for-tiny-applications-discover-a-new-plugin-for-goland/ gopatch：又一款go重构工具 https://github.com/uber-go/gopatch 使用httputil反向代理在单一端口托管gRPC REST和HTML https://medium.com/james-reads-public-cloud-technology-blog/using-a-httputil-reverse-proxy-to-host-grpc-rest-html-on-a-single-port-9d3f629762b7 基于IPv6的无状态k8s overlay网络 https://john-millikin.com/stateless-kubernetes-overlay-networks-with-ipv6 netz: 发现互联网组件服务的配置错误 https://github.com/SpectralOps/netz 在github上搭建私有helm仓库 https://jasiek-petryk.medium.com/setting-up-a-private-helm-chart-repository-on-github-4a767703cec8 揭秘有状态服务上 Kubernetes 的核心技术 https://mp.weixin.qq.com/s/TvZZVow5H9HwMrNBLLoSsQ 开放原子开源基金会项目毕业标准V1.0发布 https://mp.weixin.qq.com/s/CTetamKpZFcQdXBtQbqBPw mvcc https://blog.csdn.net/filling_l/article/details/112854716 行格式和行溢出 https://www.yuque.com/u2278269/gq5x74/pzkge7 白话GPM https://mp.weixin.qq.com/s/eHXAPQkzwMTaLVrXESowBg ","date":"2021-06-05","objectID":"/article/2021/go20210605/:0:0","tags":["技术分享","Golang"],"title":"Go20210605 今日技术分享","uri":"/article/2021/go20210605/"},{"categories":["Using Software","Shell","Linux"],"content":"Linux 常用命令 ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:0","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"日期 $(date -d '1 day ago' '+%Y-%m-%d') 常用方法 ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:1","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"数字格式化 part=`printf \"%03d\" $i` # 左补0 ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:2","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"删除旧文件 # 找出5天前修改的文件名以.tar结尾的文件进行删除 find /www/backup -mtime +5 -name \"*.tar\" |xargs rm ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:3","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"for循环 for ((i=0;i\u003c10;i++)) do _date=$(date +%Y-%m-%d -d \"${i}day\") echo $_date done # for i in {1..10} do echo $i done ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:4","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"文件合并 find ./ -name \"item*\" | xargs sed 'a\\' \u003e all.txt find ./ -name \"item*\" | xargs cat \u003e all.txt :s/old/new #替换当前行的第一个old为new :s/old/new/g #替换当前行的所有的old为new :.,$s/old/new #替换当前行到最后行的第一个old为new :.,$s/old/new/g #替换当前行到最后行的所有old为new :N,Ms/old/new #替换第N行到第M行的第一个old为new :N,Ms/old/new/g #替换第N行到第M行的所有old为new :N,Ms/old/new/gc #替换第N行到第M行的所有old为new，且逐一询问是否删除 :%s/old/new #替换所有行的第一个old为new :%s/old/new/g #替换所有行的所有old为new ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:5","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"文件排序、交集、并集、差集 #排序 sort a.txt |uniq -c #一、交集 sort a.txt b.txt | uniq -d #二、并集 sort a.txt b.txt | uniq #三、差集 a.txt-b.txt: sort a.txt b.txt b.txt | uniq -u #差集 b.txt - a.txt: sort b.txt a.txt a.txt | uniq -u ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:6","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"删除重复行 sort -k2n all.txt | uniq \u003e real.out sort -k2n all.txt | awk '{if ($0!=line) print;line=$0}' sort -k2n all.txt | sed '$!N; /^\\(.*\\)\\n\\1$/!P; D' ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:7","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"删除空格 cat all.txt |sed s/[[:space:]]//g ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:8","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"awk 去重 awk '!($1 in a){a[$1];print $1}' #或 sort $1 | uniq # awk结果使用逗号间隔拼接 awk -F ',' '{print $1}' | xargs | tr ' ' ',' ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:9","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"常用状态查看 # 按CPU和内存倒序前n个进程 ps -aux --sort -pcpu,+pmem | head -n 5 # 按进程名查看 ps -f -C java ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:10","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"文件同步rsync rsync -zvrtopgl --progress --delete /fromDist/ root@s1:/toDist/ ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:11","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"链接状态统计 netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' # TCP连接状态详解 # LISTEN: 服务器在侦听来自远方的TCP端口的连接请求 # SYN-SENT: 在发送连接请求后等待匹配的连接请求 # SYN_RECV: 一个连接请求已经到达，等待确认 # SYN-RECEIVED: 再收到和发送一个连接请求后等待对方对连接请求的确认 # ESTABLISHED: 代表一个打开的连接/正常数据传输状态/当前并发连接数 # FIN_WAIT1: 等待远程TCP连接中断请求，或先前的连接中断请求的确认/应用说它已经完成 # FIN_WAIT2: 从远程TCP等待连接中断请求/另一边已同意释放 # CLOSE-WAIT: 等待从本地用户发来的连接中断请求 # CLOSING: 等待远程TCP对连接中断的确认/两边同时尝试关闭 # LAST-ACK: 等待原来的发向远程TCP的连接中断请求的确认/等待所有分组死掉 # TIME-WAIT: 等待足够的时间以确保远程TCP接收到连接中断请求的确认/另一边已初始化一个释放 # ITMED_WAIT: 等待所有分组死掉 # CLOSED： 没有任何连接状态 ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:12","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"CPU/内存/系统信息查看 # cpu grep \"model name\" /proc/cpuinfo cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c cat /proc/cpuinfo | grep physical | uniq -c # cpu位数 echo $HOSTTYPE # 内存 grep MemTotal /proc/meminfo # linux 版本 cat /etc/redhat-release cat /etc/os-release cat /etc/lsb-release # linux 内核版本 uname -a uname -r ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:13","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"常用监控工具 # 网络监控 iftop # IO监控 iotop # 负载监控 htop top ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:14","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"进程监控 pidstat -p 843 1 3 -u -t # -u：代表对 CPU 使用率的监控 # 参数 1 3 代表每秒采样一次，一共三次 # -t：将监控级别细化到线程 ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:15","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"ssh相关 # 秘钥生成 ssh-keygen -t rsa -b 4096 -C \"your_hostname\" # 免密登录 cat ~/.ssh/id_rsa.pub | ssh root@ip \"cat \u003e\u003e .ssh/authorized_keys\" ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:16","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"firewalld防火墙使用 # 禁止ping firewall-cmd --permanent --add-rich-rule='rule protocol value=icmp drop' # 允许192.168.1.0/24主机所有连接 firewall-cmd --add-rich-rule='rule family=\"ipv4\" source address=\"192.168.1.0\" accept' # 禁止某IP访问 firewall-cmd --permanent --zone=public --add-rich-rule=\"rule family=ipv4 source address='123.56.247.76/24' reject\" # 开放端口 firewall-cmd --zone=public --permanent --add-port=8080/tcp firewall-cmd --reload ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:17","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"文件统计 ls -g |awk 'BEGIN{sum=0}{sum+=$4}END{print sum/(1024*1024*1024)}' ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:18","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Linux"],"content":"history格式及数量修改 export HISTSIZE=10000 export HISTTIMEFORMAT=\" %Y-%m-%d %H:%M:%S - `who am i 2\u003e/dev/null | awk '{print $NF}'|sed -e 's/[()]//g'` - `who -u am i |awk '{print $1}'` \" export PROMPT_COMMAND=\"history 1 \u003e\u003e /var/log/.myhistory\" #将命令记录输出到文本中 touch /var/log/.myhistory chmod /var/log/.myhistory ","date":"2021-06-05","objectID":"/article/2021/linux_cmd/:0:19","tags":["Shell脚本","linux"],"title":"Linux 常用命令","uri":"/article/2021/linux_cmd/"},{"categories":["Using Software","Shell","Nginx"],"content":"awk 分析 nginx 运行日志常用指令","date":"2021-06-05","objectID":"/article/2021/awk-nginx-access_log/","tags":["Shell脚本","awk"],"title":"awk 分析 nginx 运行日志常用指令","uri":"/article/2021/awk-nginx-access_log/"},{"categories":["Using Software","Shell","Nginx"],"content":"awk 分析 nginx 运行日志常用指令 1.独立IP awk '{print $1}' access.log | sort -r |uniq -c | wc -l 2.统计PV awk '{print $6}' access.log | wc -l 3.查询访问最频繁的URL awk '{print $7}' access.log|sort | uniq -c |sort -n -k 1 -r|more 4.查询访问最频繁的IP awk '{print $1}' access.log|sort | uniq -c |sort -n -k 1 -r|more 5.UV统计： awk '{print $6}' access.log | sort -r |uniq -c |wc -l 6.按小时统计 cat access.log |awk '{print $4}' | awk -F ':' '{print $1,$2}'|uniq -c | awk '{print $2\" \"$3\" \"$1}' ","date":"2021-06-05","objectID":"/article/2021/awk-nginx-access_log/:0:0","tags":["Shell脚本","awk"],"title":"awk 分析 nginx 运行日志常用指令","uri":"/article/2021/awk-nginx-access_log/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"👉 TOML 语言广泛用于 Rust 项目当中，cargo new 一个新项目时都会新建一个 toml 的配置文件，所以学习 Rust 过程中也有必要熟悉 TOML 语言的相关语法，从而熟练在 Rust 项目中编辑配置文件。 👉 本文来自 toml-lang 的中文翻译版本，本文收录在此处，只是方便 Rust 学习者统一查阅，若是发现有任何错误或需要完善地方，请在 toml.io 原项目仓库指出或修改错误。 TOML v1.0.0 全称：Tom 的（语义）明显、（配置）最小化的语言。（Tom’s Obvious, Minimal Language） 作者：Tom Preston-Werner、Pradyun Gedam 等人。 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:0","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"宗旨 TOML 旨在成为一个语义明显且易于阅读的最小化配置文件格式。 TOML 被设计成可以无歧义地映射为哈希表。 TOML 应该能很容易地被解析成各种语言中的数据结构。 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:1","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"目录 规格 注释 键值对 键名 字符串 整数 浮点数 布尔值 坐标日期时刻 各地日期时刻 各地日期 各地时刻 数组 表 内联表 表数组 文件扩展名 MIME 类型 ABNF 语法 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:2","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"规格 TOML 是大小写敏感的。 TOML 文件必须是合法的 UTF-8 编码的 Unicode 文档。 空白是指制表符（0x09）或空格（0x20）。 换行是指 LF（0x0A）或 CRLF（0x0D0A）。 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:3","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"注释 井字符将该行余下的部分标记为注释，除非它在字符串中。 # 这是一个全行注释 key = \"value\" # 这是一个行末注释 another = \"# 这不是一个注释\" 除制表符以外的控制字符（U+0000 至 U+0008，U+000A 至 U+001F，U+007F）不允许出现在注释中。 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:4","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"键值对 TOML 文档最基本的构成区块是键值对。 键名在等号的左边而值在右边。 键名和键值周围的空白会被忽略。 键、等号和值必须在同一行（不过有些值可以跨多行）。 key = \"value\" 值必须是下述类型之一。 字符串 整数 浮点数 布尔值 坐标日期时刻 各地日期时刻 各地日期 各地时刻 数组 内联表 不指定值是非法的。 key = # 非法 键值对后必须换行（或结束文件）。 （例外见内联表） first = \"Tom\" last = \"Preston-Werner\" # 非法 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:5","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"键名 键名可以是裸露的，引号引起来的，或点分隔的。 裸键只能包含 ASCII 字母，ASCII 数字，下划线和短横线（A-Za-z0-9_-）。 注意裸键允许仅由纯 ASCII 数字构成，例如 1234，但是是被理解为字符串的。 key = \"value\" bare_key = \"value\" bare-key = \"value\" 1234 = \"value\" 引号键遵循与基本字符串或字面量字符串相同的规则并允许你使用更为广泛的键名。 除非明显必要，使用裸键方为最佳实践。 \"127.0.0.1\" = \"value\" \"character encoding\" = \"value\" \"ʎǝʞ\" = \"value\" 'key2' = \"value\" 'quoted \"value\"' = \"value\" 裸键中不能为空，但空引号键是允许的（虽然不建议如此）。 = \"no key name\" # 非法 \"\" = \"blank\" # 合法但不鼓励 '' = 'blank' # 合法但不鼓励 点分隔键是一系列通过点相连的裸键或引号键。 这允许了你将相近属性放在一起： name = \"Orange\" physical.color = \"orange\" physical.shape = \"round\" site.\"google.com\" = true 等价于 JSON 的如下结构： { \"name\": \"Orange\", \"physical\": { \"color\": \"orange\", \"shape\": \"round\" }, \"site\": { \"google.com\": true } } 有关点分隔键定义表的详细信息，请参阅后文表一节。 点分隔符周围的空白会被忽略。 不过，最佳实践是不要使用任何不必要的空白。 fruit.name = \"banana\" # 这是最佳实践 fruit. color = \"yellow\" # 等同于 fruit.color fruit . flavor = \"banana\" # 等同于 fruit.flavor 缩进被作为空白对待而被忽略。 多次定义同一个键是非法的。 # 不要这样做 name = \"Tom\" name = \"Pradyun\" 注意裸键和引号键是等价的： # 这是不可行的 spelling = \"favorite\" \"spelling\" = \"favourite\" 只要一个键还没有被直接定义过，你就仍可以对它和它下属的键名赋值。 # 这使“fruit”键作为表存在。 fruit.apple.smooth = true # 所以接下来你可以像中这样对“fruit”表添加内容： fruit.orange = 2 # 以下是非法的 # 这将 fruit.apple 的值定义为一个整数。 fruit.apple = 1 # 但接下来这将 fruit.apple 像表一样对待了。 # 整数不能变成表。 fruit.apple.smooth = true 不鼓励跳跃式地定义点分隔键。 # 合法但不鼓励 apple.type = \"水果\" orange.type = \"水果\" apple.skin = \"薄\" orange.skin = \"厚\" apple.color = \"红\" orange.color = \"橙\" # 建议 apple.type = \"水果\" apple.skin = \"薄\" apple.color = \"红\" orange.type = \"水果\" orange.skin = \"厚\" orange.color = \"红\" 由于裸键可以仅由 ASCII 整数组成，所以可能写出看起来像浮点数、但实际上是两部分的点分隔键。 除非你有充分的理由（基本不太会），否则不要这样做。 3.14159 = \"派\" 上面的 TOML 对应以下 JSON。 { \"3\": { \"14159\": \"派\" } } ","date":"2021-06-05","objectID":"/article/2021/toml/:0:6","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"字符串 共有四种方式来表示字符串：基本字符串、多行基本字符串、字面量和多行字面量。 所有字符串都只能包含有效的 UTF-8 字符。 基本字符串由引号（\"）包裹。 任何 Unicode 字符都可以使用，除了那些必须转义的：引号，反斜杠，以及除制表符外的控制字符（U+0000 至 U+0008，U+000A 至 U+001F，U+007F）。 str = \"我是一个字符串。\\\"你可以把我引起来\\\"。姓名\\tJos\\u00E9\\n位置\\t旧金山。\" 为了方便，一些流行的字符有其简便转义写法。 \\b - backspace (U+0008) \\t - tab (U+0009) \\n - linefeed (U+000A) \\f - form feed (U+000C) \\r - carriage return (U+000D) \\\" - quote (U+0022) \\\\ - backslash (U+005C) \\uXXXX - unicode (U+XXXX) \\UXXXXXXXX - unicode (U+XXXXXXXX) 任何 Unicode 字符都可以用 \\uXXXX 或 \\UXXXXXXXX 的形式来转义。 转义码必须是有效的 Unicode 标量值。 所有上面未列出的其它转义序列都是保留的；如果用了，TOML 应当产生错误。 有时你需要表示一小篇文本（例如译文）或者想要对非常长的字符串进行折行。 TOML 对此进行了简化。 多行基本字符串由三个引号包裹，允许折行。 紧随开头引号的那个换行会被去除。 其它空白和换行会被原样保留。 str1 = \"\"\" Roses are red Violets are blue\"\"\" TOML 解析器可以相对灵活地解析成对所在平台有效的换行字符。 # 在 Unix 系统，上面的多行字符串可能等同于： str2 = \"Roses are red\\nViolets are blue\" # 在 Windows 系统，它可能等价于： str3 = \"Roses are red\\r\\nViolets are blue\" 想书写长字符串却不想引入无关空白，可以用“行末反斜杠”。 当一行的最后一个非空白字符是未被转义的 \\ 时，它会连同它后面的所有空白（包括换行）一起被去除，直到下一个非空白字符或结束引号为止。 所有对基本字符串有效的转义序列，对多行基本字符串也同样适用。 # 下列字符串的每一个字节都完全相同： str1 = \"The quick brown fox jumps over the lazy dog.\" str2 = \"\"\" The quick brown \\ fox jumps over \\ the lazy dog.\"\"\" str3 = \"\"\"\\ The quick brown \\ fox jumps over \\ the lazy dog.\\ \"\"\" 任何 Unicode 字符都可以使用，除了那些必须被转义的：反斜杠和除制表符、换行符、回车符外的控制字符（U+0000 至 U+0008，U+000B，U+000C，U+000E 至 U+001F，U+007F）。 你可以在多行基本字符串内的任何地方写一个引号或两个毗连的引号。 它们也可以写在紧邻界分符内的位置。 str4 = \"\"\"这有两个引号：\"\"。够简单。\"\"\" # str5 = \"\"\"这有两个引号：\"\"\"。\"\"\" # 非法 str5 = \"\"\"这有三个引号：\"\"\\\"。\"\"\" str6 = \"\"\"这有十五个引号：\"\"\\\"\"\"\\\"\"\"\\\"\"\"\\\"\"\"\\\"。\"\"\" # \"这，\"她说，\"只是个无意义的条款。\" str7 = \"\"\"\"这，\"她说，\"只是个无意义的条款。\"\"\"\" 如果你常常要指定 Windows 路径或正则表达式，那么必须转义反斜杠就马上成为啰嗦而易错的了。 为了帮助搞定这点，TOML 支持字面量字符串，它完全不允许转义。 字面量字符串由单引号包裹。 类似于基本字符串，他们只能表现为单行： # 所见即所得。 winpath = 'C:\\Users\\nodejs\\templates' winpath2 = '\\\\ServerX\\admin$\\system32\\' quoted = 'Tom \"Dubs\" Preston-Werner' regex = '\u003c\\i\\c*\\s*\u003e' 由于没有转义，无法在由单引号包裹的字面量字符串中写入单引号。 万幸，TOML 支持一种多行版本的字面量字符串来解决这个问题。 多行字面量字符串两侧各有三个单引号来包裹，允许换行。 类似于字面量字符串，无论任何转义都不存在。 紧随开始标记的那个换行会被剔除。 开始结束标记之间的所有其它内容会原样对待。 regex2 = '''I [dw]on't need \\d{2} apples''' lines = ''' 原始字符串中的 第一个换行被剔除了。 所有其它空白 都保留了。 ''' 你可以在多行字面量字符串中的任何位置写一个或两个单引号，但三个以上的单引号序列不可以。 quot15 = '''这有十五个引号：\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"''' # apos15 = '''这有十五个撇号：'''''''''''''''''' # 非法 apos15 = \"这有十五个撇号：'''''''''''''''\" # '那，'她说，'仍然没有意义。' str = ''''那，'她说，'仍然没有意义。'''' 除制表符以外的所有控制字符都不允许出现在字面量字符串中。 因此，对于二进制数据，建议你使用 Base64 或其它合适的 ASCII 或 UTF-8 编码。 对那些编码的处理方式，将交由应用程序自己来确定。 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:7","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"整数 整数是纯数字。 正数可以有加号前缀。 负数的前缀是减号。 int1 = +99 int2 = 42 int3 = 0 int4 = -17 对于大数，你可以在数字之间用下划线来增强可读性。 每个下划线两侧必须至少有一个数字。 int5 = 1_000 int6 = 5_349_221 int7 = 53_49_221 # 印度记数体系分组 int8 = 1_2_3_4_5 # 合法但不鼓励 前导零是不允许的。 整数值 -0 与 +0 是有效的，并等同于无前缀的零。 非负整数值也可以用十六进制、八进制或二进制来表示。 在这些格式中，+ 不被允许，而（前缀后的）前导零是允许的。 十六进制值大小写不敏感。 数字间的下划线是允许的（但不能存在于前缀和值之间）。 # 带有 `0x` 前缀的十六进制 hex1 = 0xDEADBEEF hex2 = 0xdeadbeef hex3 = 0xdead_beef # 带有 `0o` 前缀的八进制 oct1 = 0o01234567 oct2 = 0o755 # 对于表示 Unix 文件权限很有用 # 带有 `0b` 前缀的二进制 bin1 = 0b11010110 任何 64 位有符号整数（从 −2^63 到 2^63−1）都应当被接受并无损处理。 如果无法无损表现某个整数，则必须抛出错误。 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:8","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"浮点数 浮点数应当被实现为 IEEE 754 binary64 值。 一个浮点数由一个整数部分（遵从与十进制整数值相同的规则）后跟上一个小数部分和/或一个指数部分组成。 如果小数部分和指数部分兼有，那小数部分必须在指数部分前面。 # 小数 flt1 = +1.0 flt2 = 3.1415 flt3 = -0.01 # 指数 flt4 = 5e+22 flt5 = 1e06 flt6 = -2E-2 # 都有 flt7 = 6.626e-34 小数部分是一个小数点后跟一个或多个数字。 一个指数部分是一个 E（大小写均可）后跟一个整数部分（遵从与十进制整数值相同的规则，但可以包含前导零）。 小数点，如果有用到的话，每侧必须紧邻至少一个数字。 # 非法的浮点数 invalid_float_1 = .7 invalid_float_2 = 7. invalid_float_3 = 3.e+20 与整数相似，你可以使用下划线来增强可读性。 每个下划线必须被至少一个数字围绕。 flt8 = 224_617.445_991_228 浮点数值 -0.0 与 +0.0 是有效的，并且应当遵从 IEEE 754。 特殊浮点值也能够表示。 它们是小写的。 # 无穷 sf1 = inf # 正无穷 sf2 = +inf # 正无穷 sf3 = -inf # 负无穷 # 非数 sf4 = nan # 实际上对应信号非数码还是静默非数码，取决于实现 sf5 = +nan # 等同于 `nan` sf6 = -nan # 有效，实际码取决于实现 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:9","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"布尔值 布尔值就是你所惯用的那样。 要小写。 bool1 = true bool2 = false ","date":"2021-06-05","objectID":"/article/2021/toml/:0:10","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"坐标日期时刻 要准确地表示世上的一个特定时间，你可以使用指定了时区偏移量的 RFC 3339 格式的日期时刻。 odt1 = 1979-05-27T07:32:00Z odt2 = 1979-05-27T00:32:00-07:00 odt3 = 1979-05-27T00:32:00.999999-07:00 出于可读性的目的，你可以用一个空格字符替代日期和时刻之间的 T（RFC 3339 的第 5.6 节中允许了这样做）。 odt4 = 1979-05-27 07:32:00Z 毫秒级的精度是必须的。 更高精度的小数秒取决于实现。 如果它的值超出了实现所支持的精度，那超出的部分必须被舍弃，而不能四舍五入。 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:11","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"各地日期时刻 如果你省略了 RFC 3339 日期时刻中的时区偏移量，这表示该日期时刻的使用并不涉及时区偏移。 在没有其它信息的情况下，并不知道它究竟该被转化成世上的哪一刻。 如果仍被要求转化，那结果将取决于实现。 ldt1 = 1979-05-27T07:32:00 ldt2 = 1979-05-27T00:32:00.999999 毫秒级的精度是必须的。 更高精度的小数秒取决于实现。 如果它的值超出了实现所支持的精度，那多余的部分必须被舍弃，而不能四舍五入。 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:12","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"各地日期 如果你只写了 RFC 3339 日期时刻中的日期部分，那它表示一整天，同时也不涉及时区偏移。 ld1 = 1979-05-27 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:13","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"各地时刻 如果你只写了 RFC 3339 日期时刻中的时刻部分，它将只表示一天之中的那个时刻，而与任何特定的日期无关、亦不涉及时区偏移。 lt1 = 07:32:00 lt2 = 00:32:00.999999 毫秒级的精度是必须的。 更高精度的小数秒取决于实现。 如果它的值超出了实现所支持的精度，那多余的部分必须被舍弃，而不能四舍五入。 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:14","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"数组 数组是内含值的方括号。 空白会被忽略。 子元素由逗号分隔。 数组可以包含与键值对所允许的相同数据类型的值。 可以混合不同类型的值。 integers = [ 1, 2, 3 ] colors = [ \"红\", \"黄\", \"绿\" ] nested_array_of_ints = [ [ 1, 2 ], [3, 4, 5] ] nested_mixed_array = [ [ 1, 2 ], [\"a\", \"b\", \"c\"] ] string_array = [ \"所有的\", '字符串', \"\"\"是相同的\"\"\", '''类型''' ] # 允许混合类型的数组 numbers = [ 0.1, 0.2, 0.5, 1, 2, 5 ] contributors = [ \"Foo Bar \u003cfoo@example.com\u003e\", { name = \"Baz Qux\", email = \"bazqux@example.com\", url = \"https://example.com/bazqux\" } ] 数组可以跨行。 数组的最后一个值后面可以有终逗号（也称为尾逗号）。 值、逗号、结束括号前可以存在任意数量的换行和注释。 数组值和逗号之间的缩进被作为空白对待而被忽略。 integers2 = [ 1, 2, 3 ] integers3 = [ 1, 2, # 这是可以的 ] ","date":"2021-06-05","objectID":"/article/2021/toml/:0:15","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"表 表（也被称为哈希表或字典）是键值对的集合。 它们由表头定义，连同方括号作为单独的行出现。 看得出表头不同于数组，因为数组只有值。 [table] 在它下方，直至下一个表头或文件结束，都是这个表的键值对。 表不保证保持键值对的指定顺序。 [table-1] key1 = \"some string\" key2 = 123 [table-2] key1 = \"another string\" key2 = 456 表名的规则与键名相同（见前文键名定义）。 [dog.\"tater.man\"] type.name = \"pug\" 等价于 JSON 的如下结构： { \"dog\": { \"tater.man\": { \"type\": { \"name\": \"pug\" } } } } 键名周围的空格会被忽略。 然而，最佳实践还是不要有任何多余的空白。 [a.b.c] # 这是最佳实践 [ d.e.f ] # 等同于 [d.e.f] [ g . h . i ] # 等同于 [g.h.i] [ j . \"ʞ\" . 'l' ] # 等同于 [j.\"ʞ\".'l'] 缩进被作为空白对待而被忽略。 你不必层层完整地写出你不想写的所有途径的父表。 TOML 知道该怎么办。 # [x] 你 # [x.y] 不 # [x.y.z] 需要这些 [x.y.z.w] # 来让这生效 [x] # 后置父表定义是可以的 空表是允许的，只要里面没有键值对就行了。 类似于键名，你不能重复定义一个表。 这样做是非法的。 # 不要这样做 [fruit] apple = \"红\" [fruit] orange = \"橙\" # 也不要这样做 [fruit] apple = \"红\" [fruit.apple] texture = \"光滑\" 不鼓励无序地定义表。 # 有效但不鼓励 [fruit.apple] [animal] [fruit.orange] # 推荐 [fruit.apple] [fruit.orange] [animal] 顶层表，又被称为根表，于文档开始处开始并在第一个表头（或文件结束处）前结束。 不同于其它表，它没有名字且无法后置。 # 顶层表开始。 name = \"Fido\" breed = \"pug\" # 顶层表结束。 [owner] name = \"Regina Dogman\" member_since = 1999-08-04 点分隔键为最后一个键名前的每个键名创建并定义一个表，倘若这些表尚未被创建的话。 fruit.apple.color = \"red\" # 定义一个名为 fruit 的表 # 定义一个名为 fruit.apple 的表 fruit.apple.taste.sweet = true # 定义一个名为 fruit.apple.taste 的表 # fruit 和 fruit.apple 已经创建过了 由于表不能定义多于一次，不允许使用 [table] 头重定义这样的表。 同样地，使用点分隔键来重定义已经以 [table] 形式定义过的表也是不允许的。 不过，[table] 形式可以被用来定义通过点分隔键定义的表中的子表。 [fruit] apple.color = \"红\" apple.taste.sweet = true # [fruit.apple] # 非法 # [fruit.apple.taste] # 非法 [fruit.apple.texture] # 你可以添加子表 smooth = true ","date":"2021-06-05","objectID":"/article/2021/toml/:0:16","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"内联表 内联表提供了一种更为紧凑的语法来表示表。 对于否则就很啰嗦的成组数据，这尤其有用。 内联表被完整地定义在花括号之中：{ 和 }。 括号中，可以出现零或更多个以逗号分隔的键值对。 键值对采取与标准表中的键值对相同的形式。 什么类型的值都可以，包括内联表。 内联表得出现在同一行内。 内联表中，最后一对键值对后不允许终逗号（也称为尾逗号）。 不允许花括号中出现任何换行，除非在值中它们合法。 即便如此，也强烈不建议把一个内联表搞成纵跨多行的样子。 如果你发现自己真的需要，那意味着你应该使用标准表。 name = { first = \"Tom\", last = \"Preston-Werner\" } point = { x = 1, y = 2 } animal = { type.name = \"pug\" } 上述内联表等同于下面的标准表定义： [name] first = \"Tom\" last = \"Preston-Werner\" [point] x = 1 y = 2 [animal] type.name = \"pug\" 内联表是独立自足的，在内部定义全部的键与子表。 不能在括号以外的地方，再添加键与子表。 [product] type = { name = \"Nail\" } # type.edible = false # 非法 类似地，内联表不能被用于向一个已定义的表添加键或子表。 [product] type.name = \"Nail\" # type = { edible = false } # 非法 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:17","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"表数组 最后一个还没讲到的语法允许你写表数组。 这可以通过把表名写在双方括号里的表头来表示。 表头的第一例定义了这个数组及其首个表元素，而后续的每个则在该数组中创建并定义一个新的表元素。 这些表按出现顺序插入该数组。 [[products]] name = \"Hammer\" sku = 738594937 [[products]] # 数组里的空表 [[products]] name = \"Nail\" sku = 284758393 color = \"gray\" 等价于 JSON 的如下结构。 { \"products\": [ { \"name\": \"Hammer\", \"sku\": 738594937 }, { }, { \"name\": \"Nail\", \"sku\": 284758393, \"color\": \"gray\" } ] } 任何对表数组的引用都指向该数组里最近定义的表元素。 这允许你在最近的表内定义子表，甚至子表数组。 [[fruits]] name = \"apple\" [fruits.physical] # 子表 color = \"red\" shape = \"round\" [[fruits.varieties]] # 嵌套表数组 name = \"red delicious\" [[fruits.varieties]] name = \"granny smith\" [[fruits]] name = \"banana\" [[fruits.varieties]] name = \"plantain\" 上述 TOML 等价于 JSON 的如下结构。 { \"fruits\": [ { \"name\": \"apple\", \"physical\": { \"color\": \"red\", \"shape\": \"round\" }, \"varieties\": [ { \"name\": \"red delicious\" }, { \"name\": \"granny smith\" } ] }, { \"name\": \"banana\", \"varieties\": [ { \"name\": \"plantain\" } ] } ] } 如果一个表或表数组的父级是一个数组元素，该元素必须在定义子级前先定义。 顺序颠倒的行为，必须在解析时报错。 # 非法的 TOML 文档 [fruit.physical] # 子表，但它应该隶属于哪个父元素？ color = \"red\" shape = \"round\" [[fruit]] # 解析器必须在发现“fruit”是数组而非表时抛出错误 name = \"apple\" 若试图向一个静态定义的数组追加内容，即便数组尚且为空，也必须在解析时报错。 # 非法的 TOML 文档 fruits = [] [[fruits]] # 不允许 若试图用已经确定为数组的名称定义表，必须在解析时报错。 将数组重定义为普通表的行为，也必须在解析时报错。 # 非法的 TOML 文档 [[fruits]] name = \"apple\" [[fruits.varieties]] name = \"red delicious\" # 非法：该表与之前的表数组相冲突 [fruits.varieties] name = \"granny smith\" [fruits.physical] color = \"red\" shape = \"round\" # 非法：该表数组与之前的表相冲突 [[fruits.physical]] color = \"green\" 你也可以适当使用内联表： points = [ { x = 1, y = 2, z = 3 }, { x = 7, y = 8, z = 9 }, { x = 2, y = 4, z = 8 } ] ","date":"2021-06-05","objectID":"/article/2021/toml/:0:18","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"文件扩展名 TOML 文件应当使用 .toml 扩展名。 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:19","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"MIME 类型 在互联网上传输 TOML 文件时，恰当的 MIME 类型是 application/toml。 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:20","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","开发技能","编程经验","收集与整理"],"content":"ABNF 语法 TOML 语法的严谨说明，由一个 ABNF 文件另行提供。 ","date":"2021-06-05","objectID":"/article/2021/toml/:0:21","tags":["TOML","Rust"],"title":"TOML 语言规范 1.0 正式版","uri":"/article/2021/toml/"},{"categories":["Learn Rust","收集与整理"],"content":"了解 一般来说，要决定学习一门新语言之前，会先大体了解下这门语言的特点和目前的发展情况。 这时，建议看 Rust 官网 https://rust-lang.org ","date":"2021-06-05","objectID":"/article/2021/learn_rust/:1:0","tags":["Rust"],"title":"Rust 学习指南","uri":"/article/2021/learn_rust/"},{"categories":["Learn Rust","收集与整理"],"content":"Rust 官方文档 Rust 语言的学习或参考文档大都列在 Rust 学习指引页 和 Rust 官方文档主页 上，目前 Rust 官方团队已经将相关文档拆分到不同的仓库上： 《Rust 程序设计语言》（The Rust Programming Language），对应 GitHub 仓库 《通过例子学 Rust》（Rust by Example），对应 GitHub 仓库 Rust 版本指南（The Edition Guide），对应 GitHub 仓库 Cargo 帮助文档，对应 GitHub 仓库源文件 rustdoc 帮助文档，对应 GitHub 仓库源文件 rustc 帮助文档，对应 GitHub 仓库源文件 Rust 编译错误索引，对应 GitHub 仓库源代码 《Rust 语言参考》（The Rust Reference），对应 GitHub 仓库 The Rustonomicon，对应 GitHub 仓库 还有其他更多官方或其他非官方相关的文档： 使用 Rust 编写命令行应用，对应 GitHub 仓库地址 Rust 和 WebAssembly 教程（WebAssembly Book），对应 GitHub 仓库 嵌入式 Rust 教程，对应 GitHub 仓库 A Rust Cookbook，对应 GitHub 仓库 The Unstable Book，对应 GitHub 仓库源代码 rustc 指引——Rust 编译器的工作原理及如何参与贡献（rustc-guide），对应 GitHub 仓库 rustup 命令说明，本翻译项目会将 rustup 的相关说明翻译成中文 Rust RFC——Rust 发展相关制定的文稿，对应 GitHub 仓库 mdBook 使用手册，对应 GitHub 仓库 Rust API 指导原则，对应 GitHub 仓库 async-book，对应 GitHub 仓库 上述文档的源文件有些是放在 rust 和 cargo 的仓库的子目录中：Rust 文档 和 cargo 文档。 ","date":"2021-06-05","objectID":"/article/2021/learn_rust/:2:0","tags":["Rust"],"title":"Rust 学习指南","uri":"/article/2021/learn_rust/"},{"categories":["Learn Rust","收集与整理"],"content":"Rust 资源 Rust 相关的中文资源，包括网站，或者国内的 Rust 的文章或书籍。 ","date":"2021-06-05","objectID":"/article/2021/learn_rust/:3:0","tags":["Rust"],"title":"Rust 学习指南","uri":"/article/2021/learn_rust/"},{"categories":["Learn Rust","收集与整理"],"content":"Rust 相关的中文网站 以下列出目前搜集到的 Rust 中文网站： Rust 语言中文社区：https://rust.cc/ Rust Wiki 网：https://rustwiki.org/ ","date":"2021-06-05","objectID":"/article/2021/learn_rust/:3:1","tags":["Rust"],"title":"Rust 学习指南","uri":"/article/2021/learn_rust/"},{"categories":["Learn Rust","收集与整理"],"content":"Rust 语言术语中英文对照表 👉 部分来自 Rust 语言术语中英文对照表仓库，收录在此处，只是方便 Rust 学习者统一查阅，若是发现有任何错误或需要完善地方，请在原仓库指出或修改错误。 English 英文 Chinese 中文 Note 备注 A Abstract Syntax Tree 抽象语法树 ABI 应用程序二进制接口 Application Binary Interface 缩写 accumulator 累加器 accumulator variable 累加器变量 ahead-of-time compiled 预编译 ahead-of-time compiled language 预编译语言 alias 别名 aliasing 别名使用 参见 Wikipedia angle brackets 尖括号，“\u003c”和“\u003e” annotate 标注，注明（动词） annotation 标注，注明（名词） ARC 原子引用计数器 Atomic Referecne Counter anonymity 匿名 argument 参数，实参，实际参数 不严格区分的话， argument（参数）和 parameter（参量）可以互换地使用 argument type 参数类型 assignment 赋值 associated functions 关联函数 associated items 关联项 associated types 关联类型 asterisk 星号（*) atomic 原子的 attribute 属性 automated building 自动构建 automated test 自动测试，自动化测试 B baroque macro 巴洛克宏 benchmark 基准 binary 二进制的 binary executable 二进制的可执行文件 bind 绑定 block 语句块，代码块 boolean 布尔型，布尔值 borrow check 借用检查 borrower 借用者，借入者 borrowing 借用 bound 约束，限定，限制 此词和 constraint 意思相近， constraint 在 C# 语言中翻译成“约束” box 箱子，盒子，装箱类型 一般不译，作动词时翻译成“装箱”， 具有所有权的智能指针 boxed 装箱，装包 boxing 装箱，装包 brace 大括号，“{”或“}” buffer 缓冲，缓冲区，缓冲器，缓存 build 构建 builder pattern 创建者模式 C call 调用 caller 调用者 capacity 容器 capture 捕获 cargo (Rust 包管理器，不译) 该词作名词时意思是“货物”， 作动词时意思是“装载货物” cargo-fy Cargo 化，使用 Cargo 创建项目 case analysis 事例分析 cast 类型转换，转型 casting 类型转换 chaining method call 链式方法调用 channel 信道，通道 closure 闭包 coercion 强制类型转换，强制转换 coercion 原意是“强制，胁迫” collection 集合 参见 Wikipedia combinator 组合算子，组合器 comma 逗号，“,” command 命令 command line 命令行 comment 注释 compile 编译（动词） compile time 编译期，编译期间，编译时 compilation 编译（名词） compilation unit 编译单元 compiler 编译器 compiler intrinsics 编译器固有功能 compound 复合（类型，数据） concurrency 并发 conditional compilation 条件编译 configuration 配置 constructor 构造器 consumer 消费者 container 容器 container type 容器类型 convert 转换，转化，转 copy 复制，拷贝 crate 包，包装箱，装包 一般不译，crate 是 Rust 的基本编译单元 curly braces 大括号，包含“{”和“}” custom type 自定义类型 D dangling pointer 悬垂指针 use after free 在释放后使用 data race 数据竞争 dead code 死代码，无效代码，不可达代码 deallocate 释放，重新分配 declare 声明 deep copy 深拷贝，深复制 dependency 依赖 deref coercions 强制多态 dereference 解引用 Rust 文章中有时简写为 Deref derive 派生 designator 指示符 destruction 销毁，毁灭 destructor 析构器，析构函数 destructure 解构 destructuring 解构，解构赋值 desugar 脱糖 diverge function 发散函数 device drive 设备驱动 directory 目录 dispatch 分发 diverging functions 发散函数 documentation 文档 dot operator 点运算符 DST 动态大小类型 dynamic sized type，一般不译， 使用英文缩写形式 dynamic language 动态类型语言 dynamic trait type 动态特质类型 E enumeration 枚举 encapsulation 封装 equality test 相等测试 elision 省略 exhaustiveness checking 穷尽性检查，无遗漏检查 expression 表达式 expression-oriented language 面向表达式的语言 explicit 显式 explicit discriminator 显式的辨别值 explicit type conversion 显式类型转换 extension 扩展名 extern 外，外部 作关键字时不译 F fat pointer 胖指针 feature gate 功能开关 field 字段 field-level mutability 字段级别可变性 file 文件 fmt 格式化，是 format 的缩写 formatter 格式化程序，格式化工具，格式器 floating-point number 浮点数 flow control 流程控制 Foreign Function Interface（FFI） 外部语言函数接口 fragment specifier 片段分类符 free variables 自由变量 freeze 冻结 function 函数 function declaration 函数声明 functional 函数式 G garbage collector 垃圾回收 generalize 泛化，泛型化 generator 生成器 generic 泛型 generic type 泛型类型 growable 可增长的 guard 守卫 H handle error 句柄错误 hash 哈希，哈希值，散列 hash map 散列映射，哈希表 heap 堆 hierarchy 层次，分层，层次结构 higher rank lifetime 高阶生命周期 higher rank trait bound 高阶特质约束 higher tank type 高阶类型 hygiene 卫生 hygienic macro system 卫生宏系统 I ICE 编译内部错误 internal comppiler error 的缩写 immutable 不可变的 implement 实现 implementor 实现者 implicit 隐式 implicit discriminator 隐式的辨别值 implicit type conversion 隐式类型转换 import 导入 in assignment 在赋值（语句） index 索引 英语复数形式：indices infer 推导（动词） inference 推导（名词） inherited mutability 承袭可变性 inheritance 继承 integrated development environment(IDE) 集成开发环境 中文著作中通常直接写成 IDE integration-style test 集成测试 interior mutability 内部可变性 installer 安装程序，安装器 instance 实例 instance method 实例方法 integer 整型，整数 interact 相互作用，相互影响 interior mutability 内部可变性 intrinsic 固有的 invoke 调用 item 项，条目，项目 iterate 重复 iteration 迭代 iterator 迭代器 iterator adaptors 迭代器适配器 iterator invalidation 迭代器失效 L LHS 左操作数 left-hand side 的非正式缩写， 与 RHS 相对 lender 借出者 library 库 lifetime 生存时间，寿命，生命周期 lifetime elision 生命周","date":"2021-06-05","objectID":"/article/2021/learn_rust/:4:0","tags":["Rust"],"title":"Rust 学习指南","uri":"/article/2021/learn_rust/"},{"categories":["收集与整理"],"content":"2021-06-03 今日技术分享 竟然还在争论是否学Go？本文彻底终结该话题 https://mp.weixin.qq.com/s/2jYX2iMp0z7v09-AxdLDMg GM到GMP，Golang经历了什么？ https://mp.weixin.qq.com/s/RR3ducI2gK7JuLAzeILRzg 全面了解虚拟内存：更好学习Go https://mp.weixin.qq.com/s/g5I7un3-lpffAk6UFes8DA 搞 Go 要了解的 2 个 Header，你知道吗？ https://mp.weixin.qq.com/s/rGqM1wMlqQEoJSgyrgZNLg 我这样升级 Go 版本，你呢？ https://mp.weixin.qq.com/s/bGS5D0UYVp6BxSLjuZy0pg 软件工程能力漫谈 https://mp.weixin.qq.com/s/hJS5LJRZkMZmHm6g2R_jpw Harbor 结合 Traefik 的 HA 安装配置 https://mp.weixin.qq.com/s/LGI7ZWSK8YGzPVddJxcAUA 如何设计 API 接口，实现统一格式返回？ https://mp.weixin.qq.com/s/6c6uapjIzJC9wmjUFyZuZA 【阿里巴巴】云原生布道师的机会，这要求。。。 https://mp.weixin.qq.com/s/3cQLB7hEp5snlFmc1ueAfA Go 应用优化指北 https://mp.weixin.qq.com/s/KFT1hw02Zih1TMMlDWztCQ Go语言如何实现可重入锁？ https://mp.weixin.qq.com/s/wBp4k7pJLNeSzyLVhGHLEA 自制文件系统 — 02 FUSE 框架，开发者的福音 https://mp.weixin.qq.com/s/HvbMxNiVudjNPRgYC8nXyg 深入浅出查询优化器 https://mp.weixin.qq.com/s/G_KSkRREXm9fws37gFKoBg 小菜刀面试归来 https://mp.weixin.qq.com/s/xWGHV1_7qvDPhyWJiVr-4g GM 到 GMP，Golang 经历了什么？ https://mp.weixin.qq.com/s/RR3ducI2gK7JuLAzeILRzg#at Go 语言如何实现可重入锁？ https://mp.weixin.qq.com/s/wBp4k7pJLNeSzyLVhGHLEA 如何使用 Golang 进行测试驱动开发 https://medium.com/@jilsonfreddy/how-to-do-test-driven-development-using-golang-unit-testing-945256aa45cf Go 性能工具备忘录 https://steveazz.xyz/blog/go-performance-tools-cheat-sheet 字节跳动的 JSON 处理库 https://github.com/bytedance/sonic etcd工作原理 https://blog.px.dev/etcd-6-tips/ 在Go中，你可能并不希望为了性能而使用这种并发性 https://medium.com/nerd-for-tech/you-probably-dont-want-that-concurrency-in-go-109421e8d23 字节开源的高性能json编解码库 https://github.com/bytedance/sonic argo rollouts项目发布1.0版本 https://www.cncf.io/blog/2021/05/27/argo-rollouts-1-0-released/ Yor：一个开源工具，有助于在Terraform、CloudFormation和Serverless等基础设施即代码框架中添加内容丰富且一致的标签 https://bridgecrew.io/blog/announcing-yor-open-source-iac-tag-trace-cloud-resources/ Terraform 0.4的云开发包(CDK)发布 https://www.hashicorp.com/blog/announcing-cdk-for-terraform-0-4 最糟糕的所谓Docker “最佳实践” https://pythonspeed.com/articles/security-updates-in-docker 为kubernetes CRD编写controller https://vivilearns2code.github.io/k8s/2021/03/11/writing-controllers-for-kubernetes-custom-resources.html 比较postgresal的kubernetes operators https://blog.flant.com/comparing-kubernetes-operators-for-postgresql/ 容忍容器镜像仓库的故障 https://blog.kintone.io/entry/neco-registry 微软研究院的新工具帮助开发人员更快地编写无缺陷的代码 https://blogs.microsoft.com/ai-for-business/Microsoft-Research-tools-help-developers-write-bug-free-code-faster/ 作为一名高级工程师，我学到的东西 https://old.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk_post_things_ive_learned_as_a_sr_engineer/ context 使用场景到源码解读 https://xie.infoq.cn/article/3e18dd6d335d1a6ab552a88e8 go并发进阶路线 https://www.yuque.com/u2278269/gq5x74/ggpvz6 ","date":"2021-06-03","objectID":"/article/2021/go20210603/:0:0","tags":["技术分享","Golang"],"title":"Go20210603 今日技术分享","uri":"/article/2021/go20210603/"},{"categories":["趣站","轻松好玩"],"content":"塔防游戏 可玩性很高的一款塔防游戏，需要各类元素合成，通过传送带传送宝石、木材、铁等元素，最后合成弓箭、大炮、闪电塔等来抵御怪兽的袭击，一玩就停不下来。 传送门 https://yorg.io/ ","date":"2021-06-02","objectID":"/article/2021/tower-defense/:0:1","tags":["多人联机","塔防","网页游戏","Tower Defense"],"title":"塔防游戏-YORG.io","uri":"/article/2021/tower-defense/"},{"categories":["趣站","轻松好玩"],"content":"玩法 通过传送带传送宝石、木材、铁等元素，最后合成弓箭、大炮、闪电塔等来抵御怪兽的袭击 ","date":"2021-06-02","objectID":"/article/2021/tower-defense/:0:2","tags":["多人联机","塔防","网页游戏","Tower Defense"],"title":"塔防游戏-YORG.io","uri":"/article/2021/tower-defense/"},{"categories":["趣站","轻松好玩"],"content":"80后的回忆，曾经在网吧爆肝玩的一款游戏，这是个在线版本，可以和其他人对战，回忆满满的一款在线游戏","date":"2021-06-02","objectID":"/article/2021/red-alert-2-chronodivide/","tags":["多人联机","红警2","网页游戏"],"title":"网页版红色警戒2-Red Alert 2: Chrono Divide","uri":"/article/2021/red-alert-2-chronodivide/"},{"categories":["趣站","轻松好玩"],"content":"在线红警 又是一波人的集体回忆。。。网站高度还原了经典游戏——红色警戒2，原汁原味的画面和音效，仿佛又回到了那个电脑房的年代！ 传送门 https://game.chronodivide.com/ ","date":"2021-06-02","objectID":"/article/2021/red-alert-2-chronodivide/:0:1","tags":["多人联机","红警2","网页游戏"],"title":"网页版红色警戒2-Red Alert 2: Chrono Divide","uri":"/article/2021/red-alert-2-chronodivide/"},{"categories":["趣站","轻松好玩"],"content":"玩法 网站支持多人在线对战，注册登陆后即可开始！ ","date":"2021-06-02","objectID":"/article/2021/red-alert-2-chronodivide/:0:2","tags":["多人联机","红警2","网页游戏"],"title":"网页版红色警戒2-Red Alert 2: Chrono Divide","uri":"/article/2021/red-alert-2-chronodivide/"},{"categories":["收集与整理"],"content":"2021-06-02 今日技术分享 推荐一本免费的 Go 新书：用 Go 讲架构的书 https://mp.weixin.qq.com/s/SoqxlvEOyV6EtjKTWGEyxw Go 每日一库之 fasttemplate https://mp.weixin.qq.com/s/_ZIB3H1kJwb8s53lIQ-7Sw 在容器里设置GOMAXPROCS的正确姿势 https://mp.weixin.qq.com/s/jVyKb_3YS9ETX4JmIuhWJA 自适应微服务治理背后的算法 https://mp.weixin.qq.com/s/OpF4JVWHA9W1v0yefeo56w 用 Rust 编写的 Git 极速终端 UI https://mp.weixin.qq.com/s/NlVq30gs6qcdg3CQBS8-IA 优雅地处理错误真是一门学问啊！ https://mp.weixin.qq.com/s/W_LsZtnjGIKQ-LB6EkRgBA Go 每日一库之 reflect https://mp.weixin.qq.com/s/KoHYoQ0q9qVjOWLPAIWaAA kubernetes面试相关总结(上) https://mp.weixin.qq.com/s/33cKjVFf7pERyRHQtDwXoQ 百度健康急招Gopher https://mp.weixin.qq.com/s/5zyEHVz258IgnIpjOfFADQ 16 中的新函数 signal.NotifyContext 怎么用？ https://mp.weixin.qq.com/s/mnR_wADjyHtyjdkSwcnkSw 蚂蚁开源 OceanBase，开源分布式数据库又迎新玩家 https://mp.weixin.qq.com/s/iDBpa3w2iP8XUr9fb-QWoA 曹大带我学 Go（4）—— 初识 ast 的威力 https://mp.weixin.qq.com/s/K_iyVFOqg0_2wWmkvXgD8Q 理解 Golang 中函数调用的原理 https://blog.51cto.com/u_15127695/2829851 Go 微服务全链路跟踪详解 https://mp.weixin.qq.com/s/C6OtNYtskdPpfw-HsP76vQ 自适应微服务治理背后的算法 https://mp.weixin.qq.com/s/OpF4JVWHA9W1v0yefeo56w 消息队列解耦是骗小孩儿的 https://mp.weixin.qq.com/s/O0KGm3nVUSWMSKwHlPiJpg go channel惯用法 https://blog.kevinhu.me/2021/05/31/31-go-channel-examples/ 经典旧文：k8s pod的request和limit的正确设置方法 https://learnk8s.io/setting-cpu-memory-limits-requests 用Go实现一个并发文件下载工具 https://returnfn.com/lets-build-a-concurrent-file-downloader-in-go Go并发API模式 https://tech.deliveryhero.com/concurrent-api-patterns-in-go/ 使用Go生成你自己的O’RLY动物书封面 https://github.com/nanmu42/orly 使用Go实现一个简单但强大的反向代理 https://blog.joshsoftware.com/2021/05/25/simple-and-powerful-reverseproxy-in-go/ 使用falco分析k3s集群的审计日志 https://github.com/developer-guy/falco-analyze-audit-log-from-k3s-cluster docker live视频：利用Cue和Buildkit重新思考应用交付问题 https://docker.events.cube365.net/dockercon-live/2021/content/Videos/TamRA3F2zT8fycvq5 阿里的Oceanbase开源 https://github.com/oceanbase/oceanbase 开源社区需要更多的安全空间和行为准则 https://thenewstack.io/open-source-communities-need-more-safe-spaces-and-codes-of-conducts-now/ 高性能的goroutine池 https://www.yuque.com/u2278269/gq5x74/puzrkf 流？I/O操作？阻塞？epoll? https://www.kancloud.cn/aceld/golang/1958320 曹大带你看ast https://mp.weixin.qq.com/s/K_iyVFOqg0_2wWmkvXgD8Q 最常用的调试 golang 的 bug以及性能问题的实践方法 https://www.kancloud.cn/aceld/golang/1958304 ","date":"2021-06-02","objectID":"/article/2021/go20210602/:0:0","tags":["技术分享","Golang"],"title":"Go20210602 今日技术分享","uri":"/article/2021/go20210602/"},{"categories":["收集与整理"],"content":"2021-06-01 今日技术分享 发现了众多 Go 好书 https://mp.weixin.qq.com/s/x6h8xpbn9kuV2wlk-wtULA Go语言爱好者周刊：第 97 期 https://mp.weixin.qq.com/s/6kXbi8OyubJv6opOomb4zg Go小知识：%v +v #v的区别 https://mp.weixin.qq.com/s/g4qgn1b_LvpvMqRZD-k8LA 优化 Kubernetes 横向扩缩容 HPA https://mp.weixin.qq.com/s/x_yID1QFt8vV7ioy_o5LlA Go语言内存逃逸之谜 https://mp.weixin.qq.com/s/zm5rp4DkgrWIduZAMhzNzA 图解 数据安全的3 种 IO 姿势 https://mp.weixin.qq.com/s/a-SQgKzVYVmJ-qWUXy7c8A 在容器里设置GOMAXPROCS的正确姿势 https://mp.weixin.qq.com/s/kbZsJncgVZv30_TwVrLyLQ 深挖Map的读写性能 https://mp.weixin.qq.com/s/quNpj1MQQwWCKeEENGinUg 消息队列解耦是骗小孩儿的 https://mp.weixin.qq.com/s/O0KGm3nVUSWMSKwHlPiJpg 17这个新特性竟然是6年前提出来的 https://mp.weixin.qq.com/s/8Ju2-daS0s-esDAezP-lZw 深度理解 golang map https://juejin.cn/post/6967274139065253902 sync.Pool 原理解析 https://juejin.cn/post/6965421491588431909 Kratos 学习笔记 https://juejin.cn/post/6967941646138736653 来瞧一瞧 gRPC 的拦截器 https://segmentfault.com/a/1190000040087672 Go性能剖析工具速查表 https://steveazz.xyz/blog/go-performance-tools-cheat-sheet/ sealer：阿里开源的分布式应用打包交付运行的解决方案，可以把分布式应用及其数据库中间件等依赖一起打包发布 https://github.com/alibaba/sealer 基于Go控制器的组件框架和热重载插件系统 https://github.com/aperturerobotics/controllerbus 自动化的服务健康仪表板 https://github.com/TwinProduction/gatus CNCF的制品库hub https://github.com/artifacthub/hub Linux之父：我们不会用Rust取代C语言开发内核 https://mp.weixin.qq.com/s/mVo3S_F0RoxCToawrTCnlA 基于KubeEdge实现中国移动10086客服云边协同平台 https://mp.weixin.qq.com/s/pn0UEL2LFUN63__RVgHBLw 面向Kubernetes的红帽高级集群安全简介 https://www.openshift.com/blog/a-brief-introduction-to-red-hat-advanced-cluster-security-for-kubernetes 阿里基于PostgreSQL开源的PolarDB https://github.com/alibaba/PolarDB-for-PostgreSQL ","date":"2021-06-01","objectID":"/article/2021/go20210601/:0:0","tags":["技术分享","Golang"],"title":"Go20210601 今日技术分享","uri":"/article/2021/go20210601/"},{"categories":["收集与整理"],"content":"2021-05-30 今日技术分享 国外竟然有这么多公司使用 Go https://mp.weixin.qq.com/s/fKXIBfxvk1wgZMujuz9hWA Go 中如何让消息队列达到最大吞吐量？ https://mp.weixin.qq.com/s/K9qZVNP4AKsHNcrDyZq_eA Go 每日一库之 gotalk https://mp.weixin.qq.com/s/VnpQilljVokGssECVyFjWw Istio 完败？Linkerd 和 Istio 基准测试 https://mp.weixin.qq.com/s/7A7eXQONpiNdCrfwt1HfhQ 9 种开源的服务网格比较 https://mp.weixin.qq.com/s/3XwKE1pLgMkiH7xuQix25w 如何在 Go-kit 和 Service Mesh 中进行服务注册与发现？ https://mp.weixin.qq.com/s/TZoq5CRQ_QIYTG4W_cU4dg K8s 工作负载图表工具 https://github.com/Trois-Six/k8s-diagrams 灵活的 Go http client 库-Sling https://mp.weixin.qq.com/s/liCnGt0-me4cv-1WAJSSBQ go web client 单元测试实践 https://dev.to/chen/practical-unit-testing-web-client-in-go-1o2m 为什么Go引入泛型后不会改变Go惯用法？ http://www.jerf.org/iri/post/2955 GoLand 2021.2开发计划 https://blog.jetbrains.com/go/2021/05/28/goland-2021-2-early-access-program-is-open/ 使用cobra和go实现shell命令补全 https://jmtirado.net/shell-completion-with-cobra-and-go/ dubbo-go v3版本go module踩坑记 https://mp.weixin.qq.com/s/NFwL7YAtzkSsqZi8AYA6tw 如何像专家那样写benchmark测试 https://hackernoon.com/how-to-write-benchmarks-in-golang-like-an-expert-0w1834gs Go hosts文件操作包 https://github.com/areYouLazy/libhosty Go实现的磁盘分析工具 https://github.com/dundee/gdu 如何在EKS上安装Cilium https://miles-seth.medium.com/eks-unchained-with-ebpf-and-bottlerocket-1639b011a36a eks 集群运行在带有 firecracker 的单个实例上 https://ongres.com/blog/63-node-eks-cluster-running-on-a-single-instance-with-firecracker/ Kubernetes集群压力测试工具 https://github.com/cloud-bulldozer/kube-burner 不可变数据库immudb发布v1.0版本 https://www.codenotary.com/blog/immudb-release-1-0/ ","date":"2021-05-31","objectID":"/article/2021/go20210531/:0:0","tags":["技术分享","Golang"],"title":"Go20210531 今日技术分享","uri":"/article/2021/go20210531/"},{"categories":["收集与整理"],"content":"2021-05-29 今日技术分享 Go：近期两个开源免费好资源 https://mp.weixin.qq.com/s/wXrIztN5MXsNvBKg2LR3hA 再次探讨 Go 的无限缓冲的channel https://mp.weixin.qq.com/s/wZNLOywbQWdju_-7TN_48Q 读者问答：Go 编程怎么也有内存问题？ https://mp.weixin.qq.com/s/51xEfULa1cWaltkTkg1cUA validator库你知多少？govalidator了解一下 https://mp.weixin.qq.com/s/FnvvREHWeN1UdRliFjxQ9A 睡前故事|用Bitmap与AST做一个配置化时长系统 https://mp.weixin.qq.com/s/th5HgpibwZkRlj1EzxmMTw 理论结合实践详解 B+ 树存储引擎（PPT）（多图） https://mp.weixin.qq.com/s/aSNdEkNdeCAC7O6b3coo-A 图解 | epoll怎么实现的 https://mp.weixin.qq.com/s/XW561JURm5zxsXHnD1lV6A 硬核！如何在容器中做时间漫游者 https://mp.weixin.qq.com/s/dTVwpi60_URx1P9c1OPEug Pod Terminating 状态排查 https://mp.weixin.qq.com/s/IattDivoyFSWCq26IV457g 1 业务服务（1） https://mp.weixin.qq.com/s/GzoMpMIUWtM2qNFp5xNiWQ NSQ 如何实现文件队列 https://reposkeeper.net/2020/11/nsq-disk-queue-implement.html Go sync.Pool 浅析 https://blog.csdn.net/haohongfan/article/details/116978613 Golang 指针和 C++ 指针的简单剖析 https://juejin.cn/post/6967315069310861319 在 Go 中使用位掩码 https://www.ardanlabs.com/blog/2021/04/using-bitmasks-in-go.html Go 中的垃圾收集 https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html 鹅厂的Go编码安全指南 https://github.com/Tencent/secguide/blob/main/Go%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97.md OpenTelemetry Go应用入门 https://speakerdeck.com/riferrei/opentelemetry-for-dummies-instrumenting-go-apps 使用Go进行benchmark测试 https://stonecode.ca/benchmarking-with-go/ 使用Go语言进行位操作 https://www.ardanlabs.com/blog/2021/04/using-bitmasks-in-go.html 基于eBPF的网络开源项目Cilium发布1.10 https://cilium.io/blog/2021/05/20/cilium-110 Linkerd和Istio的性能对比(2021版) https://linkerd.io/2021/05/27/linkerd-vs-istio-benchmarks/ 使用Fio来判断你的存储是否足够快，以满足Etcd的需要 https://www.ibm.com/cloud/blog/using-fio-to-tell-whether-your-storage-is-fast-enough-for-etcd Kubernetes API的优先级和公平性 https://itnext.io/kubernetes-api-priority-and-fairness-b1ef2b8a26a2 用于替代TCP的QUIC协议被IETF确定为RFC9000 https://www.fastly.com/blog/quic-is-now-rfc-9000 云的成本，一万亿美元的悖论 https://a16z.com/2021/05/27/cost-of-cloud-paradox-market-cap-cloud-lifecycle-scale-growth-repatriation-optimization/ 分布式事务的实现原理 https://draveness.me/distributed-transaction-principle/ facebook全球用户流量管理系统 https://draveness.me/papers-taiji/ goroutine调度机制概览 https://zhuanlan.zhihu.com/p/244054940?utm_source=wechat_session\u0026utm_medium=social\u0026utm_oi=1034363224250163200\u0026utm_campaign=shareopn ","date":"2021-05-30","objectID":"/article/2021/go20210529/:0:0","tags":["技术分享","Golang"],"title":"Go20210529 今日技术分享","uri":"/article/2021/go20210529/"},{"categories":["收集与整理"],"content":"2021-05-28 今日技术分享 如何让 Go 的缓存库 BigCache 更好用？ https://mp.weixin.qq.com/s/Zn1rP18GtmZsbaRnRfJ8ug 在 Go 语言中，有时 nil 并不是一个 nil https://mp.weixin.qq.com/s/_REGCKxs0ymIdZXN5a6Tgg AWS 容器服务的安全实践 https://mp.weixin.qq.com/s/GYMXc4HXBGOGgA_7mdenhA 骚操作，这款工具可以把Kubernetes集群打包成一个镜像 https://mp.weixin.qq.com/s/ssZSMqogjP6CTOKOOR2e5Q 总结 Kafka 背后的优秀设计 https://mp.weixin.qq.com/s/dfOP2MeBOqFqg_BdcJCYug 硬核！如何在容器中做时间漫游者 https://mp.weixin.qq.com/s/PtYKA-lviJO6A2sXfEaNWA 曹大带我学 Go（3）—— 如何用汇编打同事的脸 https://mp.weixin.qq.com/s/2Y3qPkysRLaWDcIyLOerZg Go可用性(七) 总结: 一张图串联可用性知识点 https://mp.weixin.qq.com/s/OXopl6FpwtE6P-k0GEP9qA Go 指针 https://sher-chowdhury.medium.com/pointers-in-go-507ec33446b0 Go 自定义 http 错误 https://dev.to/clavinjune/my-custom-http-error-in-golang-5ab Go 语言 JSON 使用技巧 https://www.liwenzhou.com/posts/Go/json_tricks_in_go Go 简单快速模板引擎 https://github.com/valyala/fasttemplate Go 1.18加入泛型后的Go函数式编程的未来 https://ani.dev/2021/05/25/functional-programming-in-go-with-generics/ Go团队如何解bug: 乱序执行与内存屏障 https://mzh.io/how-go-core-team-debug-1-memory-model/ 提案：将Go移植到中科龙芯指令架构 https://github.com/golang/go/issues/46229 实验性Go重构工具rf https://pkg.go.dev/rsc.io/rf 成为Kubernetes专家的47件事 https://ymmt2005.hatenablog.com/entry/k8s-things Go自动化测试介绍 https://dev.to/salesforceeng/intro-to-automated-testing-in-go-4mjl 油管视频：Go 还是 Rust，看Go专家与Rust专家的圆桌辩论 https://www.youtube.com/watch?v=N-E-qtQhsHw 欧洲电信巨头优先选择基于Kubernetes的开放云平台 https://thenewstack.io/european-telecom-giants-prioritize-a-kubernetes-based-open-cloud-platform/ 5分钟内从零到入门Kubernetes https://dev.to/ahmednader10/zero-to-kubernetes-in-5-mins-2hbp 用这4个最佳实践提高你的CI/CD可观察性 https://thenewstack.io/improve-your-ci-cd-observability-with-these-4-best-practices/ ","date":"2021-05-29","objectID":"/article/2021/go20210528/:0:0","tags":["技术分享","Golang"],"title":"Go20210528 今日技术分享","uri":"/article/2021/go20210528/"},{"categories":["收集与整理"],"content":"2021-05-27 今日技术分享 为什么Go程序占用那么大的虚拟内存？ https://mp.weixin.qq.com/s/tkAWtSJ4ebAUcQG9AmeXWA 你不知道的 Go 之 string https://mp.weixin.qq.com/s/6miIgsZN_Fh79Aixv5BlTg 又吵起来了，Go 是传值还是传引用？ https://mp.weixin.qq.com/s/qsxvfiyZfRCtgTymO9LBZQ Go 编程怎么也有踩内存？ https://mp.weixin.qq.com/s/tXAP8_U63QLNj1h0ZMvXPw kubectl debug | 调试Kubernetes的最简方法 https://mp.weixin.qq.com/s/8uN2MySGlgxTed5vwqfFlA 果然，连流程控制都这么另类 https://mp.weixin.qq.com/s/tO8CFBDZ2UsOonqARxOQUA 带你走进云原生技术：云原生开放运维体系探索和实践 https://mp.weixin.qq.com/s/zasjqGBDjyeg91jVaa5Xwg 通用连接池帮你解决资源管理难题 https://mp.weixin.qq.com/s/X-xzEzlVrEKYo78eiHwDKw Go 1.17新特性 https://mp.weixin.qq.com/s/T14M_s5qOA6LKvWGgNa0Ow 无限缓冲的channel(2) https://mp.weixin.qq.com/s/wDrOBRaPqHx6g-Ir-Yx8kA 如何运行并行功能测试 https://medium.com/fiverr-engineering/running-parallel-functional-tests-2f6609bfbf4e Go 中一些不曾注意的点 https://arash-cordi.medium.com/dark-corners-of-go-4e29aafcd4b9 如何像专家一样编写 Golang 基准测试 https://hackernoon.com/how-to-write-benchmarks-in-golang-like-an-expert-0w1834gs 详解 Go 空结构体的 3 种使用场景 https://mp.weixin.qq.com/s/zbYIdB0HlYwYSQRXFFpqSg Promtheus rules lint 工具 https://github.com/cloudflare/pint 详解Go语言的栈跟踪 https://github.com/DataDog/go-profiler-notes/blob/main/stack-traces.md 关于go结构体字段布局优化 https://dev.to/deleplace/data-oriented-ant-in-go-3eki 使用Go实现《Head First Design Patterns》中的设计模式 5.使用taildrop在终端间安全的发送文件 https://faun.pub/head-first-design-patterns-using-go-introduction-d9f05a4c243a 使用Go实现《Head First Design Patterns》中的设计模式 5.使用taildrop在终端间安全的发送文件 https://tailscale.com/blog/sending-files-with-taildrop/ Vanilla Kubernetes对Raspberry Pi来说真的太重了吗？ https://www.talos-systems.com/blog/is-vanilla-kubernetes-really-too-heavy-for-the-raspberry-pi/ 使用Go, Gin, MySQL和Docker构建blog项目 https://nizu.tech/go-blog-1 20大Dockerfile最佳实践 https://sysdig.com/blog/dockerfile-best-practices/ 在kubernetes上运行consul和vault https://testdriven.io/blog/running-vault-and-consul-on-kubernetes/ 使用tekton构建云原生ci/cd https://itnext.io/cloud-native-ci-cd-with-tekton-building-custom-tasks-663e63c1f4fb 观点：是时候停止推荐clean code了 https://qntm.org/clean 关于编程语言的思考 https://itnext.io/my-thoughts-about-programming-languages-43a8d23ead1f redis和IO多路复用 https://zhuanlan.zhihu.com/p/24252862 mysql核心知识 https://zhuanlan.zhihu.com/p/363639169 ","date":"2021-05-28","objectID":"/article/2021/go20210527/:0:0","tags":["技术分享","Golang"],"title":"Go20210527 今日技术分享","uri":"/article/2021/go20210527/"},{"categories":["收集与整理","编程经验"],"content":"Go Module代理仓库服务 七牛云提供的：https://goproxy.cn/ goproxy.io：https://goproxy.io/ 百度云BOS提供的：https://goproxy.baidu.com/ 阿里云提供的：https://mirrors.aliyun.com/goproxy/ ","date":"2021-05-27","objectID":"/article/2021/goproxy/:0:1","tags":["技术分享","Golang","Goproxy"],"title":"Goproxy","uri":"/article/2021/goproxy/"},{"categories":["收集与整理","编程经验"],"content":"下载 Go 镜像（Golang Downloads Mirrors） 下载 Go 镜像：https://golang.google.cn/ 下载 Go 镜像：https://gomirrors.org/ 下载 Go 镜像：https://studygolang.com/dl ","date":"2021-05-27","objectID":"/article/2021/goproxy/:0:2","tags":["技术分享","Golang","Goproxy"],"title":"Goproxy","uri":"/article/2021/goproxy/"},{"categories":["收集与整理"],"content":"2021-05-26 今日技术分享 gRPC 可以不用 pb 而使用 JSON 吗？ https://mp.weixin.qq.com/s/oQ4aG0pIJmQFQd2TKGxsXg 什么？无限缓冲 channel。。。 https://mp.weixin.qq.com/s/0TJRcbaWlfwEjbKMKAxNAQ 10.0 有史以来性能最优 https://mp.weixin.qq.com/s/qJ7HQ2BVS6DEO6sPTJzeAA 最强 CNI 基准测试：Cilium 网络性能分析 https://mp.weixin.qq.com/s/NR7gDpp2i5gCRRwZjxaASA 使用kubebuilder开发简单的Operator https://mp.weixin.qq.com/s/uhOIPfTs4o5MDKbdhh_kEQ 我这样升级 Go 版本，你呢？ https://mp.weixin.qq.com/s/jEhX5JHAo9L6iD3N54x6aA B 站直播 | Istio 开源四周年回顾与展望 https://mp.weixin.qq.com/s/tYIP1_s1jHXu6j4mjLuJIw PAAS平台开发的自我救赎 https://mp.weixin.qq.com/s/0vuneQ-rweCZ-kKLvhe_6g Go 每日一库之 fasttemplate https://mp.weixin.qq.com/s/uNE94IBUmTp2PJ4boFz8OQ 60道重要的Kubernetes面试题 https://mp.weixin.qq.com/s/G1kNSmXLaAzAOQ-ja2pKVQ Go 编码安全指南 https://github.com/Tencent/secguide/blob/main/Go%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97.md 私钥安全分发工具 cocert https://github.com/Dentrax/cocert 两年 Go 经验学到的东西 https://sayedalesawy.hashnode.dev/top-5-lessons-i-learned-while-working-with-go-for-two-years Go 如何进行栈追踪 https://github.com/DataDog/go-profiler-notes/blob/main/stack-traces.md Linux 中的 macOS 子系统 lima https://github.com/AkihiroSuda/lima 使用Go的两年后我学到的五大教训 https://sayedalesawy.hashnode.dev/top-5-lessons-i-learned-while-working-with-go-for-two-years Ransomware：Kasten K8s存储平台如何克服终极数据复制挑战 https://thenewstack.io/ransomware-how-the-kasten-k8s-storage-platform-overcomes-the-ultimate-data-replication-challenge/ 新提案：bytes、strings包增加Cut函数 https://github.com/golang/go/issues/46336 将eBPF用于高级Linux基础设施监控 https://www.linuxjournal.com/content/ebpf-advanced-linux-infrastructure-monitoring 使用podman从docker compose转换到kubernetes https://www.redhat.com/sysadmin/compose-kubernetes-podman 像函数一样调用的go模板 https://github.com/rsc/tmplfunc FIFO、LRU、CLOCK和LFU四种缓存替换策略的Go实现 https://brunocalza.me/the-cache-is-full/ 使用Thanos监控多k8s集群 https://particule.io/en/blog/thanos-monitoring/ 在kubernetes上运行apache flink https://medium.com/empathyco/running-apache-flink-on-kubernetes-10815a26559e kubecost：使用kubectl监控kubernetes消耗 https://thenewstack.io/kubecost-monitor-kubernetes-costs-with-kubectl/ go应用性能优化 https://xargin.com/go-perf-optimization/ Kubernetes 集群灾备环境部署 https://mp.weixin.qq.com/s/3rOKOT7bg17K3SKNUFIiIQ mvcc多版本并发控制 https://blog.csdn.net/filling_l/article/details/112854716 ","date":"2021-05-26","objectID":"/article/2021/go20210526/:0:0","tags":["技术分享","Golang"],"title":"Go20210526 今日技术分享","uri":"/article/2021/go20210526/"},{"categories":["Using Software"],"content":" 利用 Volatility 找出应用程序、网络连接、内核模块、文件等方面的情况。 计算机的操作系统和应用使用主内存（RAM）来执行不同的任务。这种易失性内存包含大量关于运行应用、网络连接、内核模块、打开的文件以及几乎所有其他的内容信息，但这些信息每次计算机重启的时候都会被清除。 内存取证是一种从内存中找到和抽取这些有价值的信息的方式。Volatility 是一种使用插件来处理这类信息的开源工具。但是，存在一个问题：在你处理这些信息前，必须将物理内存转储到一个文件中，而 Volatility 没有这种能力。 因此，这篇文章分为两部分： 第一部分是处理获取物理内存并将其转储到一个文件中。 第二部分使用 Volatility 从这个内存转储中读取并处理这些信息。 我在本教程中使用了以下测试系统，不过它可以在任何 Linux 发行版上工作： $ cat /etc/redhat-release Red Hat Enterprise Linux release 8.3 (Ootpa) $ $ uname -r 4.18.0-240.el8.x86_64 $ 注意事项： 部分 1 涉及到编译和加载一个内核模块。不要担心：它并不像听起来那么困难。 一些指南： 按照以下的步骤。 不要在生产系统或你的主要计算机上尝试任何这些步骤。 始终使用测试的虚拟机（VM）来尝试，直到你熟悉使用这些工具并理解它们的工作原理为止。 ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:0:0","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"安装需要的包 在开始之前安装必要的工具。如果你经常使用基于 Debian 的发行版，可以使用 apt-get 命令。这些包大多数提供了需要的内核信息和工具来编译代码： $ yum install kernel-headers kernel-devel gcc elfutils-libelf-devel make git libdwarf-tools python2-devel.x86_64-y ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:1:0","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"部分 1：使用 LiME 获取内存并将其转储到一个文件中 在开始分析内存之前，你需要一个内存转储供你使用。在实际的取证活动中，这可能来自一个被破坏或者被入侵的系统。这些信息通常会被收集和存储来分析入侵是如何发生的及其影响。由于你可能没有可用的内存转储，你可以获取你的测试 VM 的内存转储，并使用它来执行内存取证。 Linux 内存提取器（LiME）是一个在 Linux 系统上获取内存很常用的工具。使用以下命令获得 LiME： $ git clone https://github.com/504ensicsLabs/LiME.git $ $ cd LiME/src/ $ $ ls deflate.c disk.c hash.c lime.h main.c Makefile Makefile.sample tcp.c $ ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:2:0","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"构建 LiME 内核模块 在 src 文件夹下运行 make 命令。这会创建一个以 .ko 为扩展名的内核模块。理想情况下，在 make 结束时，lime.ko 文件会使用格式 lime-.ko 被重命名。 $ make make -C /lib/modules/4.18.0-240.el8.x86_64/build M=\"/root/LiME/src\" modules make[1]: Entering directory '/usr/src/kernels/4.18.0-240.el8.x86_64' \u003c\u003c 删节 \u003e\u003e make[1]: Leaving directory '/usr/src/kernels/4.18.0-240.el8.x86_64' strip --strip-unneeded lime.ko mv lime.ko lime-4.18.0-240.el8.x86_64.ko $ $ $ ls -l lime-4.18.0-240.el8.x86_64.ko -rw-r--r--. 1 root root 25696 Apr 17 14:45 lime-4.18.0-240.el8.x86_64.ko $ $ file lime-4.18.0-240.el8.x86_64.ko lime-4.18.0-240.el8.x86_64.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=1d0b5cf932389000d960a7e6b57c428b8e46c9cf, not stripped $ ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:2:1","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"加载LiME 内核模块 现在是时候加载内核模块来获取系统内存了。insmod 命令会帮助加载内核模块；模块一旦被加载，会在你的系统上读取主内存（RAM）并且将内存的内容转储到命令行所提供的 path 目录下的文件中。另一个重要的参数是 format；保持 lime 的格式，如下所示。在插入内核模块之后，使用 lsmod 命令验证它是否真的被加载。 $ lsmod | grep lime $ $ insmod ./lime-4.18.0-240.el8.x86_64.ko \"path=../RHEL8.3_64bit.mem format=lime\" $ $ lsmod | grep lime lime 16384 0 $ 你应该看到给 path 命令的文件已经创建好了，而且文件大小与你系统的物理内存（RAM）大小相同（并不奇怪）。一旦你有了内存转储，你就可以使用 rmmod 命令删除该内核模块： $ $ ls -l ~/LiME/RHEL8.3_64bit.mem -r--r--r--. 1 root root 4294544480 Apr 17 14:47 /root/LiME/RHEL8.3_64bit.mem $ $ du -sh ~/LiME/RHEL8.3_64bit.mem 4.0G /root/LiME/RHEL8.3_64bit.mem $ $ free -m total used free shared buff/cache available Mem: 3736 220 366 8 3149 3259 Swap: 4059 8 4051 $ $ rmmod lime $ $ lsmod | grep lime $ ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:2:2","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"内存转储中是什么？ 这个内存转储文件只是原始数据，就像使用 file 命令可以看到的一样。你不可能通过手动去理解它；是的，在这里边有一些 ASCII 字符，但是你无法用编辑器打开这个文件并把它读出来。hexdump 的输出显示，最初的几个字节是 EmiL；这是因为你的请求格式在上面的命令行中是 lime： $ file ~/LiME/RHEL8.3_64bit.mem /root/LiME/RHEL8.3_64bit.mem: data $ $ hexdump -C ~/LiME/RHEL8.3_64bit.mem | head 00000000 45 4d 69 4c 01 00 00 00 00 10 00 00 00 00 00 00 |EMiL............| 00000010 ff fb 09 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000020 b8 fe 4c cd 21 44 00 32 20 00 00 2a 2a 2a 2a 2a |..L.!D.2 ..*****| 00000030 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a |****************| 00000040 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 20 00 20 |************* . | 00000050 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000080 00 00 00 00 00 00 00 00 00 00 00 00 70 78 65 6c |............pxel| 00000090 69 6e 75 78 2e 30 00 00 00 00 00 00 00 00 00 00 |inux.0..........| 000000a0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| $ ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:2:3","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"部分 2：获得 Volatility 并使用它来分析你的内存转储 现在你有了要分析的示例内存转储，使用下面的命令获取 Volatility 软件。Volatility 已经用 Python 3 重写了，但是本教程使用的是用 Python 2 写的原始的 Volatility 包。如果你想用 Volatility 3 进行实验，可以从合适的 Git 仓库下载它，并在以下命令中使用 Python 3 而不是 Python 2： $ git clone https://github.com/volatilityfoundation/volatility.git $ $ cd volatility/ $ $ ls AUTHORS.txt contrib LEGAL.txt Makefile PKG-INFO pyinstaller.spec resources tools vol.py CHANGELOG.txt CREDITS.txt LICENSE.txt MANIFEST.in pyinstaller README.txt setup.py volatility $ Volatility 使用两个 Python 库来实现某些功能，所以使用以下命令来安装它们。否则，在你运行 Volatility 工具时，你可能看到一些导入错误；你可以忽略它们，除非你正在运行的插件需要这些库；这种情况下，工具将会报错： $ pip2 install pycrypto $ pip2 install distorm3 ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:3:0","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"列出 Volatility 的 Linux 配置文件 你将要运行的第一个 Volatility 命令列出了可用的 Linux 配置文件，运行 Volatility 命令的主要入口点是 vol.py 脚本。使用 Python 2 解释器调用它并提供 –info 选项。为了缩小输出，查找以 Linux 开头的字符串。正如你所看到的，并没有很多 Linux 配置文件被列出： $ python2 vol.py --info | grep ^Linux Volatility Foundation Volatility Framework 2.6.1 LinuxAMD64PagedMemory - Linux-specific AMD 64-bit address space. $ ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:3:1","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"构建你自己的 Linux 配置文件 Linux 发行版是多种多样的，并且是为不同架构而构建的。这就是为什么配置文件是必要的 —— Volatility 在提取信息前必须知道内存转储是从哪个系统和架构获得的。有一些 Volatility 命令可以找到这些信息；但是这个方法很费时。为了加快速度，可以使用以下命令构建一个自定义的 Linux 配置文件： 移动到 Volatility 仓库的 tools/linux目录下，运行 make 命令： $ cd tools/linux/ $ $ pwd /root/volatility/tools/linux $ $ ls kcore Makefile Makefile.enterprise module.c $ $ make make -C //lib/modules/4.18.0-240.el8.x86_64/build CONFIG_DEBUG_INFO=y M=\"/root/volatility/tools/linux\" modules make[1]: Entering directory '/usr/src/kernels/4.18.0-240.el8.x86_64' \u003c\u003c 删节 \u003e\u003e make[1]: Leaving directory '/usr/src/kernels/4.18.0-240.el8.x86_64' $ 你应该看到一个新的 module.dwarf 文件。你也需要 /boot 目录下的 System.map 文件，因为它包含了所有与当前运行的内核相关的符号： $ ls kcore Makefile Makefile.enterprise module.c module.dwarf $ $ ls -l module.dwarf -rw-r--r--. 1 root root 3987904 Apr 17 15:17 module.dwarf $ $ ls -l /boot/System.map-4.18.0-240.el8.x86_64 -rw-------. 1 root root 4032815 Sep 23 2020 /boot/System.map-4.18.0-240.el8.x86_64 $ $ 要创建一个自定义配置文件，移动回到 Volatility 目录并且运行下面的命令。第一个参数提供了一个自定义 .zip 文件，文件名是你自己命名的。我经常使用操作系统和内核版本来命名。下一个参数是前边创建的 module.dwarf 文件，最后一个参数是 /boot 目录下的 System.map 文件： $ $ cd volatility/ $ $ zip volatility/plugins/overlays/linux/Redhat8.3_4.18.0-240.zip tools/linux/module.dwarf /boot/System.map-4.18.0-240.el8.x86_64 adding: tools/linux/module.dwarf (deflated 91%) adding: boot/System.map-4.18.0-240.el8.x86_64 (deflated 79%) $ 现在自定义配置文件就准备好了，所以在前边给出的位置检查一下 .zip 文件是否被创建好。如果你想知道 Volatility 是否检测到这个自定义配置文件，再一次运行 –info 命令。现在，你应该可以在下边的列出的内容中看到新的配置文件： $ $ ls -l volatility/plugins/overlays/linux/Redhat8.3_4.18.0-240.zip -rw-r--r--. 1 root root 1190360 Apr 17 15:20 volatility/plugins/overlays/linux/Redhat8.3_4.18.0-240.zip $ $ $ python2 vol.py --info | grep Redhat Volatility Foundation Volatility Framework 2.6.1 LinuxRedhat8_3_4_18_0-240x64 - A Profile for Linux Redhat8.3_4.18.0-240 x64 $ $ ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:3:2","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"开始使用 Volatility 现在你已经准备好去做一些真正的内存取证了。记住，Volatility 是由自定义的插件组成的，你可以针对内存转储来获得信息。命令的通用格式是： python2 vol.py -f \u003cmemory-dump-file-taken-by-Lime\u003e \u003cplugin-name\u003e --profile=\u003cname-of-our-custom-profile\u003e 有了这些信息，运行 linux_banner 插件来看看你是否可从内存转储中识别正确的发行版信息： $ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_banner --profile=LinuxRedhat8_3_4_18_0-240x64 Volatility Foundation Volatility Framework 2.6.1 Linux version 4.18.0-240.el8.x86_64 ([mockbuild@vm09.test.com][4]) (gcc version 8.3.1 20191121 (Red Hat 8.3.1-5) (GCC)) #1 SMP Wed Sep 23 05:13:10 EDT 2020 $ ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:3:3","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"找到 Linux 插件 到现在都很顺利，所以现在你可能对如何找到所有 Linux 插件的名字比较好奇。有一个简单的技巧：运行 –info 命令并抓取 linux_ 字符串。有各种各样的插件可用于不同的用途。这里列出一部分： $ python2 vol.py --info | grep linux_ Volatility Foundation Volatility Framework 2.6.1 linux_apihooks - Checks for userland apihooks linux_arp - Print the ARP table linux_aslr_shift - Automatically detect the Linux ASLR shift \u003c\u003c 删节 \u003e\u003e linux_banner - Prints the Linux banner information linux_vma_cache - Gather VMAs from the vm_area_struct cache linux_volshell - Shell in the memory image linux_yarascan - A shell in the Linux memory image $ 使用 linux_psaux 插件检查内存转储时系统上正在运行哪些进程。注意列表中的最后一个命令：它是你在转储之前运行的 insmod 命令。 $ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_psaux --profile=LinuxRedhat8_3_4_18_0-240x64 Volatility Foundation Volatility Framework 2.6.1 Pid Uid Gid Arguments 1 0 0 /usr/lib/systemd/systemd --switched-root --system --deserialize 18 2 0 0 [kthreadd] 3 0 0 [rcu_gp] 4 0 0 [rcu_par_gp] 861 0 0 /usr/libexec/platform-python -Es /usr/sbin/tuned -l -P 869 0 0 /usr/bin/rhsmcertd 875 0 0 /usr/libexec/sssd/sssd_be --domain implicit_files --uid 0 --gid 0 --logger=files 878 0 0 /usr/libexec/sssd/sssd_nss --uid 0 --gid 0 --logger=files \u003c\u003c 删节 \u003e\u003e 11064 89 89 qmgr -l -t unix -u 227148 0 0 [kworker/0:0] 227298 0 0 -bash 227374 0 0 [kworker/u2:1] 227375 0 0 [kworker/0:2] 227884 0 0 [kworker/0:3] 228573 0 0 insmod ./lime-4.18.0-240.el8.x86_64.ko path=../RHEL8.3_64bit.mem format=lime 228576 0 0 $ 想要知道系统的网络状态吗？运行 linux_netstat 插件来找到在内存转储期间网络连接的状态： $ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_netstat --profile=LinuxRedhat8_3_4_18_0-240x64 Volatility Foundation Volatility Framework 2.6.1 UNIX 18113 systemd/1 /run/systemd/private UNIX 11411 systemd/1 /run/systemd/notify UNIX 11413 systemd/1 /run/systemd/cgroups-agent UNIX 11415 systemd/1 UNIX 11416 systemd/1 \u003c\u003c 删节 \u003e\u003e $ 接下来，使用 linux_mount 插件来看在内存转储期间哪些文件系统被挂载： $ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_mount --profile=LinuxRedhat8_3_4_18_0-240x64 Volatility Foundation Volatility Framework 2.6.1 tmpfs /sys/fs/cgroup tmpfs ro,nosuid,nodev,noexec cgroup /sys/fs/cgroup/pids cgroup rw,relatime,nosuid,nodev,noexec systemd-1 /proc/sys/fs/binfmt_misc autofs rw,relatime sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw,relatime /dev/mapper/rhel_kvm--03--guest11-root / xfs rw,relatime tmpfs /dev/shm tmpfs rw,nosuid,nodev selinuxfs /sys/fs/selinux selinuxfs rw,relatime \u003c\u003c 删节 \u003e\u003e cgroup /sys/fs/cgroup/net_cls,net_prio cgroup rw,relatime,nosuid,nodev,noexec cgroup /sys/fs/cgroup/cpu,cpuacct cgroup rw,relatime,nosuid,nodev,noexec bpf /sys/fs/bpf bpf rw,relatime,nosuid,nodev,noexec cgroup /sys/fs/cgroup/memory cgroup ro,relatime,nosuid,nodev,noexec cgroup /sys/fs/cgroup/cpuset cgroup rw,relatime,nosuid,nodev,noexec mqueue /dev/mqueue mqueue rw,relatime $ 好奇哪些内核模块被加载了吗？Volatility 也为这个提供了一个插件 linux_lsmod： $ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_lsmod --profile=LinuxRedhat8_3_4_18_0-240x64 Volatility Foundation Volatility Framework 2.6.1 ffffffffc0535040 lime 20480 ffffffffc0530540 binfmt_misc 20480 ffffffffc05e8040 sunrpc 479232 \u003c\u003c 删节 \u003e\u003e ffffffffc04f9540 nfit 65536 ffffffffc0266280 dm_mirror 28672 ffffffffc025e040 dm_region_hash 20480 ffffffffc0258180 dm_log 20480 ffffffffc024bbc0 dm_mod 151552 $ 想知道哪些文件被哪些进程打开了吗？使用 linux_bash 插件可以列出这些信息： $ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_bash --profile=LinuxRedhat8_3_4_18_0-240x64 -v Volatility Foundation Volatility Framework 2.6.1 Pid Name Command Time Command -------- -------------------- ------------------------------ ------- 227221 bash 2021-04-17 18:38:24 UTC+0000 lsmod 227221 bash 2021-04-17 18:38:24 UTC+0000 rm -f .log 227221 bash 2021-04-17 18:38:24 UTC+0000 ls -l /etc/zzz 227221 bash 2021-04-17 18:38:24 UTC+0000 cat ~/.vimrc 227221 bash 2021-04-17 18:38:24 UTC+0000 ls 227221 bash 2021-04-17 18:38:24 UTC+0000 cat /proc/817/cwd 227221 bash 2021-04-17 18:38:24 UTC+0000 ls -l /proc/817/cwd 227221 bash 2021-04-17 18:38:24 UTC+0000 ls /proc/817/ \u003c\u003c 删节 \u003e\u003e 227298 bash 2021-04-17 18:40:30 UTC+0000 gcc prt.c 227298 bash 2021-04-","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:3:4","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"访问 Linux 插件脚本位置 通过读取内存转储和处理这些信息，你可以获得更多的信息。如果你会 Python，并且好奇这些信息是如何被处理的，可以到存储所有插件的目录，选择一个你感兴趣的，并看看 Volatility 是如何获得这些信息的： $ ls volatility/plugins/linux/ apihooks.py common.py kernel_opened_files.py malfind.py psaux.py apihooks.pyc common.pyc kernel_opened_files.pyc malfind.pyc psaux.pyc arp.py cpuinfo.py keyboard_notifiers.py mount_cache.py psenv.py arp.pyc cpuinfo.pyc keyboard_notifiers.pyc mount_cache.pyc psenv.pyc aslr_shift.py dentry_cache.py ld_env.py mount.py pslist_cache.py aslr_shift.pyc dentry_cache.pyc ld_env.pyc mount.pyc pslist_cache.pyc \u003c\u003c 删节 \u003e\u003e check_syscall_arm.py __init__.py lsmod.py proc_maps.py tty_check.py check_syscall_arm.pyc __init__.pyc lsmod.pyc proc_maps.pyc tty_check.pyc check_syscall.py iomem.py lsof.py proc_maps_rb.py vma_cache.py check_syscall.pyc iomem.pyc lsof.pyc proc_maps_rb.pyc vma_cache.pyc $ $ 我喜欢 Volatility 的理由是他提供了许多安全插件。这些信息很难手动获取： linux_hidden_modules - Carves memory to find hidden kernel modules linux_malfind - Looks for suspicious process mappings linux_truecrypt_passphrase - Recovers cached Truecrypt passphrases Volatility 也允许你在内存转储中打开一个 shell，所以你可以运行 shell 命令来代替上面所有命令，并获得相同的信息： $ python2 vol.py -f ~/LiME/RHEL8.3_64bit.mem linux_volshell --profile=LinuxRedhat8_3_4_18_0-240x64 -v Volatility Foundation Volatility Framework 2.6.1 Current context: process systemd, pid=1 DTB=0x1042dc000 Welcome to volshell! Current memory image is: file:///root/LiME/RHEL8.3_64bit.mem To get help, type 'hh()' \u003e\u003e\u003e \u003e\u003e\u003e sc() Current context: process systemd, pid=1 DTB=0x1042dc000 \u003e\u003e\u003e ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:3:5","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"接下来的步骤 内存转储是了解 Linux 内部情况的好方法。试一试 Volatility 的所有插件，并详细研究它们的输出。然后思考这些信息如何能够帮助你识别入侵或安全问题。深入了解这些插件的工作原理，甚至尝试改进它们。如果你没有找到你想做的事情的插件，那就写一个并提交给 Volatility，这样其他人也可以使用它。 ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:4:0","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["Using Software"],"content":"参考 使用开源工具进行 Linux 内存取证 [1] Perform Linux memory forensics with this open source tool [2] ","date":"2021-05-26","objectID":"/article/2021/linux-memory-forensics/:4:1","tags":["linux","内存取证","Volatility","LiME","insmod"],"title":"使用开源工具进行 Linux 内存取证","uri":"/article/2021/linux-memory-forensics/"},{"categories":["收集与整理"],"content":"2021-05-25 今日技术分享 Go 中为什么应该使用接口 https://mp.weixin.qq.com/s/KqXI9ekYAZYd5oYmhqFH8Q 图解Go sync.Pool https://mp.weixin.qq.com/s/aiOjUcN89nxwEUJzVNkl3A 自制文件系统 — 01 文件系统的样子 https://mp.weixin.qq.com/s/0FpQGDzFh_D7IJi6z7oXjg 深入 Go 中各个高性能 JSON 解析库 https://mp.weixin.qq.com/s/FBT5QN_Pja6vRntWY0wFeA 【预告】理论结合实践详解 b+ 树存储引擎（innodb、boltdb、buntdb） https://mp.weixin.qq.com/s/lAD6GmqjElmgXduSDA6kAg 懂得取舍才是缓存设计的真谛 https://mp.weixin.qq.com/s/CWV_rssaz3fTvi7AqEo92w 详解 Go 空结构体的 3 种使用场景 https://mp.weixin.qq.com/s/zbYIdB0HlYwYSQRXFFpqSg 配置化系统中的图模型 https://mp.weixin.qq.com/s/ZDW9mg_iYI6a8dkpo31Sdw 曹大带我学 Go（2）—— 迷惑的 goroutine 执行顺序 https://mp.weixin.qq.com/s/WWfm7Ui7g_gGlb8XkIZigg Go可用性(六) 熔断 https://mp.weixin.qq.com/s/b5Wi1TqFVCCmpjvfmUcQBQ 懂得取舍才是缓存设计的真谛 https://my.oschina.net/kevwan/blog/5056791 immudb v1.0 released https://www.codenotary.com/blog/immudb-release-1-0/ 你知道 Goroutine 是怎么来的吗？ https://mp.weixin.qq.com/s/DZavvanPnRwZMPU-5_wOeg 分布式链路跟踪中的 traceid 和 spanid 代表什么？ https://mp.weixin.qq.com/s/eKbFYwnH4vwgWm6_5sWs3w Dart Flutter 数据库 ObjectBox 1.0 版本 https://objectbox.io/dart-flutter-database-1_0-release/ 区块链可扩展性的局限 by 以太坊之父 https://vitalik.ca/general/2021/05/23/scaling.html 学习golang.org/x/sync下的包 https://ketansingh.me/posts/golang-x-sync/ 什么是可观察性 by Brendan Gregg http://www.brendangregg.com/blog/2021-05-23/what-is-observability.html Uber API网关的架构 https://eng.uber.com/architecture-api-gateway/ Uber API网关的演化 https://eng.uber.com/gatewayuberapi/ 在Go 1.16中如何嵌入静态资源文件 https://www.josephspurrier.com/how-to-embed-assets-in-go-1-16 Zadig：一个云原生、分布式、面向开发者的持续交付产品 https://github.com/koderover/zadig 给Kubernetes服务提供人类可懂的注解 https://kubernetes.io/blog/2021/04/20/annotating-k8s-for-humans/ Kubernetes应用程序的预检工具，并支持捆绑其他框架 https://github.com/replicatedhq/troubleshoot 使用kubernetes自定义资源(CRD)来管理我们的短暂环境 https://medium.com/beamdental/using-kubernetes-custom-resources-to-manage-our-ephemeral-environments-f298610893e1 使用Kubeadm在Ubuntu virtualbox上安装kubernetes集群 https://kosyfrances.com/kubernetes-cluster/ MySQL索引失效的底层原理 https://www.yuque.com/u2278269/gq5x74/sotkoz goroutine 执行顺序 https://mp.weixin.qq.com/s/WWfm7Ui7g_gGlb8XkIZigg 调度本质 https://mp.weixin.qq.com/s/5E5V56wazp5gs9lrLvtopA ","date":"2021-05-25","objectID":"/article/2021/go20210525/:0:0","tags":["技术分享","Golang"],"title":"Go20210525 今日技术分享","uri":"/article/2021/go20210525/"},{"categories":["收集与整理"],"content":"2021-05-24 今日技术分享 2021 年 5 月程序员工资排行：Go的工资满意吗？ https://mp.weixin.qq.com/s/cX25jSXo_wI22x2CKWW2Cg Go语言爱好者周刊：第 96 期 — 用 Go 实现一个计算器 https://mp.weixin.qq.com/s/yKRK4cfcdJcdwh2u0tyi7w 源码级剖析new和make怎么用！ https://mp.weixin.qq.com/s/ClbdoJXPWlq0hP9ABzVJvQ 在 EKS 中实现基于 Promtail + Loki + Grafana 容器日志解决方案 https://mp.weixin.qq.com/s/Qotk0CNgsBrFy0Ot7AL0jQ 代码重构的原则和技巧 https://mp.weixin.qq.com/s/HlbURQBw35RUJOu5XEX9KA 深度探索Go语言（四）：包装方法 https://mp.weixin.qq.com/s/9KCIaWfka-z5GDEHfAnKzg 深度探索Go语言（五）：包装方法 https://mp.weixin.qq.com/s/yZpnWXfnrSPfAa6qXM4CUw 一本开源免费的 Go 进阶图书 https://mp.weixin.qq.com/s/C2y8WqjVnLXHRMYJa-hqvA 分布式链路跟踪中的traceid和spanid代表什么？ https://mp.weixin.qq.com/s/eKbFYwnH4vwgWm6_5sWs3w 使用gRPC改造Kubernetes通信 https://mp.weixin.qq.com/s/MUW_CcsXYH1RXQGfLcb6yw 什么技巧，能优化 Go 服务 40% 以上的 CPU？ https://mp.weixin.qq.com/s/1BUAy84aXOxWwHy0ZYOD1Q 五月第三股来袭，文末有彩蛋哦！ https://mp.weixin.qq.com/s/a-iNzl9kggG-oY28ShAhxw API 网关架构 https://eng.uber.com/architecture-api-gateway/ 使用 Go 语言对网页进行截屏 https://www.youtube.com/watch?v=4hrFtF6OuiM Go 并发同步包 https://ketansingh.me/posts/golang-x-sync/ 深入 Go 中各个高性能 JSON 解析库 https://www.luozhiyun.com/archives/535 lima: 一款 Go 语言实现的 Linux 虚拟机 https://github.com/AkihiroSuda/lima 初探Go代码混淆 https://paper.seebug.org/1586/ 有争议的Go错误处理 https://dev.to/hlmerscher/the-controversial-go-way-of-handling-errors-2ka1 高性能、自我托管的通讯和邮件列表管理器-listmonk发布1.0 https://github.com/knadh/listmonk Go错误处理：从拒绝到接受 https://evilmartians.com/chronicles/errors-in-go-from-denial-to-acceptance 一个简单而完整的功能开关解决方案 https://github.com/thomaspoignant/go-feature-flag Go实现的短链接应用 https://github.com/go-awesome/shortlink 我们如何在CockroachDB中建立可扩展的空间数据和空间索引 https://www.cockroachlabs.com/blog/how-we-built-spatial-indexing/ CI/CD pipeline的pipeline模式 https://harness.io/blog/devops/deployment-pipeline-patterns/ 对Postgres 14的早期看法：性能和监控的改进 https://pganalyze.com/blog/postgres-14-performance-monitoring 如何建立你作为开发者的个人品牌 https://www.freecodecamp.org/news/build-your-personal-brand-as-a-developer/ Rust进入Linux内核开发？ https://lwn.net/Articles/853423/ 知识图谱入门 http://ai.stanford.edu/blog/introduction-to-knowledge-graphs/ ","date":"2021-05-24","objectID":"/article/2021/go20210524/:0:0","tags":["技术分享","Golang"],"title":"Go20210524 今日技术分享","uri":"/article/2021/go20210524/"},{"categories":["Using Software"],"content":" 很少有 Unix 命令像 sed、grep 和 awk 一样出名，它们经常组合在一起，可能是因为它们具有奇怪的名称和强大的文本解析能力。它们还在一些语法和逻辑上有相似之处。虽然它们都能用于文本解析，但都有其特殊性。本文研究 sed 命令，它是一个 流编辑器。 ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:0","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["Using Software"],"content":"安装 sed 如果你使用的是 Linux、BSD 或 macOS，那么它们已经安装了 GNU 的或 BSD 的 sed。这些是原始 sed 命令的独特重新实现。虽然它们很相似，但也有一些细微的差别。本文已经在 Linux 和 NetBSD 版本上进行了测试，所以你可以使用你的计算机上找到的任何 sed，但是对于 BSD sed，你必须使用短选项（例如 -n 而不是 –quiet）。 GNU sed 通常被认为是功能最丰富的 sed，因此无论你是否运行 Linux，你可能都想要尝试一下。如果在 Ports 树中找不到 GNU sed（在非 Linux 系统上通常称为 gsed），你可以从 GNU 网站 下载源代码。 安装 GNU sed 的好处是，你可以使用它的额外功能，但是如果需要可移植性，还可以限制它以遵守 sed 的 POSIX 规范。 MacOS 用户可以在 MacPorts 或 Homebrew 上找到 GNU sed。 在 Windows 上，你可以通过 Chocolatey 来 安装 GNU sed。 ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:1","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["Using Software"],"content":"了解模式空间和保留空间 sed 一次只能处理一行。因为它没有可视化模式，所以会创建一个 模式空间，这是一个内存空间，其中包含来自输入流的当前行（删除了尾部的任何换行符）。填充模式空间后，sed 将执行你的指令。当命令执行完时，sed 将模式空间中的内容打印到输出流，默认是 标准输出，但是可以将输出重定向到文件，甚至使用 --in-place=.bak 选项重定向到同一文件。 然后，循环从下一个输入行再次开始。 为了在遍历文件时提供一点灵活性，sed 还提供了保留空间（有时也称为 保留缓冲区），即 sed 内存中为临时数据存储保留的空间。你可以将保留空间当作剪贴板，实际上，这正是本文所演示的内容：如何使用 sed 复制/剪切和粘贴。 首先，创建一个示例文本文件，其内容如下： Line one Line three Line two ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:2","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["Using Software"],"content":"复制数据到保留空间 要将内容放置在 sed 的保留空间，使用 h 或 H 命令。小写的 h 告诉 sed 覆盖保留空间中的当前内容，而大写的 H 告诉 sed 将数据追加到保留空间中已经存在的内容之后。 单独使用，什么都看不到： $ sed --quiet -e '/three/ h' example.txt $ --quiet（缩写为 -n）选项禁止显示所有输出，但 sed 执行了我的搜索需求。在这种情况下，sed 选择包含字符串 three 的任何行，并将其复制到保留空间。我没有告诉 sed 打印任何东西，所以没有输出。 ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:3","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["Using Software"],"content":"从保留空间复制数据 要了解保留空间，你可以从保留空间复制内容，然后使用 g 命令将其放入模式空间，观察会发生什么： $ sed -n -e '/three/h' -e 'g;p' example.txt Line three Line three 第一个空白行是因为当 sed 第一次复制内容到模式空间时，保留空间为空。 接下来的两行包含 Line three 是因为这是从第二行开始的保留空间。 该命令使用两个唯一的脚本（-e）纯粹是为了帮助提高可读性和组织性。将步骤划分为单独的脚本可能会很有用，但是从技术上讲，以下命令与一个脚本语句一样有效： $ sed -n -e '/three/h ; g ; p' example.txt Line three Line three ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:4","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["Using Software"],"content":"将数据追加到模式空间 G 命令会将一个换行符和保留空间的内容添加到模式空间。 $ sed -n -e '/three/h' -e 'G;p' example.txt Line one Line three Line three Line two Line three 此输出的前两行同时包含模式空间（Line one）的内容和空的保留空间。接下来的两行与搜索文本（three）匹配，因此它既包含模式空间又包含保留空间。第三行的保留空间没有变化，因此在模式空间（Line two）的末尾是保留空间（仍然是 Line three）。 ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:5","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["Using Software"],"content":"用 sed 剪切和粘贴 现在你知道了如何将字符串从模式空间转到保留空间并再次返回，你可以设计一个 sed 脚本来复制、删除，然后在文档中粘贴一行。例如，将示例文件的 Line three 挪至第三行，sed 可以解决这个问题： $ sed -n -e '/three/ h' -e '/three/ d' \\ -e '/two/ G;p' example.txt Line one Line two Line three 第一个脚本找到包含字符串 three 的行，并将其从模式空间复制到保留空间，替换当前保留空间中的任何内容。 第二个脚本删除包含字符串 three 的任何行。这样就完成了与文字处理器或文本编辑器中的 剪切 动作等效的功能。 最后一个脚本找到包含字符串 two 的行，并将保留空间的内容_追加_到模式空间，然后打印模式空间。 任务完成。 ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:6","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["Using Software"],"content":"使用 sed 编写脚本 再说一次，使用单独的脚本语句纯粹是为了视觉和心理上的简单。剪切和粘贴命令作为一个脚本同样有效： $ sed -n -e '/three/ h ; /three/ d ; /two/ G ; p' example.txt Line one Line two Line three 它甚至可以写在一个专门的脚本文件中： #!/usr/bin/sed -nf /three/h /three/d /two/ G p 要运行该脚本，将其加入可执行权限，然后用示例文件尝试： $ chmod +x myscript.sed $ ./myscript.sed example.txt Line one Line two Line three 当然，你需要解析的文本越可预测，则使用 sed 解决问题越容易。发明 sed 操作（例如复制和粘贴）的“配方”通常是不切实际的，因为触发操作的条件可能因文件而异。但是，你对 sed 命令的使用越熟练，就越容易根据需要解析的输入来设计复杂的动作。 重要的事情是识别不同的操作，了解 sed 何时移至下一行，并预测模式和保留空间包含的内容。 sed 很复杂。虽然它只有十几个命令，但它灵活的语法和原生功能意味着它充满了无限的潜力。 ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:7","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["Using Software"],"content":"参考 How to use the Linux sed command [1] 使用 sed 命令进行复制、剪切和粘贴 [2] ","date":"2021-05-24","objectID":"/article/2021/linux_sed/:0:8","tags":["sed","linux","Mac","GNU sed"],"title":"使用 sed 命令进行复制、剪切和粘贴","uri":"/article/2021/linux_sed/"},{"categories":["收集与整理"],"content":"2021-05-23 今日技术分享 用Go实现一个直播系统难吗？看看这个开源项目 https://mp.weixin.qq.com/s/5YPp7WFgVfPlGxim7tmQ5A Go语言数据争用与race原理 https://mp.weixin.qq.com/s/gGGg6wqQX5b1kEOeRbTQlA Go 标准库之 unsafe 包详解 https://mp.weixin.qq.com/s/Pj4Q_8sj2pCmXe2cHNqdvw Go - 开箱即用，WEB 界面一键安装，没有项目经验，可以拿这个练手 https://mp.weixin.qq.com/s/6RlAb7iWc3Tj6g7ttiBoRQ Loki 源码分析之日志写入 https://mp.weixin.qq.com/s/9BKZvNANqGJwziygytJ1ag 无限缓冲的channel(1) https://mp.weixin.qq.com/s/ETfrSqQczbW2SnaFjoUx0A 基于 Kubernetes 的微服务项目设计与实现 https://mp.weixin.qq.com/s/BjDx-pDQsuj6p_X01Vw92g 假如 Go 能说话，听听 GMP 的心声 https://mp.weixin.qq.com/s/Tgf-JU9YDume4jRHex65NA 利用 eBPF 支撑大规模 Kubernetes Service https://mp.weixin.qq.com/s/BJHzU4LxLdLnNzOnAqIptg Golang 中的适配器设计模式 https://www.smartscribs.com/adapter-design-pattern-in-golang/ 假如 Go 能说话，听听 GMP 的心声 https://mp.weixin.qq.com/s/Tgf-JU9YDume4jRHex65NA 小函数的调用开销需要考虑吗? https://mp.weixin.qq.com/s/nW0Cye1G_A72fm7MuBAM1A ","date":"2021-05-24","objectID":"/article/2021/go20210523/:0:0","tags":["技术分享","Golang"],"title":"Go20210523 今日技术分享","uri":"/article/2021/go20210523/"},{"categories":["收集与整理"],"content":"2021-05-21 今日技术分享 优化 Golang 服务来减少 40% 以上的 CPU https://mp.weixin.qq.com/s/dgVv6p8HQtc-krPGEdU2cQ fuckdb 新功能上线，开箱即用、更加强大的代码生成器 https://mp.weixin.qq.com/s/ysOlv8xsc7wF7cPcV5pu7g Go 面试官问我如何实现面向对象？ https://mp.weixin.qq.com/s/2x4Sajv7HkAjWFPe4oD96g 一文搞懂缓存系统稳定性 https://mp.weixin.qq.com/s/eNLB1BKZi4L3aNxbL0TqWQ kubernetes 平台开发者的几个小技巧 https://mp.weixin.qq.com/s/RVYJd_3xzDps-1xFwtl01g 周刊题解：常量表达式这个规则应该了解下 https://mp.weixin.qq.com/s/8fG0OMvwKziMSRs8bZFj2Q 企业微信万亿级日志检索系统 https://mp.weixin.qq.com/s/opxvlddsSQctb3nwcxaW_g 曹大带我学 Go（1）——调度的本质 https://mp.weixin.qq.com/s/5E5V56wazp5gs9lrLvtopA 初探 Go 代码混淆 https://mp.weixin.qq.com/s/q9xUFQ7HdHAis70WrFHuOQ 优化 Golang 服务减少 40% 以上的 CPU https://mp.weixin.qq.com/s/dgVv6p8HQtc-krPGEdU2cQ Go 实现 bridge 设计模式 https://www.smartscribs.com/bridge-design-pattern-in-golang/ Go 模板引擎 templ https://adrianhesketh.com/2021/05/18/introducing-templ/ 使用 Viper 和 Consul 配置 Go 应用 https://bencane.com/2021/05/18/using-viper-with-consul-to-configure-go-apps/ 实现无限缓存的channel https://colobu.com/2021/05/11/unbounded-channel-in-go/ pprof++: 一个带有硬件监控的 Go Profiler[译] https://mp.weixin.qq.com/s/-BSzD_wIEjHnHbs0xnsHXA istio 1.10发布，让StatefulSet使用起来更容易 https://istio.io/latest/blog/2021/statefulsets-made-easier/ templ：一个可用于go web的新模板引擎 https://adrianhesketh.com/2021/05/18/introducing-templ/ Go实现bridge设计模式 https://www.smartscribs.com/bridge-design-pattern-in-golang/ Kubernetes The Hard Way(aws版) https://github.com/prabhatsharma/kubernetes-the-hard-way-aws 用于在k8s上创建和管理postgresql数据库的k8s operator https://github.com/reactive-tech/kubegres 服务网格战争：和istio说byebye https://medium.com/polymatic-systems/service-mesh-wars-goodbye-istio-b047d9e533c7#--responses 你的技术项目需要Go时的5个场景 https://hackernoon.com/lets-go-5-use-cases-when-you-need-golang-for-your-tech-project-wp1931r0 ","date":"2021-05-22","objectID":"/article/2021/go20210521/:0:0","tags":["技术分享","Golang"],"title":"Go20210521 今日技术分享","uri":"/article/2021/go20210521/"},{"categories":null,"content":"请扫下方二维码打赏一杯咖啡。 多少不重要，1元也是支持 -- ","date":"2021-05-19","objectID":"/donations/:0:0","tags":null,"title":"捐助","uri":"/donations/"},{"categories":["收集与整理"],"content":"2021-05-18 今日技术分享 也许是你从来没用过的利器：GODEBUG https://mp.weixin.qq.com/s/lqOs34aMs7AYCxM_Jv0Hug 从0开发上线一个web项目（下） https://mp.weixin.qq.com/s/W5lHCgA_SzzyCoDaHDmz1Q 如何打造高性能的 Go 缓存库 https://mp.weixin.qq.com/s/G8LJ1HBuWoQfWV2dILi6Rg 【本周四预告】JetBrains GoLand 2021.1 新特性介绍 https://mp.weixin.qq.com/s/9DbBwdkBvECl11jSd-hbYw 用 Go struct 不能犯的一个低级错误！ https://mp.weixin.qq.com/s/EKbsUwLABjpadxPZ9AJGTg Go语言中new和make你使用哪个来分配内存？ https://mp.weixin.qq.com/s/XJ9O9O4KS3LbZL0jYnJHPg 同步secret和config到指定namespace https://mp.weixin.qq.com/s/i1fI58MhbWnPx7RFftLXkg 缓存数据一致性 - 架构师峰会演讲实录 https://mp.weixin.qq.com/s/DhIv9RACxa5igJTYg4N1mA kubebuilder 进阶: 源码分析 https://mp.weixin.qq.com/s/mlpNUwoqcNdT0kAowb_zrQ 咱Gopher好香啊，输入法、搜索Top行业招Gopher，还不快到碗里来？ https://mp.weixin.qq.com/s/HY4CpoPqXroMhJJ250quZQ 如何管理多版本的 go https://lakefs.io/managing-multiple-go-versions-with-go/ 一个 SQL 数据库只使用了 2000 行 golang 代码并且没有任何第三方依赖 https://github.com/auxten/go-sqldb 使用 go 开发一个监控剪贴板的服务 https://www.reddit.com/r/golang/comments/ncsnj2/monitoring_clipboard_as_service_with_go/ Gorm 复杂关系举例 https://github.com/harranali/gorm-relationships-examples 写了 500，000 行 go 代码之后 https://blog.khanacademy.org/half-a-million-lines-of-go GopherChina 全部日程出炉 https://gc.gocn.vip/ Go http应用的错误处理 https://www.joeshaw.org/error-handling-in-go-http-applications/ 使用 Open Telemetry为Go服务自动埋点 https://varunksaini.com/auto-instrument-open-telemetry-go/ 关于（过早）优化的思考 https://www.tnotes.dev/posts/thoughts-on-premature-optimization 使用2000行go代码实现的sql关系数据库 https://github.com/auxten/go-sqldb/blob/main/README-zh.md 使用Go管理多个Go版本 https://lakefs.io/managing-multiple-go-versions-with-go/ Go算法基础 https://yourbasic.org/algorithms/ 2021年最适合初学者学习的4种编程语言 https://qvault.io/news/top-coding-languages-for-beginners/ 哪些公司使用了Go（按领域) https://www.softkraft.co/companies-using-golang/ 面向云原生企业的统一事件驱动架构 https://thenewstack.io/unified-event-driven-architecture-for-the-cloud-native-enterprise/ Harbor仓库中锁定镜像避免误删的简便方法 https://mp.weixin.qq.com/s/sj6Nj9etH-Z4B7GPjHOZng 从几百个生产环境总结出的Redis性能问题排查解决手册 https://mp.weixin.qq.com/s/WcY-h_vxXVca94Xnw0Wrgg MySQL一条语句的执行 https://www.yuque.com/u2278269/gq5x74/ubr2zr kafka知识导图 https://processon.com/view/5fff01bb6376897ae0b610ff#map go luki 日志报警 https://mp.weixin.qq.com/s/wO0w1f8ptZf4Rv1KQ6I1sw ","date":"2021-05-18","objectID":"/article/2021/go20210518/:0:0","tags":["技术分享","Golang","Gorm","Mysql"],"title":"Go20210518 今日技术分享","uri":"/article/2021/go20210518/"},{"categories":["收集与整理"],"content":"2021-05-17 今日技术分享 单机内存内缓存怎么做？go-cache 了解下 https://mp.weixin.qq.com/s/LzfLySMPtbCO91q87UKRcQ Go语言爱好者周刊：第 95 期 — 自信点，这道题一定会 https://mp.weixin.qq.com/s/yBUlIhhGNSDUv7_J8Y0NmA 从0写一个 Go Web 服务 (上) https://mp.weixin.qq.com/s/vNUBJERfgmeV_qk_cdFoVQ 高性能 Go 代码工坊（Part7) https://mp.weixin.qq.com/s/ptUH-9dvRlA558SNakIbFQ 使用 Loki 进行日志报警(二) https://mp.weixin.qq.com/s/wO0w1f8ptZf4Rv1KQ6I1sw 用Kubernetes搭建Etcd集群和WebUI https://mp.weixin.qq.com/s/AkIvkW22dvqcdFXkiTpv8Q Leetcode:House Robber II https://mp.weixin.qq.com/s/-mUMeklJdajaSxlpqJB0MA 深度探索Go语言（三）：动态派发 https://mp.weixin.qq.com/s/XLj_AKqETZy4cUBNiNZPBw 通过例子，让你彻底搞懂微服务的演化过程 https://mp.weixin.qq.com/s/wWBlrjUUn-tx0v7ZTkha1g 5月你好，第二股来喽 https://mp.weixin.qq.com/s/onnAaqM8GoaphEtZ-KHO6g http.Client 的连接行为控制详解 https://mp.weixin.qq.com/s/2fAj_8vEQYLxddllqjsYFg unsafe.Pointer 和 uintptr 的区别和联系 https://mp.weixin.qq.com/s/l-ZQws4SH4QsvMhmJddiww Common anti-patterns in Go https://mp.weixin.qq.com/s/k-Use24-UCB3y_hV0tihVg 详解 http.Handle 与 http.HandleFunc 区别 https://ckarchive.com/b/75u7h8h730p5 i/o timeout ， 希望你不要踩到这个 net/http 包的坑 https://mp.weixin.qq.com/s/AKhRFKgs-I46Lnqhbk6Iog 当GOPATH与go module相遇时的混乱情况 https://arxiv.org/pdf/2102.12105.pdf 使用NATS作为http.RoundTripper的实现 https://github.com/ripienaar/nats-roundtripper 油管视频：用net包建立一个DIY代理 https://www.youtube.com/watch?v=J4J-A9tcjcA 使用Telepresence 2进行Kubernetes调试和本地开发 https://codefresh.io/kubernetes-tutorial/telepresence-2-local-development/ Kubernetes the Hard Way (azure版) https://github.com/carlosonunez/kubernetes-the-hard-way-on-azure 像top那样的容器度量数据采集工具 https://github.com/bcicen/ctop UTF-8历史 by Rob Pike http://doc.cat-v.org/bell_labs/utf-8_history 10分钟内学会go https://www.codingholygrail.com/learn-go-in-10-mins 为Go项目逐步构建优化的Docker镜像 https://www.codingholygrail.com/build-docker-image-for-golang-projects 软件测试的角色 https://blog.thundra.io/4-software-testing-roles 在Rust中做不了的事情（以及该怎么做） https://blog.logrocket.com/what-you-cant-do-in-rust-and-what-to-do-instead/ ","date":"2021-05-17","objectID":"/article/2021/go20210517/:0:0","tags":["技术分享","Golang","Rust"],"title":"Go20210517 今日技术分享","uri":"/article/2021/go20210517/"},{"categories":["收集与整理"],"content":"2021-05-16 今日技术分享 面试官：说说unsafe.Pointer和uintptr的区别和联系 https://mp.weixin.qq.com/s/l-ZQws4SH4QsvMhmJddiww http.Client的连接行为控制详解 https://mp.weixin.qq.com/s/2fAj_8vEQYLxddllqjsYFg 你不知道的 Go 之 slice https://mp.weixin.qq.com/s/-VRyRg9d-65lNTFRPvoCLw go每日新闻(2021-05-14)——Go语言内存分配 https://mp.weixin.qq.com/s/wembkRjdv8IErolT4IpnCg 说说常见数据库及中间件的主从设计 https://mp.weixin.qq.com/s/EXTdTsOcCuWpaNXOATpGFQ i/o timeout ， 希望你不要踩到这个net/http包的坑 https://mp.weixin.qq.com/s/AKhRFKgs-I46Lnqhbk6Iog Common anti-patterns in Go https://mp.weixin.qq.com/s/k-Use24-UCB3y_hV0tihVg 服务注册中心和配置中心的选择 https://mp.weixin.qq.com/s/4gOoYI9GsfauCcDoq_6Wxw golang 并发底层实现竟然都是它！！！ https://mp.weixin.qq.com/s/7BeLEzqmA1IR-rjVig0Qbw golang 编写的 GBA 模拟器 https://github.com/pokemium/magia 漫谈 Go 语言编译器（01） https://mp.weixin.qq.com/s/0q0k8gGX56SBKJvfMquQkQ semaphore 的原理与实现 https://mp.weixin.qq.com/s/GB649snXQ5rDF2BXO9V55Q pprof++：具有硬件性能监控的 Go 探查器 https://eng.uber.com/pprof-go-profiler 对cni benchmark中Cilium网络性能的理解 https://cilium.io/blog/2021/05/11/cni-benchmark 编程与写作 by redis之父 http://antirez.com/news/135 fly.io的Prometheus度量采集实践 https://fly.io/blog/measuring-fly/ go实现的GBA游戏模拟器 https://github.com/pokemium/magia 使用go构建rest server：身份验证 https://eli.thegreenplace.net/2021/rest-servers-in-go-part-6-authentication 使用go和无服务框架构建OKR跟踪工具 https://arjitjaiswal.medium.com/building-okayar-part-1-how-it-started-back-end-crud-serverless-lambda-api-in-go-3248ae93c97c 了解如何使用Rancher的kim和K3s更快地构建函数 https://www.openfaas.com/blog/kim/ 减少Kubernetes的AWS账单的8个最佳做法 https://cast.ai/blog/8-best-practices-to-reduce-your-aws-bill-for-kubernetes Go实现的bloom filter包 https://github.com/bits-and-blooms/bloom iptables: kubernetes service是如何将流量打到pod中的 https://dustinspecker.com/posts/iptables-how-kubernetes-services-direct-traffic-to-pods/ 经过8年努力，scala 3终于发布了！ https://scala-lang.org/blog/2021/05/14/scala3-is-here.html 在大规模数据中心运行BGP协议 by facebook https://engineering.fb.com/2021/05/13/data-center-engineering/bgp/ ","date":"2021-05-16","objectID":"/article/2021/go20210516/:0:0","tags":["技术分享","Golang"],"title":"Go20210516 今日技术分享","uri":"/article/2021/go20210516/"},{"categories":["收集与整理"],"content":"今日技术分享 Uber 使用 Go 的规模这么大？！都自己定制的 Go 编译器了 https://mp.weixin.qq.com/s/oJ6BD8AXbKKe_OBj9kCx6A Go：如何优雅地实现并发编排任务 https://mp.weixin.qq.com/s/5RhaUEk33kf4LkcZphyt_g grpc Go Client 源码分析 https://mp.weixin.qq.com/s/SQ22u7l17mWl2nQlSqvGXg 使用 Loki 进行日志报警(一) https://mp.weixin.qq.com/s/s4g_lg9k1QjGa-GLRfZtEg Go 程序运行时数据统计的可视化工具 statsviz https://mp.weixin.qq.com/s/gaQhIo544VHYeGcKq34GIw Rust 劝退系列 06：常量 https://mp.weixin.qq.com/s/y5WJbP8qcvdm4WASXEEibQ semaphore 的原理与实现 https://mp.weixin.qq.com/s/GB649snXQ5rDF2BXO9V55Q kubebuilder 进阶: webhook https://mp.weixin.qq.com/s/CFggTa7E91Rf1N1EZZpOBA 【直播】5.15（周六）9:00 聊聊风控系统构建演进过程~欢迎扫码报名 https://mp.weixin.qq.com/s/KctKKf0VUCt0AppLyEEtrg 为什么 Go map 和 slice 是非线性安全的？ https://mp.weixin.qq.com/s/TzHvDdtfp0FZ9y1ndqeCRw 深度剖析 Go 的 nil https://mp.weixin.qq.com/s/wwpDqXZ8VsDL0N2IKjJNDA 熔断原理与实现 Golang 版 https://blog.51cto.com/u_15175878/2774901 Golang 语言中怎么拦截系统信号和优雅退出 http server？ https://mp.weixin.qq.com/s/yvK42TntdzAI9S6kBFFZ-w 关于如何组织 Go 项目结构的思考 https://changelog.com/posts/on-go-application-structure kubernetes 问题排查: 系统时间被修改导致 sandbox 冲突 https://mp.weixin.qq.com/s/DJMrRBP237BE69pTyrKmnQ 可汗学院 Go 语言实践 https://blog.khanacademy.org/half-a-million-lines-of-go/ 编写50w行Go代码之后：可汗学院工程师的Go感悟 https://blog.khanacademy.org/half-a-million-lines-of-go/ 为什么你应该在你的Go服务器处理程序中使用errgroup.WithContext https://bionic.fullstory.com/why-you-should-be-using-errgroup-withcontext-in-golang-server-handlers/ BuildKit CLI for kubectl是docker build的替代品 https://container-registry.com/posts/productivity-lift-buildkit-cli-for-kubectl/ docker和kubernetes是如何创建ip地址的 https://dustinspecker.com/posts/how-do-kubernetes-and-docker-create-ip-addresses/ Go语言eBPF入门 https://networkop.co.uk/post/2021-03-ebpf-intro/ k8s集群中如何切换容器运行时 https://dev.to/stack-labs/how-to-switch-container-runtime-in-a-kubernetes-cluster-1628 gohugo vs. jekyll，哪个才是你的菜 https://draft.dev/learn/posts/hugo-vs-jekyll-which-is-right-for-your-blog mk48: go实现的开源游戏项目 https://github.com/SoftbearStudios/mk48 如何构建良好的远程工作文化 https://liuandrewk.medium.com/how-to-build-a-good-remote-work-culture-5f482cd4f1dd 油管视频：git和github教程 https://www.youtube.com/watch?v=RGOj5yH7evk Go语言内存分配 https://mp.weixin.qq.com/s/Hm8egXrdFr5c4-v--VFOtg 用100行Go代码实现容器 https://medium.com/@ssttehrani/containers-from-scratch-with-golang-5276576f9909 图解kafka架构原理 https://mp.weixin.qq.com/s/4zH9kfuC6FYh4hYo0CLtTg ","date":"2021-05-15","objectID":"/article/2021/go20210515/:0:0","tags":["技术分享","Golang"],"title":"Go20210515 今日技术分享","uri":"/article/2021/go20210515/"},{"categories":["收集与整理"],"content":"今日技术分享 面试官：聊聊 defer 的工作原理。。。 https://mp.weixin.qq.com/s/oWlQU9c9z11CHdOwOMOHxA 深度解密Go语言之基于信号的抢占式调度 https://mp.weixin.qq.com/s/xdhv24Lh-7smOT5ESw2dBw 聊聊如何做技术分享 https://mp.weixin.qq.com/s/iRe1aGShDBeVhLhOSHwbMQ Uber 使用 Go 的规模这么大？！都自己定制的 Go 编译器了 https://mp.weixin.qq.com/s/MO0WNlwecDVLx4QfWklamA 如何让消息队列达到最大吞吐量？ https://mp.weixin.qq.com/s/Y1qWYdzNs8EXCFu_DtBH9g 薪资比肩北上广，你会考虑回老家吗？急招哦 https://mp.weixin.qq.com/s/koCxSjX8tXMMY3Yn8c4KpA kubebuilder 进阶: 测试 https://mp.weixin.qq.com/s/tcLIx3E0LyRkNhPO0U8zmg 从0.5到1用golang上线一个web项目 https://mp.weixin.qq.com/s/ZqbDY3IjtH2s5_oeDvhQVQ 从0到0.5用golang写一个web项目 https://mp.weixin.qq.com/s/XXLFwlmOUaD7a3hftYCd2A 译文 Go 的抢占式调度 https://gocn.vip/topics/12062 深度解密 Go 语言之基于信号的抢占式调度 https://mp.weixin.qq.com/s/ESfbVoCGUIdpwFOfGyvz1w 使用 Golang 的交叉编译 https://linux.cn/article-13385-1.html Go 无分支编码 https://mattnakama.com/blog/go-branchless-coding/ Go 数组比切片好在哪？ https://mp.weixin.qq.com/s/zp1vdhGukEYKpzAdPt--Mw minikube v1.20.0版本的一个bug https://t.zsxq.com/RbEufqr 关于Go项目代码结构的思考 https://changelog.com/posts/on-go-application-structure Kubernetes的三个租户模型 https://kubernetes.io/blog/2021/04/15/three-tenancy-models-for-kubernetes/ 经典旧文：对go测试的崇拜 https://danmux.com/posts/the_cult_of_go_test/ Calico的可插拔式数据平面的重要性 https://thenewstack.io/the-importance-of-calicos-pluggable-data-plane/ 使用curl探索kubernetes https://blog.tilt.dev/2021/03/18/kubernetes-is-so-simple.html 用eStargz加快在各种工具上pull容器镜像的速度 https://medium.com/nttlabs/lazy-pulling-estargz-ef35812d73de Kubernetes中AWS NLB超时的一个奇怪的案例 https://build.thebeat.co/a-curious-case-of-aws-nlb-timeouts-in-kubernetes-522bd88a3399 为SQL数据库dolt构建fuzz testing https://www.dolthub.com/blog/2021-05-12-dolt-and-fuzz-testing/ 使用Go CDK(Cloud Development Kit )创建Elastic Kubernetes Service https://www.steveyackey.com/post/eks-cdk-go/ pause容器源码 https://mp.weixin.qq.com/s/2kkD6Dx40Ilu7HWpCe43hw MySQL 学习 https://mp.weixin.qq.com/s/sRFmW57KUY3yyyRkyw0L4A etcd 操作 boltdb 的优化实现 https://mp.weixin.qq.com/s/Cv1lagwtSkonQQes_0Sndw ","date":"2021-05-14","objectID":"/article/2021/go20210514/:0:0","tags":["技术分享","Golang"],"title":"Go20210514 今日技术分享","uri":"/article/2021/go20210514/"},{"categories":["收集与整理"],"content":"今日技术分享 Go：跨团队协作时如何共享对象 https://mp.weixin.qq.com/s/zJaruocUDSzld8ttDyawng template源码分析 https://mp.weixin.qq.com/s/HqcaFEXgQbcRyjYjI6oKGQ kubebuilder 实战: status \u0026 event https://mp.weixin.qq.com/s/JuRlClCX7TnQKaW-Rr3Z7g 如何优雅地实现并发编排任务 https://mp.weixin.qq.com/s/M88-VS_H7o754mw5Ra7BYg Prometheus 二次开发之 API 接口 https://mp.weixin.qq.com/s/K7ERtE2KKflYSA9KJOukYg 从TDSQL，看分布式数据库的技术之美 https://mp.weixin.qq.com/s/CbzlPmGJCQKi3UmvwjFC1Q Go Team Leader — rsc大神新开源了一个库，增强模板功能 https://mp.weixin.qq.com/s/3DFejimkPY9tg9QQL2QTqw Wow，联通数科也招Gopher了 https://mp.weixin.qq.com/s/tVY3AuUOYEnMKi7Km4eBCw Go 数组比切片好在哪？ https://mp.weixin.qq.com/s/zp1vdhGukEYKpzAdPt--Mw Go 缓存系列之 go-cache https://mp.weixin.qq.com/s/dKlfwJ69s3fUBWYIV57hyg Go 存储基础 — 内存结构体怎么写入文件？ https://mp.weixin.qq.com/s/mfNz7r76vZOOgiMSmuVeJA 深度解密Go语言之基于信号的抢占式调度 https://mp.weixin.qq.com/s/ESfbVoCGUIdpwFOfGyvz1w 实现无限缓存的 channel https://colobu.com/2021/05/11/unbounded-channel-in-go/ Go RIP 协议简单的模拟实现 https://segmentfault.com/a/1190000039984330 Golang 框架 gin 运行源码分析 https://mp.weixin.qq.com/s/D6Ls3fUZnmimg8EgBDuXcQ Golang MySQL 查询更轻松 https://mp.weixin.qq.com/s/Sdt_wYJCXepoUwIIy7h9yw golang 如何使用原生 RPC 及微服务简述 https://segmentfault.com/a/1190000039990286 Go并发：高级话题 https://t.zsxq.com/yJMRjiI pprof++: 带有硬件性能监控的Go性能剖析器 by uber https://eng.uber.com/pprof-go-profiler/ Kubernetes中混沌工程的开源解决方案 https://blog.flant.com/chaos-engineering-in-kubernetes-open-source-tools/ 用GoPacket对数据包进行捕获和程序化分析 https://blog.apnic.net/2021/05/12/programmatically-analyse-packet-captures-with-gopacket/ KrakenD：高性能API网关框架项目加入linux基金会 https://www.krakend.io/blog/krakend-framework-joins-the-linux-foundation/ 跳出Go module的泥潭 https://mp.weixin.qq.com/s/EndbbH0Cxw7jBmUOovs6Ew 在Kubernetes上用多容器pod扩展应用程序 https://learnk8s.io/sidecar-containers-patterns Popeye是一个实时扫描Kubernetes集群并报告部署资源和配置的潜在问题的工具 https://github.com/derailed/popeye 分布式账本技术（DLT）和数字凭证–完美的搭配 https://www.memberpass.com/2021/05/distributed-ledger-technology-dlt-and-digital-credentials-a-perfect-match/ 通过microsoft learn零基础学习Go编程语言 https://dev.to/azure/get-started-with-the-go-programming-language-with-microsoft-learn-no-experience-needed-1npg 通过AI和机器学习扩大网络防御 https://thenewstack.io/expanding-cyber-defense-through-ai-and-ml/ 云开发如何扛过大流量活动洪峰 https://mp.weixin.qq.com/s/WOhY_bTj213XP6tdUYQCZQ MySQL 学习 https://mp.weixin.qq.com/s/sRFmW57KUY3yyyRkyw0L4A 煎鱼 数组比切片好在哪里 https://mp.weixin.qq.com/s/zp1vdhGukEYKpzAdPt--Mw ","date":"2021-05-13","objectID":"/article/2021/go20210513/:0:0","tags":["技术分享","Golang"],"title":"Go20210513 今日技术分享","uri":"/article/2021/go20210513/"},{"categories":["Learn Swift","开发技能","编程经验","收集与整理"],"content":"Swift介绍 Swift 是一门开发 iOS, macOS, watchOS 和 tvOS 应用的新语言。 swift 是一种安全，快速和互动的编程语言。 swift 支持代码预览（playgrounds），这个特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。 Swift 通过采用现代编程模式来避免大量常见编程错误： 变量始终在使用前初始化。 检查数组索引超出范围的错误。 检查整数是否溢出。 可选值确保明确处理 nil 值。 内存被自动管理。 错误处理允许从意外故障控制恢复。 ","date":"2021-05-13","objectID":"/article/2021/swift-basic-syntax/:0:1","tags":["swift","语法基础","编程学习","ios"],"title":"Swift语法全面解析","uri":"/article/2021/swift-basic-syntax/"},{"categories":["Learn Swift","开发技能","编程经验","收集与整理"],"content":"基础部分 常量和变量 声明常量和变量， 常量和变量必须在使用前声明，使用 let 来声明常量，使用 var 来声明变量。 示例： let maximumNumberOfLoginAttempts = 10 var currentLoginAttempt = 0 // 类型注解 var welcomeMessage: String 注释 单行注释双正斜杠（//）， 多行注释（/* 多行的 */）。Swift 的多行注释可以嵌套在其它的多行注释之中。 示例： // 这是一个注释 /* 这也是一个注释， 但是是多行的 */ /* 这是第一个多行注释的开头 /* 这是第二个被嵌套的多行注释 */ 这是第一个多行注释的结尾 */ 分号 Swift 并不强制要求你在每条语句的结尾处使用分号（;）。 同一行内写多条独立的语句必须用分号分隔。 let cat = \"🐱\"; print(cat) // 输出“🐱” 标识符 标识符就是给变量、常量、方法、函数、枚举、结构体、类、协议等指定的名字。构成标识符的字母均有一定的规范，Swift语言中标识符的命名规则如下： 区分大小写，Myname与myname是两个不同的标识符； 标识符首字符可以以下划线（_）或者字母开始，但不能是数字； 标识符中其他字符可以是下划线（_）、字母或数字。 例如： userName、User_Name、_sys_val、身高等为合法的标识符，而2mail、room#和class为非法的标识符。 注意:Swift中的字母采用的是Unicode编码。Unicode叫做统一编码制，它包含了亚洲文字编码，如中文、日文、韩文等字符，甚至是我们在聊天工具中使用的表情符号 如果一定要使用关键字作为标识符，可以在关键字前后添加重音符号（`），例如： let `class` = \"xiaobai\" 关键字 关键字是类似于标识符的保留字符序列，除非用重音符号（`）将其括起来，否则不能用作标识符。关键字是对编译器具有特殊意义的预定义保留标识符。常见的关键字有以下4种。 与声明有关的关键字 class deinit enum extension func import init internal let operator private protocol public static struct subscript typealias var 与语句有关的关键字 break case continue default do else fallthrough for if in return switch where while 表达式和类型关键字 as dynamicType false is nil self Self super true _COLUMN_ _FILE_ _FUNCTION_ _LINE_ 在特定上下文中使用的关键字 associativity convenience dynamic didSet final get infix inout lazy left mutating none nonmutating optional override postfix precedence prefix Protocol required right set Type unowned weak willSet Swift 空格 Swift对空格的使用有一定的要求。 在Swift中，运算符不能直接跟在变量或常量的后面。例如下面的代码会报错： let a= 1 + 2 错误信息是： error: prefix/postfix '=' is reserved 意思大概是等号直接跟在前面或后面这种用法是保留的。 下面的代码还是会报错（继续注意空格）： let a = 1+ 2 错误信息是： error: consecutive statements on a line must be separated by ';' 这是因为Swift认为到1+这个语句就结束了，2就是下一个语句了。 只有这样写才不会报错： let a = 1 + 2; // 编码规范推荐使用这种写法 let b = 3+4 // 这样也是OK的 整数、浮点数 统一使用 Int 可以提高代码的可复用性，避免不同类型数字之间的转换， 并且匹配数字的类型推断。 示例： let minValue = UInt8.min // minValue 为 0，是 UInt8 类型 let maxValue = UInt8.max // maxValue 为 255，是 UInt8 类型 类型安全和类型推断 Swift 是一门类型安全的语言，这意味着 Swift 可以让你清楚地知道值的类型。 如果你没有显式指定类型，Swift 会使用类型推断来选择合适的类型。（int、double）。 示例： let meaningOfLife = 42 // meaningOfLife 会被推测为 Int 类型 let pi = 3.14159 // pi 会被推测为 Double 类型 数值型字面量、数值型类型转换 示例： let decimalInteger = 17 let binaryInteger = 0b10001 // 二进制的17 let octalInteger = 0o21 // 八进制的17 let hexadecimalInteger = 0x11 // 十六进制的17 类型别名 类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用 typealias 关键字来定义类型别名。 示例： typealias AudioSample = UInt16 var maxAmplitudeFound = AudioSample.min // maxAmplitudeFound 现在是 0 布尔值 示例： let orangesAreOrange = true let turnipsAreDelicious = false 元组 元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。 示例： let http404Error = (404, \"Not Found\") // http404Error 的类型是 (Int, String)，值是 (404, \"Not Found\") 可选类型 使用可选类型（optionals）来处理值可能缺失的情况。可选类型表示两种可能：或者有值， 你可以解析可选类型访问这个值， 或者根本没有值。 示例： var serverResponseCode: Int? = 404 // serverResponseCode 包含一个可选的 Int 值 404 serverResponseCode = nil // serverResponseCode 现在不包含值 错误处理 错误处理，应对程序执行中可能会遇到的错误条件。 示例： func makeASandwich() throws { // ... } do { try makeASandwich() eatASandwich() } catch SandwichError.outOfCleanDishes { washDishes() } catch SandwichError.missingIngredients(let ingredients) { buyGroceries(ingredients) } 断言和先决条件 断言和先决条件，是在运行时所做的检查。 let age = -3 assert(age \u003e= 0, \"A person's age cannot be less than zero\") // 因为 age \u003c 0，所以断言会触发 基本运算符 Swift 支持大部分标准 C 语言的运算符，还提供了 C 语言没有的区间运算符，例如 a..\u003cb 或 a...b。 赋值运算符，算术运算符，组合赋值运算符，比较运算符，三元运算符，空合运算符，区间运算符，逻辑运算符 运算符分为一元、二元和三元运算符。 闭区间运算符（a…b）定义一个包含从 a 到 b（包括 a 和 b）的所有值的区间。 半开区间运算符（a..\u003cb）定义一个从 a 到 b 但不包括 b 的区间。 闭区间操作符有另一个表达形式，可以表达往一侧无限延伸的区间，(a…，…b)。 示例： let names = [\"Anna\", \"Alex\", \"Brian\", \"Jack\"] let count = names.count for i in 0..\u003ccount { print(\"第 \\(i + 1)个人叫 \\(names[i])\") } // 第 1 个人叫 Anna // 第 2 个人叫 Alex // 第 3 个人叫 Brian // 第 4 个人叫 Jack 字符串和字符 字符串字面量，字符串插值，计算字符数量，访问和修改字符串，子字符串，比较字符串 初始化空字符串，字符串可变性，字符串是值类型，连接字符串和字符(+，+=)。 使用字符，可通过 for-in 循环来遍历字符串，获取字符串中每一个字符的值。 字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。可以在已有字符串中插入常量、变量、字面量和表达式从而形成更长的字符串。 Swift 提供了三种方式来比较文本值：字符串字符相等、前缀相等和后缀相等。 示例： // 多行字符串字面量 let quotation = \"\"\" The White Rabbit put on hi","date":"2021-05-13","objectID":"/article/2021/swift-basic-syntax/:0:2","tags":["swift","语法基础","编程学习","ios"],"title":"Swift语法全面解析","uri":"/article/2021/swift-basic-syntax/"},{"categories":["收集与整理","编程经验"],"content":" 在 Linux 上测试软件时，我使用各种架构的服务器，例如 Intel、AMD、Arm 等。当我 分配了一台满足我的测试需求的 Linux 机器[1]，我仍然需要执行许多步骤： 下载并安装必备软件 验证构建服务器上是否有新的测试软件包 获取并设置依赖软件包所需的 yum 仓库 下载并安装新的测试软件包（基于步骤 2） 获取并设置必需的 SSL 证书 设置测试环境，获取所需的 Git 仓库，更改配置，重新启动守护进程等 做其他需要做的事情 ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:0","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"用脚本自动化 这些步骤非常常规，以至于有必要对其进行自动化并将脚本保存到中央位置（例如文件服务器），在需要时可以在此处下载脚本。为此，我编写了 100-120 行的 Bash shell 脚本，它为我完成了所有配置（包括错误检查）。这个脚本通过以下方式简化了我的工作流程： 配置新的 Linux 系统（支持测试的架构） 登录系统并从中央位置下载自动化 shell 脚本 运行它来配置系统 开始测试 ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:1","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"学习 Go 语言 我想学习 Go 语言 有一段时间了，将我心爱的 Shell 脚本转换为 Go 程序似乎是一个很好的项目，可以帮助我入门。它的语法看起来很简单，在尝试了一些测试程序后，我开始着手提高自己的知识并熟悉 Go 标准库。 我花了一个星期的时间在笔记本电脑上编写 Go 程序。我经常在我的 x86 服务器上测试程序，清除错误并使程序健壮起来，一切都很顺利。 直到完全转换到 Go 程序前，我继续依赖自己的 shell 脚本。然后，我将二进制文件推送到中央文件服务器上，以便每次配置新服务器时，我要做的就是获取二进制文件，将可执行标志打开，然后运行二进制文件。我对早期的结果很满意： $ wget http://file.example.com/\u003cmyuser\u003e/bins/prepnode $ chmod +x ./prepnode $ ./prepnode 然后，出现了一个问题 第二周，我从资源池中分配了一台新的服务器，像往常一样，我下载了二进制文件，设置了可执行标志，然后运行二进制文件。但这次它出错了，是一个奇怪的错误： $ ./prepnode bash: ./prepnode: cannot execute binary file: Exec format error $ 起初，我以为可能没有成功设置可执行标志。但是，它已按预期设置： $ ls -l prepnode -rwxr-xr-x. 1 root root 2640529 Dec 16 05:43 prepnode 发生了什么事？我没有对源代码进行任何更改，编译没有引发任何错误或警告，而且上次运行时效果很好，因此我仔细查看了错误消息 format error。 我检查了二进制文件的格式，一切看起来都没问题： $ file prepnode prepnode: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped 我迅速运行了以下命令，识别所配置的测试服务器的架构以及二进制试图运行的平台。它是 Arm64 架构，但是我编译的二进制文件（在我的 x86 笔记本电脑上）生成的是 x86-64 格式的二进制文件： $ uname -m aarch64 ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:2","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"脚本编写人员的编译第一课 在那之前，我从未考虑过这种情况（尽管我知道这一点）。我主要研究脚本语言（通常是 Python）以及 Shell 脚本。在任何架构的大多数 Linux 服务器上都可以使用 Bash Shell 和 Python 解释器。总之，之前一切都很顺利。 但是，现在我正在处理 Go 这种编译语言，它生成可执行的二进制文件。编译后的二进制文件由特定架构的指令码或汇编指令组成，这就是为什么我收到格式错误的原因。由于 Arm64 CPU（运行二进制文件的地方）无法解释二进制文件的 x86-64 指令，因此它抛出错误。以前，shell 和 Python 解释器为我处理了底层指令码或特定架构的指令。 ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:3","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"Go 的交叉编译 我检查了 Golang 的文档，发现要生成 Arm64 二进制文件，我要做的就是在运行 go build 命令编译 Go 程序之前设置两个环境变量。 GOOS 指的是操作系统，例如 Linux、Windows、BSD 等，而 GOARCH 指的是要在哪种架构上构建程序。 $ env GOOS=linux GOARCH=arm64 go build -o prepnode_arm64 构建程序后，我重新运行 file 命令，这一次它显示的是 ARM AArch64，而不是之前显示的 x86。因此，我在我的笔记本上能为不同的架构构建二进制文件。 $ file prepnode_arm64 prepnode_arm64: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, not stripped 我将二进制文件从笔记本电脑复制到 ARM 服务器上。现在运行二进制文件（将可执行标志打开）不会产生任何错误： $ ./prepnode_arm64 -h Usage of ./prepnode_arm64: -c Clean existing installation -n Do not start test run (default true) -s Use stage environment, default is qa -v Enable verbose output ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:4","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"其他架构呢？ x86 和 Arm 是我测试软件所支持的 5 种架构中的两种，我担心 Go 可能不会支持其它架构，但事实并非如此。你可以查看 Go 支持的架构： $ go tool dist list Go 支持多种平台和操作系统，包括： AIX Android Darwin Dragonfly FreeBSD Illumos ios Js/wasm JavaScript Linux NetBSD OpenBSD Plan 9 Solaris Windows 要查找其支持的特定 Linux 架构，运行： $ go tool dist list | grep linux 如下面的输出所示，Go 支持我使用的所有体系结构。尽管 x86_64 不在列表中，但 AMD64 兼容 x86-64，所以你可以生成 AMD64 二进制文件，它可以在 x86 架构上正常运行： $ go tool dist list | grep linux linux/386 linux/amd64 linux/arm linux/arm64 linux/mips linux/mips64 linux/mips64le linux/mipsle linux/ppc64 linux/ppc64le linux/riscv64 linux/s390x ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:5","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"处理所有架构 为我测试的所有体系结构生成二进制文件，就像从我的 x86 笔记本电脑编写一个微小的 shell 脚本一样简单： #!/usr/bin/bash archs=(amd64 arm64 ppc64le ppc64 s390x) for arch in ${archs[@]} do env GOOS=linux GOARCH=${arch} go build -o prepnode_${arch} done $ file prepnode_* prepnode_amd64: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=y03MzCXoZERH-0EwAAYI/p909FDnk7xEUo2LdHIyo/V2ABa7X_rLkPNHaFqUQ6/5p_q8MZiR2WYkA5CzJiF, not stripped prepnode_arm64: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, Go BuildID=q-H-CCtLv__jVOcdcOpA/CywRwDz9LN2Wk_fWeJHt/K4-3P5tU2mzlWJa0noGN/SEev9TJFyvHdKZnPaZgb, not stripped prepnode_ppc64: ELF 64-bit MSB executable, 64-bit PowerPC or cisco 7500, version 1 (SYSV), statically linked, Go BuildID=DMWfc1QwOGIq2hxEzL_u/UE-9CIvkIMeNC_ocW4ry/r-7NcMATXatoXJQz3yUO/xzfiDIBuUxbuiyaw5Goq, not stripped prepnode_ppc64le: ELF 64-bit LSB executable, 64-bit PowerPC or cisco 7500, version 1 (SYSV), statically linked, Go BuildID=C6qCjxwO9s63FJKDrv3f/xCJa4E6LPVpEZqmbF6B4/Mu6T_OR-dx-vLavn1Gyq/AWR1pK1cLz9YzLSFt5eU, not stripped prepnode_s390x: ELF 64-bit MSB executable, IBM S/390, version 1 (SYSV), statically linked, Go BuildID=faC_HDe1_iVq2XhpPD3d/7TIv0rulE4RZybgJVmPz/o_SZW_0iS0EkJJZHANxx/zuZgo79Je7zAs3v6Lxuz, not stripped 现在，每当配置一台新机器时，我就运行以下 wget 命令下载特定体系结构的二进制文件，将可执行标志打开，然后运行： $ wget http://file.domain.com/\u003cmyuser\u003e/bins/prepnode_\u003carch\u003e $ chmod +x ./prepnode_\u003carch\u003e $ ./prepnode_\u003carch\u003e ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:6","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"为什么？ 你可能想知道，为什么我没有坚持使用 shell 脚本或将程序移植到 Python 而不是编译语言上来避免这些麻烦。所以有舍有得，那样的话我不会了解 Go 的交叉编译功能，以及程序在 CPU 上执行时的底层工作原理。在计算机中，总要考虑取舍，但绝不要让它们阻碍你的学习。 ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:7","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["收集与整理","编程经验"],"content":"参考 Cross-compiling made easy with Golang [1] 使用 Golang 的交叉编译 [2] ","date":"2021-05-13","objectID":"/article/2021/go_cross_compilling/:0:8","tags":["Golang","编程学习"],"title":"使用 Golang 的交叉编译","uri":"/article/2021/go_cross_compilling/"},{"categories":["Using Software"],"content":" 学习基本的 GNU Screen 终端复用技术，然后下载我们的终端命令备忘录，以便你能够熟悉常用的快捷方式。 对于一般用户而言，命令行终端窗口可能是令人困惑和神秘的。但随着你对 Linux 终端的进一步了解，你很快就会意识到它的高效和强大。不过，也不需要很长时间，你就会想让终端变得更加高效，除了将更多的终端放到你的终端，还有什么高好的方法能够提升你的终端效率呢？ ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:0","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"终端复用 终端的许多优点之一是它是一个集中控制的界面。它是一个能让你访问数百个应用程序的窗口，而你与每一个应用程序进行交互所需要的只是一个键盘。但是，现代计算机几乎总是有多余的处理能力，而且现代计算机专家喜欢多任务处理，导致一个窗口处理数百个应用程序的能力是相当有限的。 解决这一问题的常见答案是终端复用：即将虚拟终端叠放在一起，然后在它们之间移动的能力。通过终端复用器，你保持了集中控制，但是当你进行多任务时，你能够进行终端切换。更好的是，你能够在终端中拆分屏幕，使得在同一时间显示多个屏幕窗口。 ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:1","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"选择合适的复用器 一些终端提供类似的功能，有标签式界面和分割式视图，但也有细微的差别。首先，这些终端的功能依赖于图形化的桌面环境。其次，许多图形化的终端功能需要鼠标交互或使用不方便的键盘快捷键。终端复用器的功能在文本控制台上和在图形桌面上一样好用，而且键位绑定是针对常见的终端序列设计的，很方便。 现有两种流行的复用器：tmux 和 GNU Screen。尽管你与它们互动的方式略有不同，但它们做同样的事情，而且大多具有相同的功能。这篇文章是 GNU Screen 的入门指南。关于 tmux 的相关介绍，请阅读 Kevin Sonney 的 tmux 介绍。 ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:2","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"使用 GNU Screen GNU Screen 的基本用法很简单，通过 screen 命令启动，你将进入 Screen 会话的第 0 个窗口。在你决定需要一个新的终端提示符前，你可能很难注意到有什么变化。 当一个终端窗口被某项活动占用（比如，你启动了文本编辑器 Vim 或 Jove 或者你在处理音视频，或运行批处理任务），你可以新建一个窗口。要打开一个新的窗口，按 Ctrl+A，释放，然后按 c。这将在你现有窗口的基础上创建一个新的窗口。 你会知道当前你是在一个新的窗口中，因为你的终端除了默认的提示符外，似乎没有任何东西。当然，你的另一个终端仍然存在，它只是躲在新窗口的后面。要遍历打开的窗口，按 Ctrl+A，释放，然后按 n（表示下一个）或按 p（表示上一个）。在只打开两个窗口的情况下， n 和 p 的功能是一样的，但你可以随时打开更多的窗口（Ctrl+A，然后 c ），并在它们之间切换。 ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:3","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"分屏 GNU Screen 的默认行为更像移动设备的屏幕，而不是桌面：你一次只能看到一个窗口。如果你因为喜欢多任务而使用 GNU Screen ，那么只关注一个窗口可能看起来是一种退步。幸运的是，GNU Screen 可以让你把终端分成窗口中的窗口。 要创建一个水平分割窗口，按 Ctrl+A，然后按 s 。这将把一个窗口置于另一个窗口之上，就像窗格一样。然而，在你告诉它要显示什么之前，分割的空间是没有用途的。因此，在创建一个分割窗后，你可以用 Ctrl+A ，然后用 Tab 移动到分割窗中。一旦进入，使用 Ctrl+A 然后 n 浏览所有可用的窗口，直到你想显示的内容出现在分割窗格中。 你也可以按 Ctrl+A 然后按 | （这是一个管道字符，在大多数键盘上通过按下 shift 键加上 \\）创建垂直分割窗口。 ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:4","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"自定义 GNU Screen GNU Screen 使用基于 Ctrl+A 的快捷键。根据你的习惯，这可能会让你感觉非常自然，也可能非常不方便，因为你可能会用 Ctrl+A 来移动到一行的开头。无论怎样，GNU Screen 允许通过 .screenrc 配置文件进行各种定制。你可以用这个来改变触发键的绑定（称为 “转义” 键绑定）。 escape ^jJ 你还可以添加一个状态行，以帮助你在 Screen 会话中保持自己不迷失。 # status bar, with current window highlighted hardstatus alwayslastline hardstatus string '%{= kG}[%{G}%H%? %1`%?%{g}][%= %{= kw}%-w%{+b yk} %n*%t%?(%u)%? %{-}%+w %=%{g}][%{B}%m/%d %{W}%C%A%{g}]' # enable 256 colors attrcolor b \".I\" termcapinfo xterm 'Co#256:AB=\\E[48;5;%dm:AF=\\E[38;5;%dm' defbce on 在有多个窗口打开的会话中，有一个时刻提醒哪些窗口具有焦点活动，哪些窗口有后台活动的提醒器特别有用。它类似一种终端的任务管理器。 ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:5","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"备忘单 当你学习 GNU Screen 的使用方法时，需要记住很多新的键盘命令。有些命令你马上就能记住，但那些你不常使用的命令可能就很难记住了。你可以按 Ctrl+A 然后再按 ? 来访问 GNU Screen 的帮助界面。 学习 GNU Screen 是提高你使用你最喜欢的 终端模拟器 的效率和敏捷性的一个好方法。请试一试吧！ ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:6","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":"参考 Linux tips for using GNU Screen [1] 使用 GNU Screen 的小技巧 [2] ","date":"2021-05-13","objectID":"/article/2021/linux_screen/:0:7","tags":["screen","linux","Mac","GNU Screen"],"title":"Linux/Mac 使用 GNU Screen 的小技巧","uri":"/article/2021/linux_screen/"},{"categories":["Using Software"],"content":" cron 是一个调度守护进程，它以指定的时间间隔执行任务，这些任务称为 corn 作业，主要用于自动执行系统维护或管理任务。例如，你可以设置一个 cron 作业来自动执行重复的任务，比如备份数据库或数据，使用最新的安全补丁更新系统，检查磁盘空间使用情况，发送电子邮件等等。 cron 作业可以按分钟、小时、日、月、星期或它们的任意组合运行。 cron 的一些优点 以下是使用 cron 作业的一些优点： 你可以更好地控制作业的运行时间。例如，你可以精确到分钟、小时、天等。 它消除了为循环任务逻辑而去写代码的需要，当你不再需要执行任务时，可以直接关闭它。 作业在不执行时不会占用内存，因此你可以节省内存分配。 如果一个作业执行失败并由于某种原因退出，它将在适当的时间再次运行。 安装 cron 守护进程 幸运的是，Fedora Linux 预先配置了运行重要的系统任务来保持系统更新，有几个实用程序可以运行任务例如 cron、anacron、at 和 batch 。本文只关注 cron 实用程序的安装。cron 和 cronie 包一起安装，cronie 包也提供 cron 服务。 ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:0","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"要确定软件包是否已经存在，使用 rpm 命令： $ rpm -q cronie Cronie-1.5.2-4.el8.x86_64 如果安装了 cronie ，它将返回 cronie 包的全名。如果你的系统中没有安装，则会显示未安装。 ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:1","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"使用以下命令安装： $ dnf install cronie ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:2","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"运行 cron 守护进程 cron 作业由 crond 服务来执行，它会读取配置文件中的信息。在将作业添加到配置文件之前，必须启动 crond 服务，或者安装它。什么是 crond 呢？crond 是 cron 守护程序的简称。要确定 crond 服务是否正在运行，输入以下命令： $ systemctl status crond.service ● crond.service - Command Scheduler Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor pre\u003e Active: active (running) since Sat 2021-03-20 14:12:35 PDT; 1 day 21h ago Main PID: 1110 (crond) 如果你没有看到类似的内容 Active: active (running) since…，你需要启动 crond 守护进程。要在当前会话中运行 crond 服务，输入以下命令： $ systemctl run crond.service 将其配置为开机自启动，输入以下命令： $ systemctl enable crond.service 如果出于某种原因，你希望停止 crond 服务，按以下方式使用 stop 命令： $ systemctl stop crond.service 要重新启动它，只需使用 restart 命令： $ systemctl restart crond.service 定义一个 cron 作业 ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:3","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"cron 配置 以下是一个 cron 作业的配置细节示例。它定义了一个简单的 cron 作业，将 git master 分支的最新更改拉取到克隆的仓库中： */59 * * * * username cd /home/username/project/design \u0026\u0026 git pull origin master 主要有两部分： 第一部分是 */59 * * * *。这表明计时器设置为第 59 分钟执行一次。 该行的其余部分是命令，因为它将从命令行运行。 在此示例中，命令本身包含三个部分： 作业将以用户 username 的身份运行 它将切换到目录 /home/username/project/design 运行 git 命令拉取 master 分支中的最新更改 ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:4","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"时间语法 如上所述，时间信息是 cron 作业字符串的第一部分，如上所属。它决定了 cron 作业运行的频率和时间。它按以下顺序包括 5 个部分： 分钟 小时 一个月中的某天 月份 一周中的某天 下面是一种更图形化的方式来解释语法： .--------------- 分钟 (0 - 59) | .------------- 小时 (0 - 23) | | .---------- 一月中的某天 (1 - 31) | | | .------- 月份 (1 - 12) 或 jan、feb、mar、apr … | | | | .---- 一周中的某天 (0-6) (周日=0 或 7) | | | | | 或 sun、mon、tue、wed、thr、fri、sat | | | | | * * * * * user-name command-to-be-executed ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:5","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"星号的使用 星号（*）可以用来替代数字，表示该位置的所有可能值。例如，分钟位置上的星号会使它每分钟运行一次。以下示例可能有助于更好地理解语法。 这个 cron 作业将每分钟运行一次： * * * * [command] 斜杠表示分钟的间隔数。下面的示例将每小时运行 12 次，即每 5 分钟运行一次： */5 * * * * [command] 下一个示例将每月的第二天午夜（例如 1 月 2 日凌晨 12:00，2 月 2 日凌晨 12:00 等等）： 0 0 2 * * [command] 关于 cron 时间格式，还有更多格式符号，此处没有展开 ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:6","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["Using Software"],"content":"使用 crontab 创建一个 cron 作业 cron 作业会在后台运行，它会不断检查 /etc/crontab 文件和 /etc/cron.*/ 以及 /var/spool/cron/ 目录。每个用户在 /var/spool/cron/ 中都有一个唯一的 crontab 文件。 不应该直接编辑这些 cron 文件。crontab 命令是用于创建、编辑、安装、卸载和列出 cron 作业的方法。 更酷的是，在创建新文件或编辑现有文件后，你无需重新启动 cron。 $ crontab -e 这将打开你现有的 crontab 文件，或者创建一个。调用 crontab -e 时，默认情况下会使用 vi 编辑器。注意：要使用 Nano 编辑 crontab 文件，可以设置 EDITOR=nano 环境变量。 使用 -l 选项列出所有 cron 作业。如果需要，使用 -u 选项指定一个用户。 $ crontab -l $ crontab -u username -l 使用以下命令删除所有 cron 作业： $ crontab -r 要删除特定用户的作业，你必须以 root 用户身份运行以下命令： $ crontab -r -u username cron 作业看起来可能只是系统管理员的工具，但它实际上与许多 Web 应用程序和用户任务有关。 参考 Fedora Linux 文档的 [1] 使用 cron 调度任务 [2] ","date":"2021-05-12","objectID":"/article/2021/linux_cron/:0:7","tags":["cron","linux","自动化任务"],"title":"使用 cron 调度自动化任务","uri":"/article/2021/linux_cron/"},{"categories":["收集与整理"],"content":"今日技术分享 unsafe 包真的不安全吗？ https://mp.weixin.qq.com/s/rIqkKNUecvnZ6gadThf4gg go-callvis 源码分析 https://mp.weixin.qq.com/s/dUXXGd8hqEhKE_Cj4EY2Lw 深度探索Go语言（二）：动态派发 https://mp.weixin.qq.com/s/fhpKBRqhRAxFnESQ4vTbWQ 再一次看到了 Go 的节制：int128 类型要不要支持？ https://mp.weixin.qq.com/s/5uW2rcIEhFPCCTPqrhwOow Go 笔试题精选 三： 19 道填空题 https://mp.weixin.qq.com/s/5Zd1DmQGDvjMySOUf7eFMg 在提赋能之前，先想想这5个问题 https://mp.weixin.qq.com/s/V8l7S7A-kRF_WDb7tlJJ0Q 代码无可避免腐化是因为这 5 个原因 https://mp.weixin.qq.com/s/IzDgV6AmK-2ph1ctcz9liA kubebuilder 实战: CRUD https://mp.weixin.qq.com/s/UDA55y5RCpzyDvfSfs9d2w 实现无限缓存的channel https://colobu.com/2021/05/11/unbounded-channel-in-go/ 轻轻松松打印网页并生成 pdf 文档 https://colobu.com/2021/05/05/generate-pdf-for-a-web-page-by-using-chromedp/ Go 1.16 的 signal.NotifyContext 让你的服务重启更优雅 https://juejin.cn/post/6960578101755510798 一种持锁被调度的情况 https://xargin.com/schedule-when-holding-lock-causes-latency-spike/ assembly 完全解析： https://segmentfault.com/a/1190000039978109?utm_source=tag-newest strace 的 10 个命令 https://colobu.com/2021/04/30/strace-commands-for-troubleshooting-and-debugging-linux/ 使eBPF工作在windows操作系统上 https://cloudblogs.microsoft.com/opensource/2021/05/10/making-ebpf-work-on-windows/ 油管视频：调试你的Go test代码：用printf还是delve https://www.youtube.com/watch?v=nmNVd7FbSYs 如何在你的本地项目中使用未发布的Go module https://iaziz786.com/blog/use-unpublished-go-modules Prometheus监控告警规则大全 https://awesome-prometheus-alerts.grep.to/ dblab: 支持与PostgreSQL和MySQL交互的终端命令行工具 https://github.com/danvergara/dblab 终端应用的自动黑暗模式 by vim-go作者 https://arslan.io/2021/02/15/automatic-dark-mode-for-terminal-applications/ 另一个开源的容器平台 https://github.com/sylabs/singularity 在Go中没有一个完美的切片克隆方案 https://github.com/go101/go101/wiki/There-is-not-a-perfect-slice-clone-way-in-Go 理解nil接口类型与值为nil的接口变量 https://trstringer.com/go-nil-interface-and-interface-with-nil-concrete-value/ 微软Teams的命令行终端UI工具 https://github.com/fossteams/teams-cli Kubernetes GUI大全 http://kokizzu.blogspot.com/2021/03/kubernetes-gui.html 如何做出你的第一个开源贡献 https://dev.to/codesandboxio/how-to-make-your-first-open-source-contribution-2oim 无服务器下的数据库 https://mp.weixin.qq.com/s/_MfuhpSAtZFnB8p-xp5HUw MySQL AUTO_UNCREMENT https://mp.weixin.qq.com/s/Ya3JrUftN0ASI8dTzb1lvw facebook google网络架构揭秘 https://mp.weixin.qq.com/s/MPBk9wdYsE48H7OXWAd5bA ","date":"2021-05-12","objectID":"/article/2021/go20210512/:0:0","tags":["技术分享","Golang"],"title":"Go20210512 今日技术分享","uri":"/article/2021/go20210512/"},{"categories":["关于"],"content":"关于我 勤奋的代码搬运工。 ","date":"2021-05-11","objectID":"/about/:0:1","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"为什么建立个人博客？ 宣传自己，这是一个信息爆炸、人人自我营销的时代，不懂得宣传自己，就得不到机会的垂青。 个人觉得IT从业者就应该有自己的博客网站，记录与分享自己的经验，收集有价值的文章。 凭借互联网的媒介，结交志同道合的朋友，为未来的事业做准备。 ","date":"2021-05-11","objectID":"/about/:0:2","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"关于本站 学习日记，点滴记录。 也会收集和分享互联网上比较经典且具有价值的文章。 ","date":"2021-05-11","objectID":"/about/:0:3","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"站长是谁： 昵称：白菜林 对于技术很爱折腾、很有热情的小哥。 联系站长：77370751（微信/qq同号，备注来意） 邮箱Email：77370751@qq.com 交流QQ群：153690156 给我留言：https://support.qq.com/product/325110 ","date":"2021-05-11","objectID":"/about/:0:4","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"我的主页 Gitee: https://lyhuilin.gitee.io/ Github: https://github.com/clin003/meBlog ","date":"2021-05-11","objectID":"/about/:0:5","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"我的微信公众号 ","date":"2021-05-11","objectID":"/about/:0:6","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"未来发展： 未来很长，且慢慢耕耘。 ","date":"2021-05-11","objectID":"/about/:0:7","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"白菜林的博客小站历程： 2021年5月11日 白菜林的博客小站 建站并部署至Github page。 ","date":"2021-05-11","objectID":"/about/:0:8","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"特别感谢 非常感谢每一位走进本站的同学对我们的大力支持，你们的走进是我坚持的动力！ 如果不介意,请把本站分享给您的同学朋友！ 我会一直努力，不求最好，只求更好！ ","date":"2021-05-11","objectID":"/about/:0:9","tags":["about"],"title":"about me","uri":"/about/"},{"categories":["关于"],"content":"Hello World! 白菜林^_^ ","date":"2021-05-11","objectID":"/article/2021/hello_world/:0:0","tags":["about"],"title":"Hello world","uri":"/article/2021/hello_world/"},{"categories":["收集与整理"],"content":"今日技术分享 图解 Go 内存管理分配 https://mp.weixin.qq.com/s/bMr4lZgf-Fn1oaOSPPSDIQ Go 刷 leetcode 之任务调度器 https://mp.weixin.qq.com/s/oI441vsKhYninXJjg3t3yA 自己动手实现一个 kubectl exec https://mp.weixin.qq.com/s/VmEcIYfsUbgh-p4RCssGFQ 云上细粒度访问管理的参考架构 https://mp.weixin.qq.com/s/3sfWGKFa1POMFcWYJbk6Ug Go 工程师必学：Go 大杀器之跟踪剖析 trace https://mp.weixin.qq.com/s/7DY0hDwidgx0zezP1ml3Ig Go并发编程 — sync.Once 单实例模式的思考 https://mp.weixin.qq.com/s/nMHNujmbIx7uMqMtjUMTvQ kustomize 简明教程 https://mp.weixin.qq.com/s/JDsDOYaACgyt97-Nz5ScDw 你不知道的 Go 之 slice https://mp.weixin.qq.com/s/aOIp7jeBWubT-u85vQJxzA 缓存系统稳定性 - 架构师峰会演讲实录 https://mp.weixin.qq.com/s/o0qUY5zUjBQuOkx_4XGB6Q 微服务的灾难 https://mp.weixin.qq.com/s/bY2s7wjfggSt77kj8exYLQ 利用 NATS JetStream 构建分布式事件流系统 https://shijuvar.medium.com/building-distributed-event-streaming-systems-in-go-with-nats-jetstream-3938e6dc7a13 100 行 Golang 代码构建一个简单的终端仿真器 https://ishuah.com/2021/03/10/build-a-terminal-emulator-in-100-lines-of-go 编写简单的 CLI 程序：Python vs Go https://dev.to/jidicula/writing-a-simple-cli-program-python-vs-go-59kf 如何使用 Go，Maroto 和 GoFakeIt 创建 PDF https://dev.to/divrhino/creating-a-pdf-with-go-maroto-gofakeit-3c7m 一个用 Go 编写的类似 cowsay 的开源程序 weebsay https://github.com/irevenko/weebsay 最受欢迎的编程语言（1965/2021） https://statisticsanddata.org/data/the-most-popular-programming-languages-1965-2021/ 用NATS JetStream在Go中构建分布式事件流系统 https://shijuvar.medium.com/building-distributed-event-streaming-systems-in-go-with-nats-jetstream-3938e6dc7a13 外部secret管理系统与k8s的集成 https://github.com/external-secrets/kubernetes-external-secrets 生成随机的、可发音的名字，像docker给容器起的默认名字那样 https://github.com/lucasepe/codename Pixie为CNCF带来Kubernetes集群内的调试能力 https://thenewstack.io/pixie-brings-in-cluster-kubernetes-debugging-to-cncf/ bofied: 一个网络启动服务器，支持PXE服务协议 https://github.com/pojntfx/bofied 糟糕的磁盘性能 by Brendan Gregg http://www.brendangregg.com/blog/2021-05-09/poor-disk-performance.html 油管视频：使用go重头构建container https://www.youtube.com/watch?v=8fi7uSYlOdc milvus：开源向量数据库搜索引擎 https://github.com/milvus-io/milvus 使用go加速python代码 https://medium.com/geekculture/speed-up-python-with-golang-9a1d2c6067ab go语言编译器 https://mp.weixin.qq.com/s/UhxFOQBpW8EUVpFvqH2tMg 虚拟内存工作原理 https://mp.weixin.qq.com/s/c81Fvws0J2tHjcdTgxvv6g redis vs tendis https://mp.weixin.qq.com/s/MeYkfOIdnU6LYlsGb24KjQ ","date":"2021-05-11","objectID":"/article/2021/go20210511/:0:0","tags":["技术分享","Golang","微服务"],"title":"Go20210511 今日技术分享","uri":"/article/2021/go20210511/"}]